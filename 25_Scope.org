#+title: 作用域

每个标识符的定义或声明在程序的某些部分中可见，通常不包括整个程序。它可见的部分称为其 /作用域/ 。

通常，在源代码的顶层进行的声明 - 即不在任何块或函数定义中的声明 - 在此之后的整个源文件的内容中可见。
这被称为文件作用域（参见文件作用域变量）。

在代码块内部进行的声明，包括函数定义内部的声明，仅在这些代码块内部可见。这被称为块作用域。这里有一个例子：

#+begin_src c
void
foo (void)
{
  int x = 42;
}
#+end_src

上面的例子中，变量x具有块作用域；它仅在foo函数定义块内可见。
因此，其他代码块可以拥有自己的变量，也可以命名为x，而这些变量之间不会发生冲突。

在子块内声明的变量的作用域仅限于该子块。

#+begin_src c
void
foo (void)
{
  {
    int x = 42;
  }
  // x is out of scope here.
}
#+end_src

如果在一个代码块内声明的变量与该代码块外声明的变量同名，那么在其作用域内，代码块内部的定义将优先生效。

#+begin_src c
int x = 42;

void
foo (void)
{
  int x = 17;
  printf ("%d\n", x);
}
#+end_src

上面的代码将打印17，即函数体块中声明的变量x的值，而不是文件作用域中变量x的值。
我们说内部对x的声明在其作用域范围内遮蔽了外部对x的声明。

具有块作用域的声明可以被子块中具有相同名称的另一个声明所遮蔽。

#+begin_src c
void
foo (void)
{
  char *x = "foo";
  {
    int x = 42;
    …
    exit (x / 6);
  }
}
#+end_src

函数参数的作用域是整个函数体，但它可以被遮蔽。例如：

#+begin_src c
int x = 42;

void
foo (int x)
{
  printf ("%d\n", x);
}
#+end_src

的值，而不是文件作用域变量x的值。但是，

标签（参见goto语句）具有函数作用域：每个标签在包含的函数体中始终可见，无论在标签声明之前还是之后。

#+begin_src c
void
foo (void)
{
  …
  goto bar;
  …
  {  // Subblock does not affect labels.
    bar:
    …
  }
  goto bar;
}
#+end_src

除了标签之外，在声明之前，已声明的标识符对代码是不可见的。例如：

#+begin_src c
int x = 5;
int y = x + 10;
#+end_src

是正确的，但是：

#+begin_src c
int x = y + 10;
int y = 5;
#+end_src

在变量y声明之前无法引用该变量。
