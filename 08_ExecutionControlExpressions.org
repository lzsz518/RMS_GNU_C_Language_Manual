#+title: 08 执行控制表达式

* 执行控制表达式

本章介绍一种通过组合表达式来控制哪些表达式将被执行或以什么顺序执行。

** 逻辑运算

/逻辑运算/ 组合逻辑值，逻辑值在C语言中以数字的形式出现。任何具有数值的表达式都是有效的逻辑值：
0代表假，其余值代表真。指针类型也是有意义的逻辑值；空指针(0)代表假，非空指针代表真。(详见指针章节)
逻辑运算的值总是int类型的1或0。(详见整数章节)

逻辑运算主要作为if语句的条件使用，或者用来判断for与while语句是否应该结束。(详见语句)
然而，它们在任何允许整数值表达的情况下都是有效的。

'! exp'

  一元逻辑运算符“非”。如果exp的值是0那么表达式为真，反之为假。
  *注意* ：如果exp是左值或函数调用那么应该使用小括号包裹它。

'left && right'

  二元逻辑运算符"与"将计算left并且在必要时计算right。如果left和right都是真那么“与”表达式的值
  为真(1)，否则值为假(0)。当计算left为假时它将决定整个表达式为假，所以right不需要再被计算。

'left || right'

  二元逻辑运算符“或”将计算left并且在必要时计算right。如果left和right中任意一个为真(1)那么
  表达式的值为真(1)，否则值为假(0)。当计算left为真时它将决定整个表达式为真，所以right不需要再被计算。

  *注意* ： 绝不要以来“&&” 和 “||” 的优先级。当它们在一起使用时总是使用小括号来确定他们的结合顺序。例如：

#+begin_src c
  if ((r != 0 && x % r == 0)
      ||
      (s != 0 && x % s == 0))
#+end_src

** 逻辑运算与比较

逻辑运算符经常被用来进行比较。'&&' 和 '||'的优先级低于比较运算符和算术运算符。所以我们在书写表达式的时
省略使用小括号让表达式自己匹配执行顺序是很自然的事情。两个比较运算必须都为真：

#+begin_src c
  if (r != 0 && x % r == 0)
#+end_src

上面的例子展示了如何使用'&&'低优先级特性来保证如果左边操作数为假时忽略右边的操作数。因此这段代码永远不会
出现除以0的情况。

这等价于：

#+begin_src c
  if (r && x % r == 0)
#+end_src

逻辑值是一个简单的数字，所以r作为一个真值来测试它是否为零。但是r实际上并不是一个逻辑值--它时一个除数。
所以最好使用明确指定它不等于的代码风格(!= 0)。

这里是另外一个等价的形式：

#+begin_src c
  if (!(r == 0) && x % r == 0)
#+end_src

这说明了一元'!'运算符，以及在其操作数周围写括号的必要性。

** 逻辑运算与赋值

有一种情况下将赋值迁到今条件可以提高程序可读性。下面的例子使用一个假设有一个表示链表的类型--list；
例子的作用是检测链表是否至少包含两个链接(元素)，假设函数nonempty可以检测链表是否为空，如果是函数返回
逻辑值--真；list_next函数用来使链表从一个节点前进到下一个节点。我们假设链表绝不会是空指针，所以赋值
表达式的值永远为"真"(true)。

#+begin_src c
  if (nonempty (list)
      && (temp1 = list_next (list))
      && nonempty (temp1)
      && (temp2 = list_next (temp1)))
    …  /* use temp1 and temp2 */
#+end_src

如果nonempty的值是"假"(false)那么我们从'&&'运算符中得到了避免运行它右边所有代码的收益。唯一适合放置这些
赋值的地方是那些调用之中。

可以将上例改写成几个语句，但是这会将其变得更复杂。另一方面，当测试条件更复杂时，那么需要将其拆分成多条语句
以使其更清晰。

如果一个空的链表是一个空指针，我们可以将nonempty调用拆分：

#+begin_src c
  if ((temp1 = list_next (list))
      && (temp2 = list_next (temp1)))
   …
#+end_src

** 条件表达式

C语言中将选择两个表达式中的一个进行计算并返回其值：

#+begin_src c
  condition ? iftrue : iffalse
#+end_src

*** 条件运算符的规则

第一个操作数--/condition/ 应该是一个可以和0对比的值--一个数字或指针。如果它为真(非0)，那么条件表达式将
计算iftrue表达式并将其值作为条件表达式的值，反之则计算iffalse表达式并使其值作为条件表达式的值。条件表达式
总是只计算iftrue和iffalse其中之一，绝不可能同时计算它们。

求取绝对值的条件表达式为：

#+begin_src c
  (x >= 0 ? x : -x)
#+end_src

*注意* ：条件表达式的优先级向当低。如果希望在函数调用时在参数中使用它那么请在它们周围使用括号。为了代码的可读性
请总是使用括号将多于一行的代码括起来。

赋值运算和逗号运算的优先级比条条件运算更低，所以当它们出现在条件表达式中时，在它们周围写上括号。

*** 条件运算分支

我们将iftrue和iffalse称作条件的 /分支/ 。

一般情况下两个分支应该拥有相同的类型，但是也有一些例外允许它们时不同的类型。如果它们都是数值类型那么条件表达式
会将它们转换成它们的公共类型。(详见公共类型)

使用指针时，两个分支的指针可以指向相互兼容的类型(详见兼容类型)。在这个例子中，其目标类型结合了两个分支的所有的类型限定词。

如果一个分支是 void * 而另一个是指向一个对象(不是一个函数)的指针，条件表达式将转换void * 到另一个分支的类型。

如果一个分支是一个整形数0常量而另一个分支是一个指针，条件表达式转换0到另一个分支的指针的类型。

在GNU C的条件表达式中可以省略ifture分支。在这种情况下如果 /condition/ 是一个非零值那么它的值在经过公共类型转换后
将作为条件表达式的值。因此：

#+begin_src c
  x ? : y
#+end_src

在x为非零是其值为x否则为y。


当 /condition/ 会对后续执行产生影响使省略iftrue分支是非常有用的。在那种情况下，使用iftrue表达式两次会对后续执行产生两次影响，
但是如果省略iftrue则只产生一次影响。例如，我们假设nex_element函数使链表指针变量前进到下一个元素并且返回其指针：

#+begin_src c
  next_element () ? : default_pointer
#+end_src

这中方法使指针前进并且使用新元素的指针，但是当新指针为空时使用默认指针(default_pointer)。我们绝不应该使用如下的方法：

#+begin_src c
  next_element () ? next_element () : default_pointer
#+end_src

因为这会一次性让指针前进两个元素。

** 逗号运算

逗号运算代表示一个系列表达式按顺序执行。逗号表达式的值为这一系列被执行表达式中最后一个表达式的值；最后一个表达式之前的表达式
仅仅产生其自身的作用。逗号运算看起来如下：

#+begin_src c
  exp1, exp2 …
#+end_src

你可以以在表达式之间加上逗号的方式把任意数量的表达式捆绑在一起。

*** 逗号操作符的用途

通过逗号运算你可以将多个表达式连接成一个表达式，例如在for语句的头部：

#+begin_src c
  for (i = 0, j = 10, k = 20; i < n; i++)
#+end_src

前三条赋值语句初始化了i,j和k。for表达式的语法要求只是用一条语句进行初始化；我们使用逗号操作将三次赋值绑定成一个表达式，i=0，
j=0，k=20。这个技术一也对括号中的后三条循环推进表达式使用。

在for语句和while语句(详见循环语句)，逗号提供了在下一次迭代开始之前执行一些一操作的途径，例如：

#+begin_src c
  while (printf ("At the test, x = %d\n", x), x != 0)
#+end_src

*** 清晰的使用逗号运算符

总是使用小括号将逗号运算包裹，除非它时在一个表达式的最顶级或者一个if，for，while 或switch的括号中(详见语句章节)。例如：

#+begin_src c
  for (i = 0, j = 10, k = 20; i < n; i++)
#+end_src

赋值之间的逗号很清楚，因为它们在括号和分号之间。

函数调用中的参数也用逗号隔开，但这不是逗号运算符的一个实例。请注意以下的区别:

它将三个参数传递给foo

#+begin_src c
  foo (4, 5, 6)
#+end_src

和

#+begin_src c
  foo ((4, 5, 6))
#+end_src

它使用逗号运算符，只传递一个参数（值为6）。

*注意* ： 不要在一个函数的参数周围使用逗号运算符，除非它有助于理解代码。当你这样做时，不要把另一个参数的一部分放在同一行中。
相反，要加一个换行符，使逗号运算符周围的括号更容易看到，像这样

#+begin_src c
foo ((mumble (x, y), frob (z)), *p)
#+end_src


*** 何时不使用逗号运算

你可以在任何子表达式中使用逗号，但在大多数情况下，这只会使代码变得混乱，将除最后一个逗号分隔的表达式之外的所有表达式提升到更高的层次，
会更加清晰。因此，与其这样：

#+begin_src c
  x = (y += 4, 8);
#+end_src

以下方式更清晰：

#+begin_src c
  y += 4, x = 8;
#+end_src

或者：

#+begin_src c
  y += 4;
  x = 8; 
#+end_src

只有在没有更明确的涉及多个语句的替代方案的情况下，才使用逗号。

相比之下，不要犹豫在宏定义中的扩展部分使用逗号。在这种情况下，代码清晰度的权衡是不同的，因为宏的使用可能会提高整体的清晰度，
以至于宏的定义的丑陋是一个小小的代价。






























































