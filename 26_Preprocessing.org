#+title: 预处理

当GCC编译器对原文件进行编译时首先会进行文本替换与文件包含，这部分操作被称为预处理。

* 概述

GNU C在编译的第一阶段对C程序的每一行进行预处理。只有当一行包含预处理指令或使用宏时，
预处理器才对其进行处理，其他所有行都会在预处理之后保持不变。

以下是预处理所执行的一些任务。本章的其余部分将详细介绍这些内容。

 * 头文件的包含：头文件通常包含声明和宏定义，可以被替换到程序中。

 * 宏展开：您可以定义宏，宏是对任意C代码片段的缩写。预处理将宏替换为其定义。有些宏是自动预定义的。

 * 条件编译：您可以根据不同条件包含或排除程序的部分代码。

 * 行控制：如果您使用程序将源文件组合或重新排列成中间文件，然后再进行编译，您可以使用行控制来通知编译器每行源代码最初来自哪个文件。

 * 编译控制：#pragma和_Pragma可以调用一些特殊的编译器功能来处理特定的结构。

 * 诊断：您可以在编译时检测问题并输出错误或警告信息。

除了预定义宏的展开之外，所有这些操作仅在您使用预处理指令来请求它们时才会发生。

* 指令

预处理指令是程序中以‘#’开头的行。在‘#’之前和之后允许有空白字符。‘#’后面紧跟一个标识符，表示指令名称，
它指定要执行的操作。以下是一些示例：

#+begin_src c
#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
#+end_src

通常我们将指令写为#name，其中name是指令名称。例如，#define 表示定义宏的指令。

以‘#’开头的指令不能来自宏展开。另外，指令名称不会进行宏展开。因此，如果将foo定义为一个展开为define的宏，
那么#foo就不是一个有效的预处理指令。

C语言拥有固定数量的合法预处理指令，程序员不能自己定义新的预处理指令。

一些指令需要参数；这些参数位于指令行的其余部分，并且必须与指令名称用空白分隔开。
例如，#define 后面必须跟着宏的名称和宏的预期展开内容。

预处理指令不能跨越多行。但是，可以使用反斜杠换行符（backslash-newline）或者使用/*...*/风格的注释来延续行。
在指令被处理之前，这些反斜杠换行符或注释将被替换掉（替换为空白或删除），以便保持指令的连续性。

* 标记

预处理将C代码（去除其注释）划分为预处理标记，这些标记类似于C标记，但并不完全相同。以下是预处理标记的特点。

预处理标记的主要类别包括标识符、预处理数值、字符串常量、字符常量和标点符号；还有一些其他类型的预处理标记。

*标识符*

	标识符预处理标记在语法上类似于C中的标识符：它可以是由字母、数字或下划线组成的任意序列，
	还可以使用'\U'或'\u'表示非ASCII字符，但不能以数字开头。

	在预处理阶段，C语言的关键字没有特殊意义；在这个阶段，它们只是普通的标识符。
	因此，您可以定义一个宏，其名称是一个关键字。在预处理期间，唯一具有特殊意义的标识符是defined（请参阅defined）。

*预处理数值*

	预处理数值是指预处理阶段将其文本视为数字的内容，包括C语言的数值常量以及其他类似数值常量的字符序列。
	预处理并不尝试验证预处理数值是否在C语言中是有效的数字，实际上它不一定是一个合法的C语言数值。

	更准确地说，预处理数值以可选择以小数点开始，接着是必需的十进制数字，然后继续包含任意序列的字母、数字、下划线、
	小数点和指数部分。指数部分由两个字符组成，包括 'e+'、'e-'、'E+'、'E-'、'p+'、'p-'、'P+' 和 'P-'。
	（以 'p' 或 'P' 开头的指数部分是C99引入的，它们用于表示十六进制浮点常量。）

*标点*

	标点符号在语法上类似于运算符。以下是有效的标点符号：

#+begin_src c
	[  ]   (  )  {  }  .  ->
	++ --  &  *  +  -  ~  !
	/  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
	?  :   ;  ...
	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
	,  #   ##
	<: :>  <% %>  %:  %:%:
#+end_src

*字符串常量*

	在源代码中的字符串常量在预处理阶段被识别为一个单一的预处理标记。

*字符常量*

	在源代码中的字符常量在预处理阶段被识别为一个单一的预处理标记。

*头文件名*

	在#include指令内部，预处理器识别头文件名标记。它由'"name"'组成，
	其中name是除换行符和双引号之外的源代码字符序列，或者由'<name>'组成，
	其中name是除换行符和尖括号之外的源代码字符序列。

	在实际使用中，更方便的做法是将#include行视为不需要进行标记化的例外情况。

*其他*

	除此之外，在C源程序中任何其他有效的字符都会被视为独立的预处理标记。


一旦程序被划分为预处理标记，它们会保持独立直到预处理结束。
宏生成的两个连续标记会在必要时插入空格来保持它们的独立性。例如，

#+begin_src c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
#+end_src

唯一的例外是使用##预处理运算符，它将标记粘贴在一起（参见拼接）。

预处理将空字符（字符代码0）视为空格，但是对其生成警告，因为它可能对用户不可见（许多终端根本不显示它），
而且在文件中出现它很可能是一个错误。

* 头文件

头文件是一种C代码文件，通常包含C声明和宏定义（参见宏），用于在多个源代码文件之间共享。
您可以通过使用C预处理指令 #include 来请求在程序中使用头文件。

头文件有两个目的:

 * 操作系统使用头文件提供接口。您将操作系统提供的头文件包含在您的程序中，以提供您需要调用系统调用和库的定义和声明。

 * 特定程序的头文件包含特定程序源文件之间的接口声明。如果所有或大部分接口声明和宏定义在多个不同的源文件中都需要使用，那么为相关声明和宏定义创建一个头文件是一个不错的主意。

如果没有头文件那么就需要将相同内容在每个源文件中重新书写一遍，但是这样的重写不但浪费时间还容易出错。
有了头文件，相关的声明只出现在一个地方。如果它们需要被修改，您可以在一个地方进行修改，然后包含该头文件的程序在下次重新编译时会自动使用新版本。
头文件消除了查找和更改所有副本的工作量，同时也消除了未更改一个副本会导致程序内部不一致的风险。

在C语言中，通常的约定是给头文件命名以 .h 结尾。在头文件名称中，最好只使用字母、数字、破折号和下划线，并且最多只有一个点，这样可移植性最好。

** 包含头文件语法

您可以使用预处理指令 #include 来指定包含用户和系统头文件。它有两种变体：

#+begin_src c
#include <file>
#+end_src

	这个变体用于包含系统头文件。它在标准系统目录列表中搜索名为 "file" 的文件。您可以使用 -I 选项在此列表前添加目录
	（参见《使用GNU编译器集合》中的 "调用GCC"）。

#+begin_src c
#include "file"
#+end_src

	这个变体用于包含您自己程序的头文件。它首先在包含当前文件的目录中搜索名为 "file" 的文件，然后在引号目录中搜索，
	最后在用于 <file> 的相同目录中搜索。您可以使用 -iquote 选项在引号目录列表前添加目录。


在 #include 的参数中，无论是用引号括起来还是用尖括号括起来，它都像一个字符串常量一样运行，即不识别注释，并且不会展开宏名称。
因此，#include <x/*y> 表示包含一个名为 x/*y 的系统头文件。

一些系统将 ‘\’ 解释为文件名与路径的分隔符。所有系统以相同的方式解释 ‘/’。为了最大的可移植性，最好只使用 ‘/’。

在 #include 行的文件名后面放置除注释以外的任何内容都是错误的。

** 包含头文件操作

#include指令的工作原理是在继续处理当前文件之前扫描指定的头文件。预处理的结果包括已经生成的文本，
后跟预处理包含文件的结果，然后是继续处理#include指令之后的文本。
例如，如果有一个名为header.h的头文件，内容如下：

#+begin_src c
char *test (void);
#+end_src

假设main函数在名为program.c的源文并使用上面提到的头文件：

#+begin_src c
int x;
#include "header.h"

int
main (void)
{
  puts (test ());
}
#+end_src

结果等同于直接把头文件中的内容放置到program.c中

#+begin_src c
int x;
char *test (void);

int
main (void)
{
  puts (test ());
}
#+end_src


包含的文件不仅限于声明和宏定义；这些只是典型的用法。C程序的任何片段都可以从另一个文件中包含进来。
包含的文件甚至可以包含在包含文件中开始的语句的开头，或者在包含文件中结束的语句的结尾。
然而，被包含的文件必须由完整的标记组成。在被包含的文件中，如果注释或字符串文字在文件结束时没有关闭，
那么它们是无效的。为了错误恢复，编译器将在文件结束时终止它们的处理。

为了避免混淆，最好让头文件只包含完整的语法单元，例如函数声明或定义、类型声明等。

不管被包含的文件是否缺少最后的换行符，紧随#include指令的那一行始终被视为一个单独的行。在这里放置预处理指令也没有问题。

** 搜寻路径

GCC在寻找要包含的头文件时会查找多个不同的位置。在GNU系统和Unix系统上，系统头文件的默认目录包括：

#+begin_src 
libdir/gcc/target/version/include
/usr/local/include
libdir/gcc/target/version/include-fixed
libdir/target/include
/usr/include/target
/usr/include
#+end_src

在一些操作系统中，这个列表可能会有所不同。此外，对于C++，可能会添加其他目录用于头文件的查找。


在上述内容中，target是GCC配置为编译代码的系统的规范名称；通常情况下，
但并不总是与运行GCC的系统的规范名称相同。version是正在使用的GCC版本。

你可以通过命令行选项"-Idir"来增加这个列表。所有由"-I"指定的目录将按照从左到右的顺序在默认目录之前进行搜索。
唯一的例外是当"dir"已经是默认搜索目录之一时。在这种情况下，该选项会被忽略，系统目录的搜索顺序保持不变。

在将使用引号与尖括号所引用的路径合并之前，重复的路径将从他们各自的集合中移除。因此，如果一个路径分别出现在
使用引号和尖括号的引用集合之中，那么他可能在合并的路径集合中出现两次。

你可以通过使用"-nostdinc"选项来阻止GCC搜索任何默认目录。这在编译操作系统内核或其他不使用标准C库设施或标准C库本身
的程序时非常有用。当启用"-nostdinc"选项时，GCC之搜索-I指定的路径。

GCC首先在包含当前文件的目录中查找使用#include "file"指令请求的头文件，
然后在由"-iquote"选项指定的引号目录中查找，最后在它通常搜索系统头文件的位置查找。
例如，如果"/usr/include/sys/stat.h"文件中包含了#include "types.h"，
GCC将首先在"/usr/include/sys"目录中查找types.h，然后在引号目录中查找，最后在其通常的搜索路径中查找。

#line（参见Line Control）指令不会改变GCC对包含当前文件的目录的理解。

"-I-"是一种过时的、老式的方式来指定引号目录（quote directories）。要在名为"-"的目录中查找头文件，可以使用"-I./-"。
调整头文件搜索路径还有其他几种方法，请参阅《使用GNU编译器集合》中的《调用GCC》章节。

** 单次包含头文件


如果一个头文件被包含两次，编译器将会处理它的内容两次。这很可能导致错误，例如当编译器看到相同的结构体定义两次时会发生错误。

防止头文件重复包含的标准方法是使用条件编译将整个文件的真实内容包裹起来，就像这样：

#+begin_src c
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

the entire file

#endif /* !FILE_FOO_SEEN */
#+end_src

这个构造通常被称为包装器 #ifndef。当头文件再次被包含时，条件将为假，因为FILE_FOO_SEEN已经被定义。预处理器会跳过整个文件的内容，
因此在同一个模块中编译时将不会“再次看到”文件内容。

GCC在这种情况下甚至进一步优化了处理方式。它会记住哪些头文件有包装器 #ifndef。如果后续的#include指定了该头文件，
并且#ifndef中的宏仍然被定义，GCC将不再重新扫描整个文件。

你可以将注释放在头文件的包装器之外，这些注释不会干扰优化。

宏FILE_FOO_SEEN被称为控制宏或守卫宏。在用户头文件中，宏的名称不应以'_'开头。
在系统头文件中，它应该以'__'（或''后跟一个大写字母）开头，以避免与用户程序发生冲突。在任何类型的头文件中，
宏的名称应包含文件的名称和一些额外的文本，以避免与其他头文件发生冲突。


** 计算式包含

有时候需要从几个不同的头文件中选择一个包含到程序中。这些头文件可能指定了在不同类型的操作系统上使用的配置参数，
例如，你可以通过一系列条件语句来实现这一点。

#+begin_src c
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
/* … */
#endif
#+end_src

那样很快就会变得乏味。GNU C提供了使用宏作为头文件名的功能。这被称为计算式包含（Computed Include）。
在#include的直接参数中，你只需放置一个宏名即可，而不是写上头文件名：

#+begin_src c
#define SYSTEM_H "system_1.h"
/* … */
#include SYSTEM_H
#+end_src


SYSTEM_H被展开后，system_1.h会被包含，就好像#include指令是用system_1.h这个名字写的。
SYSTEM_H可以通过你的Makefile使用-D选项进行定义。


在定义这样的宏时必须小心。#define保存的是标记（tokens），而不是文本。GCC无法知道宏将作为#include指令的参数使用，
因此它生成普通的标记，而不是头文件名。如果你使用双引号包含（double-quote includes），
这与字符串常量在语法上相似，那么这可能不会引起问题。然而，如果你使用尖括号包含（angle brackets），可能会遇到问题。

计算式包含的语法实际上比上述所述的更加通用。如果在#include指令后的第一个非空白字符不是'“'或'<'，
那么整行代码将会像普通代码一样进行宏展开。

如果计算式包含展开为一个单独的字符串常量，那么该字符串常量的内容将作为要包含的文件名。
预处理器不会重新检查字符串中是否有嵌套的引号，也不会处理字符串中的反斜杠转义符。
因此，计算式包含是在宏展开阶段进行处理的，不会再次解析字符串中的引号或反斜杠转义符。

#+begin_src c
#define HEADER "a\"b"
#include HEADER
#+end_src

查找名为a\"b的文件，计算式包含会根据双引号包含（double-quoted includes）的规则来搜索这个文件。

如果计算式包含展开的结果是一个以'<'标记开头且包含'>'标记的标记流（token stream），
那么位于'<'和第一个'>'之间的标记将被组合成要包含的文件名。在组合文件名时，任何标记之间的空格都会被缩减为一个空格；
然后在初始的'<'后面的空格会保留，但在结束的'>'之前的末尾空格将被忽略。
预处理器会根据尖括号包含（angle-bracket includes）的规则来搜索该文件。

在任何情况下，如果在文件名之后的行上存在任何标记，都会导致错误，并且该指令不会被处理。
如果展开的结果不符合预期的两种形式之一，也会引发错误。

这些规则是根据C标准定义的实现定义行为。为了最大限度地减少不同编译器对计算式包含的解释差异，
我们建议你只使用一个类似对象的宏，其展开结果是一个字符串常量。这样做也有助于程序读者更好地理解代码。
























