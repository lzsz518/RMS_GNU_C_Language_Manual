#+title: 算术

* 算术运算

C语言中的算术运算符试图尽可能地类似于现实中的算术运算，但是不可能做到完全一样。计算机可以表示的数值都被
限定在一个范围内，并且对于非整数的数值在精度上也有一定的限制。尽管如此，在大多数情况下不必对使用'+'表示加法，
'-'表示减法，'*'表示乘法感到意外。

C语言的运算符都具有优先级--一种规定运算符在各种表达式中运算先后顺序的等级。优先级最高的运算符首先对相邻的
操作数产生作用；然后这些表达式将成为优先级较低的运算符的操作数。本章我们仅讨论本章所使用到的运算符的优先级，
对于全部运算符优先级的讨论请见二元运算符语法章节。

算数运算符在对其操作数产生作用之前总是先提升他们的域。这意味着总是转换表示较小范围的数据类型到较大范围的
数据类型。详情请见操作数提升章节。如果只是学习C语言那么可以暂时忽略这部分内容。


如果操作符有两个操作数那么总是将他们转换为 /公共类型/ 。例如：一个int 和一个 double变量在一起那么他们
的 /公共类型/ 就是 double(这是因为double可以表示int可以容纳的所有数值，但反之则不然）。详情请见公共类型章节。

** 基础运算

C语言中的基础算数通常是两个操作数的代数：加法（'+'），减法（'-'），乘法（'*'）和除法（'/'）。一元运算符'-'用于更改数字的符号。
'+'也可以作为一元操作符，但是它不会对操作数产生任何影响。

'/'是除法操作符，但是整数除法可能不会得到你所期望的值。当除法是一个分数时其值是整数但是不等于数学上的商。当有必要时使用'%'来取得
除法的余数。详情请见除法和余数章节。浮点除法产生的数值比较接近数学上的商数。

这些运算符使用现实中代数上的先乘除后加减的优先级规则(详情请见二元操作语法)，但是你可以使用小括号来指定他们的运算顺序。他们是向
左结合的，因此：

#+begin_src c
  -a + b - c + d * e / f
#+end_src

等价于

#+begin_src c
  (((-a) + b) - c) + ((d * e) / f)
#+end_src

** 整数运算

C语言的运算都可以使用两种类型的整数： 有符号型和无符号型。操作数的类型将决定使用那种类型。

C语言中的每个整数数据类型都是有符号或无符号的。有符号类型可以容纳包括0在内何其左右数量近乎相等的正负整数(可以容纳的正整数总是比负整数少一个)。
无符号数可以容纳大于等于0的整数。

多数整数变量被声明为 /int/ 型， /int/ 型可以容纳的数值范围从 -2,147,483,648 到 2,147,483,647, /unsigned int/ 型可以容纳数值范围从0 到 4,294.967,295。
(这里假设 /int/ 型变量为32 bits 位宽，这对于GNU C 编译器和桌面型计算机总是成立但是对于嵌入式系统却不一定。) 关于整数类型详情请见整数类型章节。

如果给予算术运算符两个有符号操作数那么结果为有符号数，如果给予两个无符号数那么结果为无符号数。

如果一个操作数是无符号但是另一个是有符号的那么运算符会将他们都当作无符号操作数对待。更通用的情况是操作数的公共类型将决定运算是否有符号。

使用'%d'打印数值较大的无符号数可能会得到令人意外的结果。尽管按照上面所说的规则计算时是使用的无符号数但是打印的结果可能会出现负号！

对于上述现象的解释是加法、减法和乘法对于操作数产生的位模式对于有符号数和无符号数都是一样的。区别只在于结果的数据类型，它影响到结果位模式的解释，
以及算术运算是否会溢出（见下一节）。

但是'%d'并不知道参数的数据类型，它只知道参数的位模式，并且将其按照有符号整数对待。如果需要打印无符号数那么需要使用'%u'来代替'%d'。
详情请见[[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output][The GNU C Library]]

C语言中的算数运算从来不直接在位宽小于 /int/ 的整数类型上进行(详情请见窄整数)。

** 整数溢出


当一个算术运算的数学值不符合所使用的数据类型的范围时，这被称为溢出。当它发生在整数运算中时，就是 /整数溢出/ 。

整数溢出只发生在算术操作中。根据定义类型转换操作不会导致溢出，即使是当结果不能适应其新类型时也不会。见整数转换。

有符号数使用补码形式表示，大多数负整数都找不到与其对应的正整数，因此应用'-'一元运算符在有符号整数上时有可能导致溢出。

*** 无符号数溢出

C语言忽略无符号数运算的溢出；真实的结果将是产生溢出的数值的2^n模，其中n是数据类型的比特位数。我们将这种行为称为"截断"，真是结果将取产生溢出的
数值的最低n位。

一个负数结果当取2^n的模后会得到一个正数，例如：
#+begin_src c
  unsigned int x = 1;
  unsigned int y;

  y = -x;
#+end_src

以上代码会导致溢出，因为-1不能被存储在无符号类型标量中。实际的结果是-1对2^n求模,结果是2^n-1。这时无符号整形变量可以表示的最大的数值，对于32位
usigned int 型数据那个数字将是4,294,967,295。

将上述数字和它自己相加：

#+begin_src c
  unsigned int z;

  z = y + y;
#+end_src

应该得到8,489,934,590；然而，这又大到32位整型变量无法容纳，所以溢出将该值截断为4,294,967,294。如果这是一个有符号的整数，它将意味着-2，这（并非巧合）等于-1+-1。

*** 有符号数溢出

C语言并没有定义如何处理有符号数溢出的原则，这意味着可能发生不可预测的情况。因此C语言编译器可以对其进行忽略来产生优化效果。(由原则未定义所以不能说这样的优化是错误的)

*当心* ：编译器对代码的优化可能产生意想不到的结果。例如：

#+begin_src c
  int i;
  ...
  if( i < i +1 )
    x = 5;
#+end_src

编译器可以对以上代码进行取消条件表达式的优化，因为如果在不发生溢出的情况下条件表达式永远为真。

GCC提供编译器选项来控制处理有符号整数溢出。 这些选项按模块运行，每个模块的行为都取决于它编译时使用的选项。

一共有两个与默认规则不同的选项：

 * -fwrapv

   给予有符号整数溢出一个良好的定义，像对待无符号数一样：最低的n(变量类型拥有的比特数)位是运算结果，溢出
   的数值的最高位作为结果的符号位。使用次选项，这些超出范围的操作不被视为溢出，所以（严格来说）整数溢出永远不会发生。

   此选项启用了一些基于值溢出结果的优化。在GCC第8版中禁止了基于假设有符号整数操作不会溢出的优化。

 * -ftrapv

   当有符号整数发生溢出时会产生一个SIGFPE信号。如果程序不对这个信号进行处理那么程序会被终止。详情请见信号章节。

还有一个选项对于寻找溢出发生的地方很有用：

 * -fsanitize=signed-integer-overflow

    当有符号的整数溢出发生时，在运行时输出一个警告信息。这将检查'+'、'*'和'-'运算符。这个选项会优先于-ftrapv被编译器使用。

** 混合模式算数运算

当在算数运算中混合使用整数和浮点数时整数会被自动转换成浮点数。大多数情况下这个操作将会产生与预期相符的结果。但是这要看转换发生在哪里。

如果i和j是整数，(i + j) * 2.0将它们作为整数相加，然后将总和转换为浮点进行乘法。如果加法得到溢出，这不等同于将两个整数转换为浮点，
然后再相加。你可以通过显式转换整数得到后一种结果，如((double) i + (double) j) * 2.0。

几个数值相加或相乘，包括一些整数和一些浮点，从左到右进行运算。因此，3.0 + i + j将i转换为浮点数，然后加上3.0，再将j转换为浮点数并加上。
你可以用圆括号指定不同的顺序。3.0 + (i + j) 先加上i和j，然后把这个结果（转换为浮点数）加到3.0。在这方面，C语言与其他语言不同，如Fortran。















