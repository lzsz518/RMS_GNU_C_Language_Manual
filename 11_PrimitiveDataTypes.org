#+title: 基本数据类型

本章将讲述C语言的所有基本数据类型，即所有不是从其他数据类型构建起来的类型。这其中就包括
之前章节涵盖过的 *int* 和 *double* 类型。

这些类型都是由字节组成的。

** 整数类型(Integer)

本节讲述说有整数类型和它们的基本特性。若要从比特级更多的了解整数数据的呈现和算术请参考
深入整数章节。

*** 整数基础

C语言中的整形数据可以是有符号或无符号的。无符号类型只能呈现整数和零。有符号类型可以呈现
正数和负数，它们的范围是以零为中心正负数绝对值几乎相同的一个区间。

除了整数的符号以外，整数数据类型的大小各不相同：它们一共有多少个字节。字节数决定该类型
可以存储多大的整数值。

下面的列表是有符号整数数据类型和它们所拥有的字节数。它们都有与其对应的无符号数。
详情请见有符号和无符号类型章节。

*signed char*

    1个字节(8比特位)。这种整数类型主要用于代表字符的整数，作为数组或其他数据结构的一部分。

*short*
*short int*

    2个字节(16比特位)。

*int*

    4个字节(32比特位)。

*long*
*long int*

    4字节(32比特位)或8字节(64比特位)，根据不同的平台而定。通常，在32位计算机上是32位，
    在64位计算机上是64位，但也有例外。

*long long*
*long long int*

    8字节(64比特位)。GNU C在1980年代开始支持此类型，国际标准化组织(ISO)在1999年的
    C99标准中开始支持此类型。

当你使用long或short时，你可以省略int。这是无害和惯用的。

*** 有符号与无符号类型
无符号类型只能呈现整数和零。有符号类型可以呈现正数和负数，它们的范围是以零为中心正负数
绝对值几乎相同的一个区间。比如说， *unsigned char* 可以容纳的数值从0到255(在大多数计算机中)，
而 *signed char* 可以容纳的数值从-128到127。每个类型都可以容纳256个不同的数值，因为它们
都是8比特位宽。

在类型关键字之前使用 *signed* 或 *unsigned* 可以指定类型是有符号或无符号的。然而，除了
*char* 之外的整数类型都是默认有符号的，对他们使用 *signed* 是没有意义的。

普通 *char* 可以是有符号或无符号的；这取决于编译器、使用的机器和其操作系统。

在许多程序中，char是否有符号并无区别。当符号确实重要时，不要让编译器决定，请明确使用
*signed char* 或 *unsigned char* 。

*** 窄整数

比 *int* 拥有更少字节的的类型(窄整形)很少用于普通变量--我们使用 *int* 替代它们，因为C语言会将
任何算术运算中较 *int* 拥有更少字节的类型转换成 *int* 类型。比如说从字面上来看没有理由
将一个局部变量声明为 *char* 类型。

特别是即使数值是一个 *char* 类型也应该该将其声明成 *int* 类型而不是 *char* ! 使用窄整形将会
迫使编译器为了类型转换二阶段数值，这时一种浪费。此外，一些函数要么返回一个字符值，要么返回-1表示
"无字符"。使用int可以保持这些值的区别。

窄的整数类型作为其他对象的一部分是很有用的，如数组和结构。比较一下这些数组声明，
它们在32位处理器上的大小显示出来了：

#+begin_src c
  signed char ac[1000];   /* 1000 bytes */
  short as[1000];         /* 2000 bytes */
  int ai[1000];           /* 4000 bytes */
  long long all[1000];    /* 8000 bytes */
#+end_src

此外，字符串必须由字符组成，因为这也是所有标准库中的字符串函数所期望的。因此，数组ac可以作为字符串使用，
但其他的就不行了。

*** 整数类型之间的转换

在许多情况下，C语言在整数类型之间进行隐式转换。在任何算术运算中 *char* 和 *short* 类型都会被转换成
*int* 类型。对一个变量进行赋值(或者其他左值)会将值转换成变量的类型。

你也可以使用类型转换运算符转换一个整数类型到另外一个指定的类型。详见显式类型转换。

转换到较宽整形的操作非常直接：数值不会被改变。唯一例外是转换一个负值(一个明显的有符号类型)到较宽的
类型。在这种情况下转换的结果是将符号位直接作为数值的最高位的正整数。(详见深入整数)。

转换到较窄的整数类型也被成为 /截断/ ，这涉及到丢弃被转换数值的一些比特位。这不被认为是溢出因为有效
比特位的丢失是阶段的正常后果。对于拥有同样位宽的有符号和无符号类型之间的转换同样不被视为溢出。

更多关于赋值类型缓缓的信息在赋值类型转换章节，关于算术运算类型转换的信息在参数类型提升章节。

*** 布尔类型

无符号整型 *bool* 用来保存真值：0和1。转换所有非零值到 *bool* 都被转换为1。例如：

#+begin_src c
  bool a = 0;
  bool b = 1;
  bool c = 4; /* Stores the value 1 in c.  */
#+end_src

与 *int* 不同， *bool* 不是一个关键字。它被定义在stdbool.h头文件中。
