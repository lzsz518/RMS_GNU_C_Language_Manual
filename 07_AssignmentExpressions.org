#+title: 07 赋值表达式

* 赋值表达式

作为编程的基本概念， /赋值/ 是将一种数值存储到可以存储它的地方的结构，比如说存储到变量中。
这种地方被称为左值(lvalues)，因为它们是存有一个值的位置。

因为赋值操作会产生一个值所以它在C语言中被命名为 /赋值表达式/ 。一个简单的赋值看起来如下：

#+begin_src c
  lvalue = value-to-store
#+end_src

我们将其称为把表达式的值 /value-to-store/ 赋予 /lvalue/所在的位置，或存储到那里。
你可以把 "lvalue "中的 "l "看作是 "left "的意思，因为它是你放在赋值运算符左边的东西。

但这并不是唯一使用lvalue的途径，而且并不是所有的lvalue都可以被赋值。在赋值操作的左边使用
lvalue意味着它必须是可以被修改的。这意味着它在声明时不能使用类型修饰符 const (详情请见const章节)

把一个数值存储到lvalue之后其将作为赋值表达式的新值。这意味着可以在其他表达式中使用赋值表达式。
赋值表达式总是向右结合的，所以：

#+begin_src c
  x = y = z = 0;
#+end_src

等价于

#+begin_src c
  x = (y = (z = 0));
#+end_src

这是唯一有用的结合方式，因为其他方式：

#+begin_src c
  ((x = y) = z) = 0;
#+end_src

是无效的，因为赋值表达式 x = y 不是一个有效的左值(lvalue)。

*提醒* : 如果赋值表达式在另外一个表达式中并且这个表达式不是条件表达式、逗号分隔表达式或其他赋值表达式那么
请使用小括号将其包裹。

** 简单赋值

简单赋值表达式将计算赋值号右边操作数的值并存储到左边的左值中。例如将5存储到i中的赋值表达式为：

#+begin_src c
  i = 5
#+end_src

我们称其为一个将5赋值给i的赋值表达式。因为这是一个表达式所以没有在结尾使用分号。如果在结尾增加了分号那么它将
变为一个语句。

下面是另一个简单赋值表达式。它的操作数不是很简单但是它的赋值操作很简单。

#+begin_src c
  x[foo()] = y + 6
#+end_src

如果两边操作数的数值类型不同那么简单赋值表达式在可行的情况下会把右边操作数的类型转换到左值的类型。所有数值类型
都可以相互转换。

简单赋值表达式也可以使用非数值类型,例如：指针，结构体，联合体。

*警告* ： 不能对数组使用赋值操作因为数组在C语言中没有值；C语言的变量可以是数组但是它不能被作为一个整体进行操作。

** 左值

指明一块内存空间用来存储数值的表达式被称作左值(lvalue)，因此这款内存可以一直持有这个值。

标准的左值是：
 * 变量
 * 指针解引用表达式(一元操作符 '*')。
 * 使用'.'的结构体字段引用，如果字段是左值。
 * 使用'->'的结构体字段引用。'->'意味着指针解引用所以总是左值。
 * 联合体替代引用，成立条件和结构体相同。
 * 使用'[...]'的数组元素引用，如果数组是左值。

如果一个表达式是其他表达式的最外层那么它就不是一个左值。因此变量x是一个左值但是x + 0 不是，即使这两个表达式代表
同一个值(假设x是一个数值)。

数组可以是左值(上述规则决定他是否为左值)，但是在表达式中使用数组总是自动将其转换成指向其第一个元素的指针。这个
转换的结果不是左值，因此如果变量是数组那么你不能将其作为赋值操作左边的操作数。但是你可以给数组的元素赋值，类似
a[0]，因为a是左值所以数组的元素是左值。
































































