#+Title: 15 结构体

/结构体/ 是一种用户自定义的数据类型，它可以拥有不同的 /字段/ 。结构体中的字段都拥有名字和类型。

下面我们为给链表排序定义一个合适的结构体。链表的项包含一个整数和一个指向下一项的指针。

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };
#+end_src

这个结构体拥有一个类型标签所以其他代码可以使用它来定义这个结构类型的变量。这里的类型标签是 *intlistlink* 。
上面的结构体使用类型标签进行了递归定义。

你可以定义一个结构体而不使用类型标签，但是定义之后便无法再使用它。这只有在一些特殊场合有用，例如在
*typedef* 和 *联合体* 中。

结构体中的内容是大括号中的字段。每个字段都需要声明。在定义结构体时每一个字段都需要有一个明确的名字，但是
这个名字不会与程序中的其它名字产生冲突。

字段声明看起来就像是变量声明。你可以使用与变量声明相同的命名规则声明字段。

以上结构体有用两个字段。一个叫 *datum* 类型是 *int* 并可以为链表保存一个整数，另一个叫 *next* 类型是指向
另一个 *struct intlistlink* 的指针，从这个指针可以找到剩余的链表项。链表的最后一项中的 *next* 的值应该是 *NULL* 。

这个结构体是一个递归定义，因为 *next* 的类型是 *intlistlink* 类型。这样的递归定义是没有问题的；事实上你可以在
struck intlistlink 定之前使用类型 struct intlistlink *。这是因为在机器码的层级指向所有结构体的指针都是基本相同的。

结构体被定义之后，你可以声明一个 *struct intlistlink* 类型的变量：

#+begin_src c
  struct intlistlink foo;
#+end_src

结构定义本身可以作为变量声明的开始，所以你可以紧接着它声明变量，像这样:

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    } foo;
#+end_src

但是这看起来比较难看。将结构体的定义与使用它分开可以让代码看起来更清晰。

在代码块中声明结构体将会限制这个结构体的作用域仅仅存在于那个代码块中。这意味着这个结构体仅存在于那个代码块中。
在一个函数的参数列表中定义结构体：

#+begin_src c
  int f (struct foo {int a, b} parm);
#+end_src

(假设 *struct foo* 之前没被定义过) *struct foo* 的作用域仅限参数列表中；这没有任何用处所以会产生一个警告。

标准C语言需要结构体最少有一个字段，但是GNU C 没有这个限制。

* 结构体字段引用

结构体最常见的用处是对其字段进行存取，'.'(点)操作符用以完成该操作；写法类似 *对象.字段* 。

定义以下结构体和变量，

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };

  struct intlistlink foo;
#+end_src

你可以通过 *foo.datum* 和 *foo.next* 来引用结构体foo中的两个字段的值。这些字段都是左值所以你可以使用它们存取数值。

结构体经常会被动态分配(下一章节)，我们在引用它时需要通过指针。通过(*p).field 的形式访问有些繁琐，可以通过使用缩略
语的方式来简化访问: p->field. 例如假设程序中包含以下声明:

#+begin_src c
  struct intlistlink *ptr;
#+end_src

你可以使用 ptr->datum 和 ptr->next 来引用结构体指针中的两个字段。

如果一个一元运算符出现在使用'->'的表达式之前那么一元运算符会对'->'所引用的字段产生作用：

#+begin_src c
  -ptr->datum  等于   -(ptr->datum)
#+end_src

你可以在不使用小括号的情况下混合使用'->'和'.':

#+begin_src c
  struct { double d; struct intlistlink l; } foo;

  …foo.l.next->next->datum…
#+end_src

* 动态内存分配

若要给一个对象动态分配内存可以使用库函数 *malloc* (详见： [[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Basic-Allocation][The GNU C Library ]]GNU C 库函数手册)。这里演示如何动态分配一个
*struct intlistlink* 对象。若要使这段代码可以正常工作需要包含 *stdlib.h* :

#+begin_src c
  #include <stddef.h>  /* Defines NULL. */
  #include <stdlib.h>  /* Declares malloc.  */

  …

  struct intlistlink *
  alloc_intlistlink ()
  {
    struct intlistlink *p;

    p = malloc (sizeof (struct intlistlink));

    if (p == NULL)
      fatal ("Ran out of storage");

    /* Initialize the contents. */
    p->datum = 0;
    p->next = NULL;

    return p;
  }
#+end_src

*malloc* 的返回值是 *void* 类型，但是其赋值给 *p* 的时候会自动转换到 *struct intlistlink* *** 。 *malloc* 的返回值
总是充分对齐的(详见对其章节)，这使其可以转换到任意类型。

检测p是否为空是必要的因为当没有足够的可用内存时 *malloc* 会返回一个空指针。我们假设程序定义了 *fatal* 函数来向用户报告
致命错误。

这里展示如何在链表前面增加一个整数：

#+begin_src c
  struct intlistlink *my_list = NULL;

  void
  add_to_mylist (int my_int)
  {
    struct intlistlink *p = alloc_intlistlink ();

    p->datum = my_int;
    p->next = mylist;
    mylist = p;
  }
#+end_src

释放动态分配的对象的方法是调用 *free* 函数。这里是使用 *free* 函数释放链表中所有对象的例子：

#+begin_src c
  void
  free_intlist (struct intlistlink *p)
  {
    while (p)
      {
        struct intlistlink *q = p;
        p = p->next;
        free (q);
      }
  }
#+end_src

我们必须在一个对象被释放之前从其中提取 *next* 指针，因为 *free* 会删除对象中的数据。相同的原因，程序不应该使用被释放过
的对象中的元素。要确保这些不会发生最好清楚存储链表的变量，例如：

#+begin_src c
  free_intlist (mylist);

  mylist = NULL;
#+end_src

* 字段偏移

要确定一个结构体中一个字段的偏移量可以使用在 *stddef.h* 中的宏定义 *offsetof* 。看起来就像：

#+begin_src c
  offsetof (type, field)
#+end_src

例如：

#+begin_src c
  struct foo
  {
    int element;
    struct foo *next;
  };

  offsetof (struct foo, next)
  /* 在大多数机器上是 4.  有些机器上可能是 8.  */
#+end_src

* 结构体内存布局

本章及其后续章节是关于结构体的高级特性，如果你只是想学习C语言那么可以跳过这些章节。

合理的结构体内存布局对于硬件寄存器读写性能，共享内存中的数据存取和网络通信数据包的组合与拆分至关重要。对于避免由于使用结构体
导致的内存浪费同样重要。然而，内存布局依赖于具体的目标平台。每一种平台对于结构体内存布局都有具体的约定，编译器必须遵循这些约定。

以下是大多数平台对于结构体内存布局的约定：

结构体的字段按照其声明的顺序出现在结构体的内存布局中。在可能的情况下连续的字段在结构体中占据连续的字节。然而，如果一个字段需要
更多的字节来满足系统需要对齐的字节数那么C语言会在下一个字段出现之前补齐上一个字段对于对齐要求所缺少的字节。

当所有字段需要占据的字节都安排好之后结构体的对齐方式和大小就可以确定下来了。结构体的对齐方式指的是所有字段中需要最大的对齐字节。
结构体的大小是对齐方式整数倍。这可能需要在结构体的最后一个字段之后补充一些字节。

例如，我们假设 *char* 的大小是1对齐方式是1(永远是这样)， *int* 的大小和对齐方式都是4 (在大多数计算机上是这样)：

#+begin_src c
  struct foo
  {
    char a, b;
    int c;
  };
#+end_src

这个结构体在内存中将以4字节对齐的方式占用8个字节。 *a* 的偏移是0， *b* 的偏移是1， *c* 的偏移是4。在 字段 *b* 与 *c* 之间有
2字节的间隔以满足4字节的对齐方式。

对比下面的结构体：

#+begin_src c
  struct foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

这个结构体在内存中以4字节对齐的方式占用12个字节。 *a* 的偏移是0， *c* 的偏移是4， *b* 的偏移是8. 在字段 *a* 与 *c* 之间
有三个字节的间隔，在字段 *b* 之后又补充了三个字节。

以上两个结构体在C语言中拥有相同的字段，但是由于字段顺序的不同一个占用8字节内存另一个占用12字节内存。一个避免内存浪费的可靠的
途径是按照字节占用从大到小的顺序定义字段。

* 折叠结构体

在GNU C中你可以通过在 *struct* 关键字之后或结构体类型声明之后使用 *__attribute__((packed))* 强制结构体内存布局不进行内存对齐。
例如：

#+begin_src c
  struct __attribute__((packed)) foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

假设 *int* 的对齐方式是4字节，在不使用 *__attribute__((packed))* 时这个结构体将占用12字节内存(如上一章所述)。使用
*__attribute__((packed))* 后它只占用6字节内存，这相当于每一个字段实际占用内存字节数的和。

使用 *__attribute__((packed))* 会经常导致字段不会按照其应有的方式进行对齐。在获取未进行内存对齐的字段的地址时可能会得到一个
非法的指针。在不允许出现未内存地址未对齐的指针的机器上进行指针解引用会产生 *SIGSEGV* 信号。

* 比特字段

当定义一个整数类型的结构体字段时可以指定该字段占用的比特位数，我们称之为 /比特字段/ 。 这样做的好处是可以让连续的比特字段被一起
存储到更大的存储单元中。例如：

#+begin_src c
  unsigned char opcode: 4;
#+end_src

上面的语句指定地段只占用4个比特位。由于是无符号类型所以他的值域为0--15. 一个占用4比特的有符号字段如下：

#+begin_src c
  signed char small: 4;
#+end_src

其值域为 -8--7。

你可以使用以下方法将结构体中的一个有符号字节拆分成两部分:

#+begin_src c
  unsigned char opcode: 4;
  signed char small: 4;
#+end_src

使用比特字段以上两个数字被放到一个有符号 *char* 中。

接下来演示如何点定义一个只能存储0或者1的1比特字段：

#+begin_src c
  unsigned char special_flag: 1;
#+end_src

你也可以使用 *bool* 类型的比特字段：

#+begin_src c
  bool special_flag: 1;
#+end_src

除了使用 *bool* 类型以外(*bool* 类型总是无符号的，详见布尔类型章节)，请总是为比特字段指明是有符号还是无符号的。当没有指定符号类型
时会使用一个默认规则：如果比特字段时普通 *char* 类型那么它是有符号的，除非使用 *-funsigned-bitfields* 编译参数强制它默认为
无符号的。但是不依赖这种默认规则是比较明智的。

比特字段的特别之处是你不可以对其使用取地址符 '&'。它们并没有按照适当的大小和对齐方式来存储到对应的类型中，所以它们不能通过指向其
类型的指针被找到。

* 打包比特字段

当使用底层级硬件接口进行编程时需要使比特字段的布局符合硬件数据的布局，本章将阐述如何做到。

连续的比特字段会被打包到一起，但是每一个比特字段必须只能根据它的类型被填充到一个单一内存对象中。例如：

#+begin_src c
  unsigned short a : 3, b : 3, c : 3, d : 3, e : 3;
#+end_src

以上5个比特字段会被使用一个两字节 *short* 来存储。它们一共需要15比特， *short* 可以提供16比特。相比之下：

#+begin_src c
  unsigned char a : 3, b : 3, c : 3, d : 3, e : 3;
#+end_src

以上5个比特字段需要三个字节来存储。 *a* 和 *b* 可以存储在一个 *char* 中，但是剩余两个比特不足以存储 *c* (存储它们三个需要9个比特)。
所以 *c* 和 *d* 需要第二个 *char* ，在 *b* 和 *c* 之间会留有两个比特的间隔。最后 *e* 存储在第三个 *char* 中。 再对比以下定义：

#+begin_src c
  unsigned char a : 3, b : 3;
  unsigned int c : 3;
  unsigned char d : 3, e : 3;
#+end_src

只需要两个字节： *unsigned int* 允许 *c* 在一个字(2个字节)中跨越两个字节。

你可以通过定义匿名比特字段来在其他字段之间设置间隔。匿名比特字段看起来就像： *： nbits;* 。匿名字段就像其它字段以后会在结构体中被分配
空间。

你可以使用类型 *:0* 强制下一个比特字段存储到经过对齐的下一个内存对象中。

匿名比特字段与 *:0* 在语法上皆可用于普通的比特字段共存。下例展示如何做到：

#+begin_src c
  unsigned int a : 5, : 3, b : 5, : 0, c : 5, : 3, d : 5;
#+end_src

*a* 和 *b* 被存储到一个 *int* 中，它们之间有3比特的间隔，接下来 *:0* 强制 *c* 和 *d* 存储到下一个 *int* 中。

本章讲述的打包比特字段规则适用于大多数目标平台，包含所有常见的真实计算机。有些嵌入式控制器有用特殊的布局规则。

* 常量字段

结构体中定义的常量字段是不可以被赋值的(详见常量章节)。例如让我们来定义一个 *struct intlistlink* 的修改版：

#+begin_src c
  struct intlistlink_ro  /* “ro” for read-only.  */
    {
      const int datum;
      struct intlistlink *next;
    };
#+end_src

这个结构体可以被用来防止其它代码修改该它的 *datum* 字段：

#+begin_src c
  /* p 的类型是 struct intlistlink *.
     转换它到 struct intlistlink_ro *.  */
  struct intlistlink_ro *q
    = (struct intlistlink_ro *) p;

  q->datum = 5;     /* 非法! */
  p->datum = 5;     /* 合法 因为 *p 不是一个struct intlistlink_ro.  */
#+end_src

常量字段可以通过两种方式获取值：通过结构体的整体初始化和通过有用常量字段的结构体的指针来指向一个该字段已经拥有值的结构体对象。

任何常量字段都会使结构体赋值变得不可能(详见结构体赋值)，这是因为结构体赋值会对所有字段进行一对一的赋值。

* 长度为0的数组

GNU C允许长度为0的数组。这对于位于结构体最后的元素作为一个变长对象的首地址非常有用。下面的例子展示如何构造一个变长的结构体来保存
根据 *this_length* 来分配内存的列表：

#+begin_src c
  struct line {
    int length;
    char contents[0];
  };

  struct line *thisline
    = ((struct line *)
       malloc (sizeof (struct line)
               + this_length));
  thisline->length = this_length;
#+end_src

在C90标准中必须要让 *contents* 的长度为1，这意味着要么浪费存储空间要么使给予 *malloc* 的参数复杂化。

* 灵活数组字段

C99标准采用了一种更复杂的方式实现0长度数组字段，这种方式被称为 *灵活数组* ，它的实现方式是声明数组字段时省略长度，例如：

#+begin_src c
  struct line
  {
    int length;
    char contents[];
  };
#+end_src

灵活数组必须是结构体最后一个字段并且在它之前必须还存在另外一个字段。

在C语言的标准规定一个含有灵活数组字段的结构体不能作为另外一个结构体的一部分并且也不能是数组的元素。

GNU C允许对灵活数组字段进行静态初始化。静态初始化可以让零或数组有用足够的长度。

#+begin_src c
  struct f1 { int x; int y[]; } f1
  = { 1, { 2, 3, 4 } };
#+end_src

上面定义了一个名为 *f1* 的结构体，其类型是 *struct f1* 。在C语言中变量名和函数名从不会与结构类型标签产生冲突。

省略灵活数组字段的长度而让初始化来决定它的长度，这只有当灵活数组字段被定义在最外层的结构体中并且你声明了这个结构体类型的变量时才可以。
例如：

#+begin_src c
  struct foo { int x; int y[]; };
  struct bar { struct foo z; };

  struct foo a = { 1, { 2, 3, 4 } };        // 合法.
  struct bar b = { { 1, { 2, 3, 4 } } };    // 非法.
  struct bar c = { { 1, { } } };            // 合法.
  struct foo d[1] = { { 1 { 2, 3, 4 } } };  // 非法.
#+end_src

* 覆盖不同的结构体

小心在一个函数中使用不同的结构类型来引用相同的内存，因为GNU C在优化代码时会假设用户绝不会这样做。(详见别名章节)。
下面是一个会产生问题的类似别名的例子：

#+begin_src c
  struct a { int size; char *data; };
  struct b { int size; char *data; };
  struct a foo;
  struct b *q = (struct b *) &foo;
#+end_src

这里*q* 指向变量 *foo* 占据的内存地址，但是它们是两种不同的类型。类型 *struct a* 和 *struct b* 的定义类似，但是它们是不同的类型。
将它们穿插在一起引用类似：

#+begin_src c
  p->size = 0;
  q->size = 1;
  x = p->size;
#+end_src

GNU C会认为 *p->size* 在赋值给 *x* 时仍然是0。编译器"知道" *q* 指针指向 *srtuct b* 并且绝不会与 *struct a* 重叠。

其它编译器也许会进行相同的优化。*ISO C* 为了使优化有效会认为这种代码是错误的。

* 结构体赋值

赋值对于结构体来说就是数据拷贝。左边和后边的操作数必须拥有相同的类型。例如：

#+begin_src c
  #include <stddef.h>  /* Defines NULL. */
  #include <stdlib.h>  /* Declares malloc.  */
  …

  struct point { double x, y; };

  struct point *
  copy_point (struct point point)
  {
    struct point *p
      = (struct point *) malloc (sizeof (struct point));
    if (p == NULL)
      fatal ("Out of memory");
    ,*p = point;
    return p;
  }
#+end_src

名义上结构体赋值是依次拷贝每个字段，因此如果结构体拥有常量字段那么这个结构体类型是不允许被赋值的：

#+begin_src c
  struct point { const double x, y; };

  struct point a, b;

  a = b;            /* 错误! */
#+end_src

* 联合体

/联合体/ 类型是以多种数据类型使用同一块内存的类型。每一种替代类型都是一个拥有名称的数据类型的定义。一个联合体的定义如下：

#+begin_src c
  union name
  {
    alternative declarations…
  };
#+end_src

每一种替代类型的声明看起来就像一个除过比特字段以外的结构体字段的声明，例如：

#+begin_src c
  union number
  {
    long int integer;
    double float;
  }
#+end_src

以上联合体允许你粗出一个整型(long int)或一个浮点型数字(double)在同一块内存中。联合体占用字节的多少和对齐方式取决于占用字节最多的替代类型
，它们不一定是相同的。在上面的例子中， *double* 可能占用比 *long int* 更多的内存，但是在正常使用它时并不会导致任何为题。

这些成员不一定是不同的数据类型。有时，每个成员与数据的使用方式有关。例如：

#+begin_src c
  union datum
  {
    double latitude;
    double longitude;
    double height;
    double weight;
    int continent;
  }
#+end_src

以上联合体拥有一些数据，大多数时浮点型，但是仍然可以是一个存储在 *continent* 中的整型。你可以使用使用一个数据类型 *double* 来访问所有
相同的类型的数据，但是不同的成员名称会让程序看起来更清晰。

联合体的对齐类型是拥有最大对齐类型的替代类型的对其类型。联合体的占据字节的多少是占据字节最多的替代类型占据的字节数，它们会四舍五入到对齐
方式的整数倍(因为每一个类型的大小都是它的对齐类型的整数倍)。

联合体的所有备选类型地址都从联合本身的地址开始。如果一个备选类型比整个联合体占据的字节少那么它只从开始占用它应该占用的部分，后面的部分
会被其余备选类型使用。

*警告* ： 如果代码使用一种备选类型来存储数据然后使用另一种备选类型来访问数据，那么结果完全依赖于代码在何种计算机上执行。只有魔法师才允许
进行这样的操作。然而，当你需要这么做，联合体总会有办法做到。

赋值对于联合体来说就是拷贝素有数据。

* 使用联合体打包数据

有时候我们设计联合体的目的是打包多种内存对象到一个特定大小的内存空间中。例如：

#+begin_src c
  union bytes8
  {
    long long big_int_elt;
    double double_elt;
    struct { int first, second; } two_ints;
    struct { void *first, *second; } two_ptrs;
  };

  union bytes8 *p;
#+end_src

以上联合体可以被看作指针 *p* 指向的8字节有符号整数(p->big_int_elt)，或者一个有符号浮点数(p->double_elt)，或者一个整数对
(p->two_ints.first 和 p->two_ints.second)，或者一个指针对(p->two_ptrs.first 和 p->two_ptrs.second)。

要使用联合体节省存储空间，需要考虑所有类型所占字节的多少。上面的联合体期望指针与 *int* 类型占据相相同的字节数。在其它指针占用
8个字节的机器上这个联合体可能不会按照预期的方式工作。联合体本身的功能是正常的--如果你通过two_ints存储两个值并通过two_ints提取
它们，你将得到相同的整数--但有部分程序期望联合体为8字节长时可能会出错，或者至少会占用更多的空间。

以上的例子展示了一个结构体类型在没有标签时是很有用的。另一种有效地获得相同结果的方法是将数组作为联合的成员：

#+begin_src c
  union eight_bytes
  {
    long long big_int_elt;
    double double_elt;
    int two_ints[2];
    void *two_ptrs[2];
  };
#+end_src

* 类型转换到结构体

在GNU C中你可以显式转换任意属于联合体备选类型的变量到联合体类型；例如：

#+begin_src c
  (union eight_bytes) (long long) 5
#+end_src

这样的转换会让数值5称为一个拥有 *big_int_elt*备选类型的联合体 *eight_bytes* 的类型。

类型转换必须完全契合联合体中的某一个备选类型，所以下面的转换是非法的：

#+begin_src c
  (union eight_bytes) 5  /* 错误!  5 是 int. */
#+end_src

联合体之间的类型转换看起来与其它类型转换一样，除非特别指定被转换的类型是一个联合体。你可以使用结构体标签或被类型定义的名字来指定结构体类型。(详见定义类型名)

在联合体赋值时对右边的操作数使用类型转换后赋值给一个联合体类型的变量就如同存储一个数值到联合体的某个备选类型，例如：

#+begin_src c
  union foo u;

  u = (union foo) x   means   u.i = x

  u = (union foo) y   means   u.d = y
#+end_src

你也可以使用联合体类型转换作为函数的参数：

#+begin_src c
  void hack (union foo);
  …
  hack ((union foo) x);
#+end_src

* 结构体构造器

你可以通过将结构体的类型写在括号中来并在之后接着书写一个初始化器来构造一个结构体的值，这在声明结构体类型的变量时是合法的。例如对于以下结构体：

#+begin_src c
  struct foo {int a; char b[2];} structure;
#+end_src

你可以以下形式创建一个类型为 *struct foo* 的数值：

#+begin_src c
  ((struct foo) {x + y, 'a', 0})
#+end_src

上面指定 *x + y* 的值赋给字段 *a* ，字符 'a' 赋给字段 *b* 的第0个元素，空字符赋给字段 *b* 的第一个元素。

构造器外围的括号不是必须的，但是我们建议使用它以使表达式的嵌套关系更加清晰。

你也可以通过下面的方式明晰两个字段在初始化时的嵌套方式：

#+begin_src c
  ((struct foo) {x + y, {'a', 0} })
#+end_src

上面的初始化方式都与下面的语句表达式等价(详见语句表达式章节)：

#+begin_src c
  ({
    struct foo temp = {x + y, 'a', 0};
    temp;
  })
#+end_src

你也可以用同样的方式创建联合体数值，但是这没什么用处因为对于联合体这样的创建方式就等于类型转换：

#+begin_src c
    ((union whosis) {value})
  is equivalent to
    ((union whosis) (value))
#+end_src

* 无名类型字段

结构体或者联合体可以包换没有名字的结构体和联合体作为字段。例如：

#+begin_src c
  struct
  {
    int a;
    union
    {
      int b;
      float c;
    };
    int d;
  } foo;
#+end_src 

你可以使用 *foo* 访问无名联合体字段，就如同它们是与联合体处于同一级别的独立字段一样：

#+begin_src c
  foo.a = 42;
  foo.b = 47;
  foo.c = 5.25; //覆盖 foo.b 的值 
  foo.d = 314;
#+end_src

避免使用可能产生混淆的字段名，例如下面的定义：

#+begin_src c
  struct
  {
    int a;
    struct
    {
      int a;
      float b;
    };
  } foo;
#+end_src

这将使 *foo.a* 无法引用到任何一个字段。GNU C 会视这种模糊的定义为一个错误并报告它。
