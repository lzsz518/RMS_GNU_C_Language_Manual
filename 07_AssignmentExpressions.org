#+title: 07 赋值表达式

* 赋值表达式

作为编程的基本概念， /赋值/ 是将一种数值存储到可以存储它的地方的结构，比如说存储到变量中。
这种地方被称为左值(lvalues)，因为它们是存有一个值的位置。

因为赋值操作会产生一个值所以它在C语言中被命名为 /赋值表达式/ 。一个简单的赋值看起来如下：

#+begin_src c
  lvalue = value-to-store
#+end_src

我们将其称为把表达式的值 /value-to-store/ 赋予 /lvalue/所在的位置，或存储到那里。
你可以把 "lvalue "中的 "l "看作是 "left "的意思，因为它是你放在赋值运算符左边的东西。

但这并不是唯一使用lvalue的途径，而且并不是所有的lvalue都可以被赋值。在赋值操作的左边使用
lvalue意味着它必须是可以被修改的。这意味着它在声明时不能使用类型修饰符 const (详情请见const章节)

把一个数值存储到lvalue之后其将作为赋值表达式的新值。这意味着可以在其他表达式中使用赋值表达式。
赋值表达式总是向右结合的，所以：

#+begin_src c
  x = y = z = 0;
#+end_src

等价于

#+begin_src c
  x = (y = (z = 0));
#+end_src

这是唯一有用的结合方式，因为其他方式：

#+begin_src c
  ((x = y) = z) = 0;
#+end_src

是无效的，因为赋值表达式 x = y 不是一个有效的左值(lvalue)。

*提醒* : 如果赋值表达式在另外一个表达式中并且这个表达式不是条件表达式、逗号分隔表达式或其他赋值表达式那么
请使用小括号将其包裹。

** 简单赋值

简单赋值表达式将计算赋值号右边操作数的值并存储到左边的左值中。例如将5存储到i中的赋值表达式为：

#+begin_src c
  i = 5
#+end_src

我们称其为一个将5赋值给i的赋值表达式。因为这是一个表达式所以没有在结尾使用分号。如果在结尾增加了分号那么它将
变为一个语句。

下面是另一个简单赋值表达式。它的操作数不是很简单但是它的赋值操作很简单。

#+begin_src c
  x[foo()] = y + 6
#+end_src

如果两边操作数的数值类型不同那么简单赋值表达式在可行的情况下会把右边操作数的类型转换到左值的类型。所有数值类型
都可以相互转换。

简单赋值表达式也可以使用非数值类型,例如：指针，结构体，联合体。

*警告* ： 不能对数组使用赋值操作因为数组在C语言中没有值；C语言的变量可以是数组但是它不能被作为一个整体进行操作。

** 左值

指明一块内存空间用来存储数值的表达式被称作左值(lvalue)，因此这款内存可以一直持有这个值。

标准的左值是：
 * 变量
 * 指针解引用表达式(一元操作符 '*')。
 * 使用'.'的结构体字段引用，如果字段是左值。
 * 使用'->'的结构体字段引用。'->'意味着指针解引用所以总是左值。
 * 联合体替代引用，成立条件和结构体相同。
 * 使用'[...]'的数组元素引用，如果数组是左值。

如果一个表达式是其他表达式的最外层那么它就不是一个左值。因此变量x是一个左值但是x + 0 不是，即使这两个表达式代表
同一个值(假设x是一个数值)。

数组可以是左值(上述规则决定他是否为左值)，但是在表达式中使用数组总是自动将其转换成指向其第一个元素的指针。这个
转换的结果不是左值，因此如果变量是数组那么你不能将其作为赋值操作左边的操作数。但是你可以给数组的元素赋值，类似
a[0]，因为a是左值所以数组的元素是左值。

** 修改赋值

可以对常见结构使用缩写形式

#+begin_src c
  lvalue = lvalue + expression
#+end_src

等价于

#+begin_src c
  lvalue += expression
#+end_src

这样的形式被成为修改赋值。例如：

#+begin_src c
  i = i + 5;
  i += 5;
#+end_src

上面两条语句等价。第一条使用简单赋值，第二条使用修改赋值。

修改赋值适用于任何二元操作符。例如可以从一个左值减去一些值：

#+begin_src c
  lvalue -= expression
#+end_src

或者乘以一个值：

#+begin_src c
  lvalue *= expression
#+end_src

或者移位：

#+begin_src c
  lvalue <<= expression
  lvalue >>= expression
#+end_src

大多数情况下这些语法特性并不能使编程语言变得更强力但是可以提供很多方便。而且当左值包含需要调用或这计算的代码时简单赋值将
执行左值的代码两次但是修改赋值只执行一次。例如：

#+begin_src c
  x[foo()] = x[foo()] + 5;
#+end_src

在两次调用之间foo有可能每次返回不同的值。如果foo先返回1然后返回3那么效果是先将x[3]加5然后把值存储到x[1]中，反之亦可。
因为C语言并不指定那个foo先被计算，所以我们不知道他们的执行顺序。

类似这样有歧义的语句最好不要使用。

相比之下

#+begin_src c
  x[foo()] += 5;
#+end_src

是一个良好的语句：它只调用foo一次来决定那个x数组的元素被引用并且将其值加上5。

** 自增和自减运算

'++' 和 '--' 是 /自增/ 和 /自减/ 运算符。当对一个数值使用它们时这个数值自动加1或减1并且
不需要考虑它们的赋值操作因为他们拥有相当于赋值的效果。

使用'++'或'--'作为左值的前缀时其称为 /预增/ 或 /预减/ 。这里的加1或减1会直接作用于表达式
并且作为表达式的新值。例如：

#+begin_src c
  #include <stdio.h>   /* Declares printf. */

  int
  main (void)
  {
    int i = 5;
    printf ("%d\n", i);
    printf ("%d\n", ++i);
    printf ("%d\n", i);
    return 0;
  }
#+end_src

输出的结果为 5，6和6。表达式++i增加i的值从5到6，然后输出6。

使用'--'实现预减：

#+begin_src c
  #include <stdio.h>   /* Declares printf. */

  int
  main (void)
  {
    int i = 5;
    printf ("%d\n", i);
    printf ("%d\n", --i);
    printf ("%d\n", i);
    return 0;
  }
#+end_src

输出结果为5，4和4。

** 后增和后减

在左值之后使用'++'或'--'会有一些奇怪的效果：它将直接得到左值然后在将其加1或减1。因此i++的值就是i
但是i++将在"晚些时候"将i加1。这被称为后增或后减。例如：

#+begin_src c
  #include <stdio.h>   /* Declares printf. */

  int
  main (void)
  {
    int i = 5;
    printf ("%d\n", i);
    printf ("%d\n", i++);
    printf ("%d\n", i);
    return 0;
  }
#+end_src

输出结果为5，5和6。表达式i++的值为5，这就是i在当时的值，但是在"晚些时候"之后i从5增加到了6。

具体多晚是"晚些时候"? 这有很大的灵活性。自增将在下一个序列点处发生。简单来说就是语句结束处。
详情请见序列点章节。

如果一元操作符先于后增或后减出现在表达式中那么增量操作将优先于一元操作符执行：

#+begin_src c
  -a++ 等价于 -(a++)
#+end_src

这是唯一合理的解释；因为-a不是一个左值左移他不能被自增。

** 陷阱：子表达式中的赋值

在C语言中，表达式中每部分的计算顺序并不是固定的。除了极个别的情况，运算符可以被以任何顺序执行。
如果一个表达式的一部分对x赋值而另一部分使用x，其结果将是变幻莫测的因为这两部分都有可能在对方
之前或之后执行。

例如这段语义模糊的代码：

#+begin_src c
  x = 20;
  printf("%d,%d\n", x, x = 4);
#+end_src

如果第二个参数x在第三个参数x = 4之前被计算那么它的值是20，如果之后被计算那么它值是4。

明晰版本：

#+begin_src c
  y = 20;
  printf ("%d %d\n", y, x = 4);
#+end_src

另一个明晰版本：

#+begin_src c
  x = 4;
  printf ("%d %d\n", x, x);
#+end_src

这种问题在所有类型的赋值上都会出现，包括自增和自减。详情请见执行顺序章节。

然而在条件语句和循环语句的测试条件中与逻辑运算一起使用它却非常有用。详情请见逻辑与赋值。

** 从语句中分离赋值

在条件语句中使用赋值非常方便，但是却减少的程序的可读性。例如：

#+begin_src c
  if( x = advance(x))
    ...
#+end_src

上面代码的目的是调用advance(x)并测试它的值是否为0。然而读者可能忽略了这段代码使用了
’=‘ 而不是’==‘。实际上在条件语句中应该使用’==‘的地方使用’=‘是一个经常发生的错误，
所以GNU C会对这种情况给以一个警告以提示可能发生的错误。

如果将赋值从条件表达式中分离那么代码将更明晰：

#+begin_src c
  x = advance(x);
  if(x != 0)
    ...
#+end_src

这将不会发生在条件语句中给x赋值的错误。

另一个方法是使用逗号操作符：

#+begin_src c
  if(x = advance(x), x != 0)
    ...
#+end_src

然而，除非赋值非常短，否则将赋值放在一个单独的语句中通常会更清晰，因为它可以减少嵌套。
























































