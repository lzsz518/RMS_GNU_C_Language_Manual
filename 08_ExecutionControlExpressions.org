#+title: 08 执行控制表达式

* 执行控制表达式

本章介绍一种通过组合表达式来控制哪些表达式将被执行或以什么顺序执行。

** 逻辑运算

/逻辑运算/ 组合逻辑值，逻辑值在C语言中以数字的形式出现。任何具有数值的表达式都是有效的逻辑值：
0代表假，其余值代表真。指针类型也是有意义的逻辑值；空指针(0)代表假，非空指针代表真。(详见指针章节)
逻辑运算的值总是int类型的1或0。(详见整数章节)

逻辑运算主要作为if语句的条件使用，或者用来判断for与while语句是否应该结束。(详见语句)
然而，它们在任何允许整数值表达的情况下都是有效的。

'! exp'

  一元逻辑运算符“非”。如果exp的值是0那么表达式为真，反之为假。
  *注意* ：如果exp是左值或函数调用那么应该使用小括号包裹它。

'left && right'

  二元逻辑运算符"与"将计算left并且在必要时计算right。如果left和right都是真那么“与”表达式的值
  为真(1)，否则值为假(0)。当计算left为假时它将决定整个表达式为假，所以right不需要再被计算。

'left || right'

  二元逻辑运算符“或”将计算left并且在必要时计算right。如果left和right中任意一个为真(1)那么
  表达式的值为真(1)，否则值为假(0)。当计算left为真时它将决定整个表达式为真，所以right不需要再被计算。

  *注意* ： 绝不要以来“&&” 和 “||” 的优先级。当它们在一起使用时总是使用小括号来确定他们的结合顺序。例如：

#+begin_src c
  if ((r != 0 && x % r == 0)
      ||
      (s != 0 && x % s == 0))
#+end_src

** 逻辑运算与比较

逻辑运算符经常被用来进行比较。'&&' 和 '||'的优先级低于比较运算符和算术运算符。所以我们在书写表达式的时
省略使用小括号让表达式自己匹配执行顺序是很自然的事情。两个比较运算必须都为真：

#+begin_src c
  if (r != 0 && x % r == 0)
#+end_src

上面的例子展示了如何使用'&&'低优先级特性来保证如果左边操作数为假时忽略右边的操作数。因此这段代码永远不会
出现除以0的情况。

这等价于：

#+begin_src c
  if (r && x % r == 0)
#+end_src

逻辑值是一个简单的数字，所以r作为一个真值来测试它是否为零。但是r实际上并不是一个逻辑值--它时一个除数。
所以最好使用明确指定它不等于的代码风格(!= 0)。

这里是另外一个等价的形式：

#+begin_src c
  if (!(r == 0) && x % r == 0)
#+end_src

这说明了一元'!'运算符，以及在其操作数周围写括号的必要性。

** 逻辑运算与赋值

有一种情况下将赋值迁到今条件可以提高程序可读性。下面的例子使用一个假设有一个表示链表的类型--list；
例子的作用是检测链表是否至少包含两个链接(元素)，假设函数nonempty可以检测链表是否为空，如果是函数返回
逻辑值--真；list_next函数用来使链表从一个节点前进到下一个节点。我们假设链表绝不会是空指针，所以赋值
表达式的值永远为"真"(true)。

#+begin_src c
  if (nonempty (list)
      && (temp1 = list_next (list))
      && nonempty (temp1)
      && (temp2 = list_next (temp1)))
    …  /* use temp1 and temp2 */
#+end_src

如果nonempty的值是"假"(false)那么我们从'&&'运算符中得到了避免运行它右边所有代码的收益。唯一适合放置这些
赋值的地方是那些调用之中。

可以将上例改写成几个语句，但是这会将其变得更复杂。另一方面，当测试条件更复杂时，那么需要将其拆分成多条语句
以使其更清晰。

如果一个空的链表是一个空指针，我们可以将nonempty调用拆分：

#+begin_src c
  if ((temp1 = list_next (list))
      && (temp2 = list_next (temp1)))
   …
#+end_src

** 条件表达式

C语言中将选择两个表达式中的一个进行计算并返回其值：

#+begin_src c
  condition ? iftrue : iffalse
#+end_src

*** 条件运算符的规则

第一个操作数--/condition/ 应该是一个可以和0对比的值--一个数字或指针。如果它为真(非0)，那么条件表达式将
计算iftrue表达式并将其值作为条件表达式的值，反之则计算iffalse表达式并使其值作为条件表达式的值。条件表达式
总是只计算iftrue和iffalse其中之一，绝不可能同时计算它们。

求取绝对值的条件表达式为：

#+begin_src c
  (x >= 0 ? x : -x)
#+end_src

*注意* ：条件表达式的优先级向当低。如果希望在函数调用时在参数中使用它那么请在它们周围使用括号。为了代码的可读性
请总是使用括号将多于一行的代码括起来。

赋值运算和逗号运算的优先级比条条件运算更低，所以当它们出现在条件表达式中时，在它们周围写上括号。

*** 条件运算分支

我们将iftrue和iffalse称作条件的 /分支/ 。

一般情况下两个分支应该拥有相同的类型，但是也有一些例外允许它们时不同的类型。如果它们都是数值类型那么条件表达式
会将它们转换成它们的公共类型。(详见公共类型)

使用指针时，两个分支的指针可以指向相互兼容的类型(详见兼容类型)。在这个例子中，其目标类型结合了两个分支的所有的类型限定词。

如果一个分支是 void * 而另一个是指向一个对象(不是一个函数)的指针，条件表达式将转换void * 到另一个分支的类型。

如果一个分支是一个整形数0常量而另一个分支是一个指针，条件表达式转换0到另一个分支的指针的类型。

在GNU C的条件表达式中可以省略ifture分支。在这种情况下如果 /condition/ 是一个非零值那么它的值在经过公共类型转换后
将作为条件表达式的值。因此：

#+begin_src c
  x ? : y
#+end_src

在x为非零是其值为x否则为y。


当 /condition/ 会对后续执行产生影响使省略iftrue分支是非常有用的。在那种情况下，使用iftrue表达式两次会对后续执行产生两次影响，
但是如果省略iftrue则只产生一次影响。例如，我们假设nex_element函数使链表指针变量前进到下一个元素并且返回其指针：

#+begin_src c
  next_element () ? : default_pointer
#+end_src

这中方法使指针前进并且使用新元素的指针，但是当新指针为空时使用默认指针(default_pointer)。我们绝不应该使用如下的方法：

#+begin_src c
  next_element () ? next_element () : default_pointer
#+end_src

因为这会一次性让指针前进两个元素。

*** 逗号运算

逗号运算代表示一个系列表达式按顺序执行。逗号表达式的值为这一系列被执行表达式中最后一个表达式的值；最后一个表达式之前的表达式
仅仅产生其自身的作用。逗号运算看起来如下：

#+begin_src c
  exp1, exp2 …
#+end_src

你可以以在表达式之间加上逗号的方式把任意数量的表达式捆绑在一起。






































































