#+title: 类型转换

C语言在必要时会自动转换数据类型。此外，你还可以使用强制C语言进行显式转换。

* 显示转换

你可以使用一元转换运算符进行显式转换，该运算符的写法是在括号中的类型标识符（参见类型标识符）。
例如，(int) 是将类型转换为 int 类型的运算符。以下是一个使用示例:

#+begin_src c
{
  double d = 5.5;

  printf ("Floating point value: %f\n", d);
  printf ("Rounded to integer: %d\n", (int) d);
}
#+end_src


使用 (int) d 将一个 int 值作为参数传递给 printf，因此你可以使用 %d 来打印它。如果没有进行强制转换，
只使用 d 作为参数，则会将值作为 double 类型传递。这样使用 %d 将完全不起作用，结果将是无意义的。


要进行整数之间的除法而不进行四舍五入，可以先将其中一个整数转换为 double 类型：

#+begin_src c
(double) dividend / divisor
dividend / (double) divisor
#+end_src

只需要对其中一个整数进行强制转换就足够了，因为这将强制将公共类型转换为 double，从而使另一个整数自动转换。

以下是有效的强制转换类型：

 * 数值类型之间的强制转换，例如从整数类型到浮点数类型，或从浮点数类型到整数类型。
 * 指针类型之间的强制转换，例如将一个指向一个类型的指针转换为指向另一个类型的指针。需要注意的是，C标准中不支持在函数指针和数据指针之间进行转换。
 * 将指针类型转换为整数类型。
 * 将整数类型转换为指针类型。
 * 将一个联合类型的成员类型转换为该联合的其他成员类型。这是GNU扩展的一部分，不是标准C的一部分。
 * 将任何类型转换为 void 类型。

* 赋值类型转换

在赋值操作和其他一些上下文中，会自动进行某些类型转换。以下是赋值操作可以执行的类型转换：

 * 将任何数值类型转换为任何其他数值类型。
 * 将 void * 转换为任何其他指针类型（除了指向函数类型的指针）。
 * 将任何其他指针类型转换为 void *（除了指向函数类型的指针）。
 * 将 0（空指针常量）转换为任何指针类型。
 * 将任何指针类型转换为 bool。如果指针不为 null，则结果为 1。
 * 在左边的目标类型向上兼容于右边的目标类型时，可以进行指针类型之间的转换。参见 Compatible Types。

这些类型转换在以下特定上下文中会自动发生：

 * 赋值操作将右侧表达式的类型转换为左侧表达式所需的类型。例如
#+begin_src c
double i;
i = 5;
#+end_src

5将被转换为double型。

 * 函数调用时，如果函数指定了参数的类型，将会将参数值转换为该类型。例如，

#+begin_src c
void foo (double);
foo (5);
#+end_src

5将被转换为double型。

 * 返回语句将指定的值转换为函数声明的返回类型。例如，

#+begin_src c
double
foo ()
{
  return 5;
}
#+end_src

5仍然将被转换为double型。

在上面三种情况下，如果不能进行类型转换，那就会产生一个错误。

* 参数提升

当函数的定义或声明未指定参数的类型时，该参数将按照其当前的类型原样传递，不进行转换，但有以下几个例外情况：

 * 某些窄数值会提升为更宽的类型。如果表达式是窄整数类型，如 char 或 short，函数调用会自动将其转换为 int 类型（参见整数类型）。
 例如表达式c将被当作int传递:

#+begin_src c
char c = '$';

printf ("Character c is '%c'\n", c);
#+end_src

 * 如果表达式的类型是 float，函数调用会自动将其转换为 double 类型。
 * 作为参数的数组会被转换为指向其第一个元素的指针。
 * 作为参数的函数名会被转换为指向该函数的指针。

* 操作数提升

在算术操作中，操作数会自动进行类型转换。这些操作数提升与参数提升相同，只是不会将 float 转换为 double。
换句话说，操作数提升会将：


 * char 或 short（无论是否有符号）转换为 int。
 * 数组转换为指向其第一个元素的指针。
 * 函数名转换为指向该函数的指针。

* 公共类型

算术二元运算符（除了移位运算符）在对操作数进行运算之前，将它们转换为公共类型。
条件表达式也会将两种可能的结果转换为它们的公共类型。以下是确定公共类型的规则：


如果其中一个数是浮点数类型，而另一个是整数类型，那么公共类型就是浮点数类型。例如，

#+begin_src c
5.6 * 2   ⇒ 11.2 /* a double value */
#+end_src

如果两个操作数都是浮点数类型，那么具有较大范围的类型将成为公共类型。


如果两个操作数都是整数类型但所占字节数不同，那么占有较多字节数的类型将成为公共类型。


如果它们是占有相同字节的整数类型，如果其中一个操作数是无符号的，那么公共类型就是无符号类型；
如果其中一个操作数是 long 类型，那么公共类型就是 long 类型；如果其中一个操作数是 long long 类型，
那么公共类型就是 long long 类型。


这些规则适用于加法、减法、乘法、除法、取余、比较和位运算。
它们也适用于条件表达式的两个分支以及修改赋值操作中的算术运算。
