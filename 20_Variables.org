#+title: 变量

在C语言程序中只有通过声明才可以让程序知道变量的存在。只有在声明之后，才能使用该变量。在同一作用域内多次声明变量名是错误的；
但有一个例外，即在变量的暂时定义(定义变量时不初始化)时使用extern关键字可以与同一个变量的另一个声明共存。

变量可以在块或文件的任何位置进行声明。（C语言的早期版本要求在块内的所有变量声明都在任何语句之前发生。）


在函数或块内声明的变量是局部变量。这意味着该变量的名称仅在该函数或块的结束之前可用，并且内存空间只在控制流程位于该函数或块内时分配。

在文件的顶层声明的变量称为文件范围变量。它们被分配固定且独立的内存位置，因此在它们的值将在程序的整个执行工程中可用。

* 声明变量

变量声明看起来就像：

#+begin_src c
  keywords basetype decorated-variable [= init];
#+end_src

关键字指定了如何处理变量名的作用域和存储分配。大多数声明没有关键字，因为默认设置对它们来说是正确的。

C允许这些关键字出现在基本类型之前、之后，甚至中间，比如unsigned static int，但不要这样做，
这会让其他程序员感到惊讶。请始终将关键字写在最前面。

基本类型可以是C预定义的任何类型，或者是使用typedef定义的类型关键字。它还可以是结构体标签（struct tag）、
联合体标签（union tag）或枚举标签（enum tag）。此外，它还可以包含类型限定符，如const和volatile（参见类型限定符）。

在普通情况下，声明变量时只使用基本类型修饰变量名，例如：

#+begin_src c
  int foo;
#+end_src

使用int作为基本类型，foo作为修饰过的变量。这将声明类型为int的变量foo。

#+begin_src c
  struct tree_node foo;
#+end_src

声明类型为struct tree_node的变量foo。

** 声明数组与指针

要声明数组变量，使用variable[length]来修饰变量名：

#+begin_src c
  int foo[5];
#+end_src

要声明指针变量，使用*variable来修饰变量名：

#+begin_src c
  struct list_elt *foo
#+end_src

这些结构可以嵌套，例如：

#+begin_src c
  int foo[3][5];
#+end_src

声明foo为有用三个数组每个数组有5个整型元素的数组：

#+begin_src c
  struct list_elt *foo[5];
#+end_src

声明foo为拥有5个结构体类型元素的指针数组，和

#+begin_src c
  struct list_elt **foo;
#+end_src

声明foo为指向结构体的指针的指针。

#+begin_src c
  int **(*foo[30])(int, double);
#+end_src

声明foo为一个包含30个指向函数的指针的数组（参见函数指针），每个函数都必须接受两个参数（一个int和一个double），并返回类型为int**。

#+begin_src c
  void
  bar (int size)
  {
    int foo[size];
    …
      }
#+end_src

在函数bar被调用时，声明foo为一个大小在运行时指定的整数数组。

** 合并变量声明

当多个声明具有相同的关键字和基本类型时，可以使用逗号将它们组合在一起。因此，

#+begin_src c
  keywords basetype
    decorated-variable-1 [= init1],
    decorated-variable-2 [= init2];
#+end_src

相当于

#+begin_src c
  keywords basetype
     decorated-variable-1 [= init1];
  keywords basetype
     decorated-variable-2 [= init2];
#+end_src

一些简单的例子：

#+begin_src c
  int a, b;
  int a = 1, b = 2;
  int a, *p, array[5];
  int a = 0, *p = &a, array[5] = {1, 2};
#+end_src

在最后两个例子中，a是一个int，p是一个指向int的指针，array是一个包含5个int的数组。
由于数组的初始化器只指定了两个元素，其他三个元素将被初始化为零。

* 初始化

除了使用extern关键字声明变量之外，还应指定其初始值。对于数值和指针类型的变量，初始化器是一个具有值的表达式。
如果需要，它将转换为变量的类型，就像在赋值语句中一样。

你也可以使用一个具有相同类型的表达式的值种方式初始化本地的结构体类型（参见结构体）或联合体类型（参见联合体）变量。
但是你不能以这种方式初始化数组（参见数组），因为在C中数组不是一级对象（参见C数组的限制），并且没有数组赋值操作。

你可以逐个成员地初始化数组和结构体，使用一个元素或组件的列表。你可以使用联合体的任意一个成员来初始化联合体。

 * 数组的逐个成员初始化器由以 '{...}' 包围的元素值组成。如果初始化器中的值没有覆盖数组中的所有元素，剩余的元素将被初始化为零。
   在声明数组时，你可以省略数组的大小，并让初始化器指定大小：

#+begin_src c
  int array[] = { 3, 9, 12 };
#+end_src

 * 对于结构体，逐个成员的初始化器由以 '{...}' 包围的字段值组成。按照结构体中字段的声明顺序编写字段值。
   如果初始化器中的值没有覆盖结构体中的所有字段，剩余的字段将被初始化为零

 * 联合体类型变量的初始化器形式为 { value }，其中 value 初始化联合体定义中的第一个成员。

对于数组的数组、包含数组的结构体、结构体数组等，这些结构都可以嵌套。例如，

#+begin_src c
  struct point { double x, y; };

  struct point series[]
    = { {0, 0}, {1.5, 2.8}, {99, 100.0004} };
#+end_src

如果内部的一对花括号中包含了正确数量的元素来初始化子值，你可以省略这对花括号，这样就不需要用零填充任何元素或字段。
但是不要经常这样做，因为它容易让人混淆。

可以使用字符串常量初始化char数组。请记住，字符串常量在末尾包含一个隐式的空字符（参见字符串常量）。
使用字符串常量作为初始化器意味着将其内容作为数组元素的初始值。例如：

#+begin_src c
  char text[6] = "text!";     /* Includes the null. */
  char text[5] = "text!";     /* Excludes the null. */
  char text[] = "text!";      /* Gets length 6. */
  char text[]
    = { 't', 'e', 'x', 't', '!', 0 };  /* same as above. */
  char text[] = { "text!" };  /* Braces are optional. */
#+end_src 

这种类型的初始化器可以嵌套在花括号内，以初始化包含char数组的结构体或数组。

同样地，你可以使用宽字符串常量来初始化wchar_t数组。

* 指定初始化器

在复杂的结构体或长数组中，指定初始化器可以很有用，可以指示我们正在初始化哪个字段或元素。

要在初始化过程中指定特定的数组元素，可以在方括号中包含数组索引，并为每个元素使用赋值运算符：

#+begin_src c
  int foo[10] = { [3] = 42, [7] = 58 };
#+end_src

以下声明与上面的效果相同：

#+begin_src c
  int foo[10] = { 0, 0, 0, 42, 0, 0, 0, 58, 0, 0 };
#+end_src

在数组初始化中，可以将非指定元素值与指定的索引一起包含；它们按照数组初始化的预期顺序进行排序，这样就能确保正确的对应关系。因此，

#+begin_src c
  int foo[10] = { [3] = 42, 43, 44, [7] = 58 };
#+end_src

与下面的声明效果相同：

#+begin_src c
  int foo[10] = { 0, 0, 0, 42, 43, 44, 0, 58, 0, 0 };
#+end_src

请注意，你只能使用常量表达式作为数组索引值，而不能使用变量。

如果你需要将顺序数组的子序列初始化为相同的值，你可以指定一个范围：

#+begin_src c
  int foo[100] = { [0 ... 19] = 42, [20 ... 99] = 43 };
#+end_src

使用范围初始化是GNU C自己的扩展。

当子序列范围重叠时，每个元素都由适用于它的最后一个指定值进行初始化。因此，这种初始化与之前的初始化是等价的。

#+begin_src c
  int foo[100] = { [0 ... 99] = 43, [0 ... 19] = 42 };
#+end_src

第二次赋值覆盖了第一次赋值中从0到第19个元素的值。

对于数组使用范围初始化时仅对赋值表达式的值进行一次计算，因此下面的代码：

#+begin_src c
  int random_values[100]
    = { [0 ... 99] = get_random_number() };
#+end_src

会将数组random_values的所有100个元素都初始化为相同的值，这很可能不是期望的结果。

同样地，你可以通过指定以点号开头的字段名来初始化结构体变量的特定字段：

#+begin_src c
  struct point { int x; int y; };

  struct point foo = { .y = 42; };
#+end_src

这样的语法也适用于联合体：

#+begin_src c
  union int_double { int i; double d; };

  union int_double foo = { .d = 34 };
#+end_src

这将整数值34转换为double类型，并将其存储在联合变量foo中。

你可以在同一初始化过程中指定数组元素和结构体元素；例如，这是一个点结构体数组的示例：

#+begin_src c
  struct point point_array[10] = { [4].y = 32, [6].y = 39 };
#+end_src

伴随着能过指定特定数组和结构体元素进行初始化的能力，会出现对同一个元素进行多次初始化的情形：

#+begin_src c
  int foo[10] = { [4] = 42, [4] = 98 };
#+end_src

在这种情况下最有一次初始化的值将被保留。

* 使用__auto_type引用类型

你可以使用 *__auto_type* 来声明变量，变量的类型为初始化表达式值的类型来决定。例如：

#+begin_src c
  #define max(a,b) \
    ({ __auto_type _a = (a); \
        __auto_type _b = (b); \
        _a > _b ? _a : _b })
#+end_src

这将定义 *_a* 与 *a* 具有相同的类型，并且 *_b* 与 *b* 具有相同的类型。这在宏中是非常有用的，
因为它可以处理任何类型的数据（参见宏和自动类型）。

原始的GNU C方法用于获取一个值的类型是使用 typeof，它以一个值或类型名称作为参数。前面的例子也可以这样写：

#+begin_src c
  #define max(a,b) \
    ({ typeof(a) _a = (a); \
        typeof(b) _b = (b); \
        _a > _b ? _a : _b })
#+end_src


*typeof* 比 *__auto_type* 更灵活；然而， *typeof* 主要用于带有初始化的变量声明，而这正是 *__auto_type* 所处理的情况。

* 局部变量

在函数定义内部声明一个变量会使变量名在包含的代码块中成为局部变量，也就是在一对大括号内部。更准确地说，
变量的名称在声明的位置之后立即可用，并且它的可用性持续到该代码块的末尾。

C语言中的局部变量通常是自动变量：每个变量的存储空间仅在声明到代码块结束期间存在。在声明语句被执行时，
会分配存储空间、计算初始值并将其存储在变量中。代码块的结束会释放存储空间。

*警告：* 在同一作用域中对同一个局部变量进行两次声明是错误的。

*警告：* 自动变量存储在运行时堆栈中。程序的堆栈总空间可能有限；因此，在使用非常大的数组时，可能需要以其他方式分配它们，
以防止程序崩溃。

*警告：* 如果自动变量的声明没有指定初始值，那么该变量的初始值将是随机的垃圾值。在这个例子中，打印出的值可以是任意的。

#+begin_src c
  {
    int i;

    printf ("Print junk %d\n", i);
  }
#+end_src

在一个简单的测试程序中，这个语句可能打印出0，仅仅是因为每个进程都以零内存开始。但是不要依赖它是零，这是错误的。

*注意:* 请确保在引用每一个局部变量之前存储一个值到它们之中(通过赋值或初始化)。

* 文件范围变量

在文件的顶层（而不是在函数定义内部），变量声明将产生一个文件范围变量。加载程序时会为其中的所有文件范围变量分配存储空间，并进行初始化。

每个文件范围变量要么是静态的（限定于一个编译模块），要么是全局的（与程序中的所有编译模块共享）。要使变量成为静态变量，
在声明的开始处写上关键字 static。如果省略 static，则变量为全局变量。

文件范围变量的初始值不能依赖于存储器中的值，并且不能通过调用任何函数得到。例如：

#+begin_src c
  int
  increment_counter ()
  {
    static int counter = 0;
    return ++counter;
  }
#+end_src

名为 *counter* 的变量的作用域从声明开始处一直持续到包含它的代码块结束，就像一个自动局部变量一样，但是它的存储空间在程序运行
期间是一直存在的并且它的值在每次调用期间保持不变。因此每次调用 *increment_counter* 都会返回一个不同且唯一的值。

静态局部变量的初始值具有与文件范围变量相同的限制：它不能依赖于存储的内容或调用任何函数。它可以使用文件范围变量或静态局部变量的地址，
因为这些地址在程序运行之前就确定了。

* extern 声明

extern声明用于引用位于同一个编译模块或另一个编译模块中的全局变量。其形式类似：

#+begin_src c
  extern basetype decorated-variable;
#+end_src

它的含义是，在当前作用域中，变量名引用了同名的文件范围变量，这个变量需要在其他地方以非extern、非static的方式进行声明。

例如，如果一个编译模块声明了一个这样的全局变量：

#+begin_src c
  int error_count = 0;
#+end_src

之后另外一个编译模块中可以通过这样指定：

#+begin_src
  extern int error_count;
#+end_src

来允许引用这个变量。

通常，在源文件的开始处使用extern声明是常见的做法，但是您也可以在块内使用extern声明，以使全局或静态的文件范围变量在该块中可访问。

由于extern声明不为变量分配空间，因此可以省略数组的大小：

#+begin_src c
  extern int array[];
#+end_src

您可以在所有自动转换为指针的上下文中正常使用数组。然而，将其用作sizeof运算符的操作数是错误的，因为大小是未知的。

如果多个extern声明给出相同类型的同一个变量，甚至在同一个作用域内，这是有效的。它们不会冲突，而是相互一致。
对于数组，某些extern声明可以指定大小，而其他声明则可以省略。然而，如果两个声明给出不同的大小，那将是一个错误。

同样的，你可以在文件范围(详见文件范围变量)使用 *extern* 声明并在其后接着声明一个名字相同的普通全局变量(非静态)。
它们不会冲突，因为它们对同一个变量的意义给出了兼容的声明。

* 文件范围变量的存储空间分配

一些文件范围声明为变量分配空间，而其他一些则不会。

具有初始值的文件范围声明必须为变量分配空间；如果存在两个这样的声明拥有相同的变量名，即使它们位于不同的编译模块中，它们也会冲突。

extern声明从不为变量分配空间。如果某个变量的所有顶层声明都是extern，那么该变量永远不会获得内存空间。
如果在程序中使用了该变量，将会报告错误，指明该变量未定义。

没有初始值的文件范围声明被称为暂定定义（tentative definition）。这是一种奇特的混合形式：它可以为变量分配空间，但不坚持要求。
因此，如果变量有另一个为其分配空间的声明（可能在另一个编译模块中），它不会导致冲突或错误。但是，如果没有其他地方为变量分配空间，
暂定定义将完成这个任务。任意数量的编译模块都可以以这种方式声明相同的变量，这足以让它们都使用该变量。

在非常大或有许多贡献者的程序中，最好采用不使用暂定定义的约定。您可以使用编译选项-fno-common将其视为错误，
或者使用--warn-common选项来发出警告。

如果文件范围的变量通过暂定定义来获得空间，它的初始值将全为零。

* auto 和 register


由于历史原因，您可以在局部变量声明之前使用 *auto* 或 *register* 关键字。 *auto* 只是强调变量不是静态的，不会对变量产生任何影响。

*register* 关键字建议编译器将该变量存储在寄存器中。然而，GNU C忽略这个建议，
因为它可以在没有任何提示的情况下选择最适合存储于寄存器中的变量。

在使用register声明的变量上使用取地址运算符‘&’是错误的，因此您不能对其使用一元‘&’运算符。如果变量是一个数组，
您根本无法使用它（除了作为sizeof的操作数），这使它变得相当无用。

* 在声明中省略类型

传统的C语言语法允许在声明中省略数据类型，如果声明中包含存储类、类型限定符（见下一章节）或者关键字auto或register。
此时，默认类型为int。例如：

#+begin_src c
  auto foo = 42;
#+end_src

这是一个坏习惯，如果你看到了请修正它。


