#+title: 12 常数
#+options: ^:nil

常数是显式呈现恒定值的表达式。C语言允许的常量类型有数值，字符和字符串。前面已经使用过数值和字符串常量。

** 整型常数

整型常数是一个指定的数值并且通过字符后缀指定常量为哪种类型的整数。

最简单的整型常数是十进制数字，例如 5，77，403。十进制整型常数不能以字符'0'开始因为这让它变成八进制数。

你可以给整型常数前面加上负号让它变成一个负数。从语法上讲这将使其成为一个算术表达式而不是常量，但是它
的行为和真正的常数一样。

常数也能以八进制，十六进和二进制形式表示。八进制常量以字符'0'作为前缀，之后是任意数量的八进制数('0'--'7'):

#+begin_src c
  0      // zero
  077    // 63
  0403   // 259
#+end_src

如果非要咬文嚼字，常数 *0* 是一个八进制常数，但是也可以认为它是一个十进制常数，尽管不论那种进制它的值都是相同的。

十六进制常量以字符'0x'(x 大小写均可)作为前缀，之后是任意十六进制数('0'--'9','a'--'f'大小写均可)：

#+begin_src c
  0xff   // 255
  0XA0   // 160
  0xffFF // 65535
#+end_src

二进制常数以字符'0b'(大小写均可)，之后是任意二进制数('0'--'1')：

#+begin_src c
  0b101   // 5
#+end_src

二进制常数仅仅被GNU C支持，它并不被标准C支持。

有些时候整型常数后面需要一个空格以防止与后续标记产生歧义。详情请见非法数值。

** 整型常数类型

一般情况下如果整型常数的大小适合与 *int* 型那么这就是它的类型，但是对于如何决定类型仍然存在完整的规则。
一个整型常数的类型是一下列表中第一个可以正确存储该值的类型：

 1. int
 1. unsigned int
 1. long int
 1. unsigned long int
 1. long long int
 1. unsigned long long int

对以上列表还有下面的例外规则：

 * 如果常数后缀为'l'或'L'，忽略列表前两项
 * 如果常数后缀为'll'或'LL'，忽略列表前四项
 * 如果常数后缀为'u'或'U'，忽略所有有符号项
 * 如果常数是十进制的，忽略无符号项

例如：

#+begin_src c
  3000000000u      // three billion as unsigned int.
  0LL              // zero as a long long int.
  0403l            // 259 as a long int.
#+end_src 

整型常数中的后缀很少使用。当类型的精确性很重要时使用显示类型转换是明智的选择。详情请见显示类型准换与整数类型章节。


** 浮点常数

浮点数常量必须有一个小数点或一个十的指数又或两者兼备；它们是辨别整型常数还是浮点常数的标志。

'e'或'E'加上随后的数字表示指数。指数总是使用十进制数字，它前面还可以加正负号。指数 /n/ 的意义是将常数乘以10的
n次方。

因此，'1500.0'，'15e2'，'15e+2'，'1.5e+3'，'.15e4'，与 '15000e-1' 的值都等于1500。

使用小数点的例子：

#+begin_src c
  1.0
  1000.
  3.14159
  .05
  .0005
#+end_src

对于以上数值这里是一些等价表示法：

#+begin_src c
  1e0, 1.0000e0
  100e1, 100e+1, 100E+1, 1e3, 10000e-1
  3.14159e0
  5e-2, .0005e+2, 5E-2, .0005E2
    .05e-2
#+end_src

通常情况下浮点常数的类型是 *double* 。但是你可以通过后缀'f'或'F'指定它们为 *float* ：

#+begin_src c
  3.14159f
  3.14159e0f
  1000.f
  100E1F
  .0005f
  .05e-2f
#+end_src

同样的，后缀'l'或'L'强制指定类型为 *long double* 。

你也可以在十六进制浮点数中使用指数，但是因为'e'属于十六进制数的基数所以需要使用'p'或'P'(意为'power')来代替它。

十六进制常数中的指数可以是有符号的十进制整数，指数在这里的底数是2而不是10或16。

例如：

#+begin_src c
0xAp2        // 40 in decimal
0xAp-1       // 5 in decimal
0x2.0Bp4     // 16.75 decimal
0xE.2p3      // 121 decimal
0x123.ABCp0  // 291.6708984375 in decimal
0x123.ABCp4  // 4666.734375 in decimal
0x100p-8     // 1
0x10p-4      // 1
0x1p+4       // 16
0x1p+8       // 256
#+end_src

详情请见浮点数数据类型章节

** 虚数常数

复数由实部和虚部组成。(其中一个或两个部分都可以为零)。本节说明如何用虚数值书写复数常数。
通过将这些添加到普通的实数值常数，我们可以创建具有复数值的常量。

书写虚数常量的简单方法是给整数或浮点常量添加后缀'i'或'I'，或'j'或'J'。 例如，2.5fi 的类型为 _Complex float，
而 3i 的类型为 _Complex int。 四个后缀字母都是等价的。

另一种数写虚常数的方法是将实常数乘以 _Complex_I，它表示虚数 i。 标准 C 不支持后缀为'i'或'j'，因此需要这种笨拙的方式。

要书写具有非零实部和非零虚部的复数常数，请分别书写并添加它们，如下所示：

#+begin_src c
  4.0 + 3.0i
#+end_src

这将赋予 4+3i *_Complex double* 。

如同求和时可以使用0个或多个实数常数，同样的也可以使用0个或多个虚数常数：

#+begin_src c
  _Complex double foo, bar, quux;
  foo = 2.0i + 4.0 + 3.0i; /* Imaginary part is 5.0. */
  bar = 4.0 + 12.0; /* Imaginary part is 0.0. */
  quux = 3.0i + 15.0i; /* Real part is 0.0. */
#+end_src

详情请见复数数据类型。

** 非法数值

在预处理指令中，一些不是真正有效的数字常数的类似数字的结构被视为数字。 如果这些结构出现在预处理之外，
它们就是错误的。 请参阅预处理标记。

有时我们需要插入空格来分隔标记，这样它们就不会组合成一个类似数字的结构。 例如，0xE+12 是一个预处理数字，
它不是一个有效的数字常量，因此它是一个语法错误。 如果我们想要的是 0xE + 12 这三个标记，我们必须使用这些空格作为分隔符。

** 字符常数

单引号之内的字符被成为字符常数，例如'c'。在这个简单的例子中 /c/ 是最终被显示的单一ASCII字符。字符常数的类型是 *int* ,
它的值是对应的ASCII码。例如，呈现字符'a'的字符常数的值是97。

要将'''(单引号)作为字符常量需要使用反斜杠('\')来引用它，写出来就是：'\''。这个以反斜杠开始的序列被称为转义序列，
反斜杠在这里作为转移字符是使用。

要将'\'(反斜杠)作为字符常量需要使用他自己引用它。写出来就是：'\\'。

以下是字符常数中的所有转义序列。 显示的数值是相应的 ASCII 字符代码，为十进制数。

#+begin_src c
  '\a' ⇒ 7       /* alarm, CTRL-g */
  '\b' ⇒ 8       /* backspace, BS, CTRL-h */
  '\t' ⇒ 9       /* tab, TAB, CTRL-i */
  '\n' ⇒ 10      /* newline, CTRL-j */
  '\v' ⇒ 11      /* vertical tab, CTRL-k */
  '\f' ⇒ 12      /* formfeed, CTRL-l */
  '\r' ⇒ 13      /* carriage return, RET, CTRL-m */
  '\e' ⇒ 27      /* escape character, ESC, CTRL-[ */
  '\\' ⇒ 92      /* backslash character, \ */
  '\'' ⇒ 39      /* singlequote character, ' */
  '\"' ⇒ 34      /* doublequote character, " */
  '\?' ⇒ 63      /* question mark, ? */
#+end_src

'\e' 是GNU C的扩展，要兼容标准C请使用 '\33'。

也可以使用八进制和十六进制的字符代码例如：'\otcalcode'或'\xhexcode'。十进制并不是唯一选择，八进制并不需要以'0'前缀开始。

字符常数是 *int* 类型。然而字符的值却被初始化成 *char* 类型，然后转换成 *int* 。如果字符值大于127(八进制数0177)，那么
对于 *char* 类型为8比特有符号数的平台转换的结果在 *int* 中有可能是负数。

** 字符串常数

字符串常数由一系列写在双引号之间的字符组成。在字符串常数中书写'"'，'\'和'\n'等特殊字符和在字符常数中的方法一样。在字符串
常量里单引号不需要转义字符('\')。

字符串常数定义了一个以字符0结尾包含特定字符的数组。使用字符串常数如同使用包含相同内容的数组。一般情况下，
字符串常量的字节长度比其中写入的字符数大1。

和C语言里的数组一样，在表达式中使用字符串常量其会被转换成一个指向数组中第一个元素的指针(详情请见指针章节)。
因为这个指针是指向以 *char* 类型为元素的数组所以这个指针将是 *char ** 类型的。 *char* 是一个指针类型的类型指定的例子。
(详情请见指针类型指定)。 字符串变量也通常*char** 类型，而不仅仅只有字符串常量使用它它。

因此，字符串常数 *"Foo!"* 近乎等价于声明一个如下数组：

#+begin_src c
  char string_array_1[] = {'F', 'o', 'o', '!', '\0' };
#+end_src

然后在程序中使用名为 *string_array_1* 的数组。字符串常数与数组有两点不同：

 * 字符串常数并不定义数组名。
 * 字符串常数多半存储在只读内存区域。

字符串常数的文本中不允许使用换行符。这条禁令的目的是捕获丢失结束双引号'"'的错误。要在字符串常数中使用换行请使用'\n'转义字符。

源代码中字符串常量内的真正空字符会导致警告。 要在字符串常量中间放置一个空字符，请使用‘\0’或‘\000’。

连续的字符串常量将被视为有效字符串而连接起来，因此：
#+begin_src c
  "Fo" "o!"   等价于   "Foo!" 
#+end_src

这是书写包含多行的字符串非常有用的方法，例如：

#+begin_src c
  "This message is so long that it needs more than\n"
  "a single line of text.  C does not allow a newline\n"
  "to represent itself in a string constant, so we have to\n"
  "write \\n to put it in the string.  For readability of\n"
  "the source code, it is advisable to put line breaks in\n"
  "the source where they occur in the contents of the\n"
  "constant.\n"
#+end_src

反斜杠和换行符的序列在 C 程序中的任何地方都被忽略，也包括在字符串常数中。 因此，你可以这样书写多行字符串常数：

#+begin_src c
  "This is another way to put newlines in a string constant\n\
  and break the line after them in the source code."
#+end_src

然而，推荐使用的方式是串联的方式。


你也可以用这样反常的方式书写字符串：

#+begin_src c
  "Fo\
  o!"
#+end_src

不过做个人吧，请使用正常方式书写：

#+begin_src c
  "Foo!"
#+end_src

需要非常小心的避免将一个字符串常数当参数传递给一个可能修改该字符串的函数。存储字符串常数的内存区域多半是只读的，修改这部分内存中的
内容会触发终止函数执行的 *SIGSEGV* 信号。(详见信号章节)。更糟糕的是如果那部分内存不是只读的时候那么函数修改该字符串常数之后将会导致
由编译器统一生成的其它字符串常量的内容被破坏。

** UTF-8 字符串常数

在字符串常数前面使用'u8'前缀并且与常量之间没有任何存在那么字符串常量将被以 *UTF-8* 字节编码序列的方式呈现。 *UTF-8* 编码使用单字节
表示 *ASCII* 字符，使用多字节表示非 *ASCII* (编码值在128以上的字符) 字符。例如：

#+begin_src c
  u8"A cónstàñt"
#+end_src

以上常量将占用13字节加上1字节结束符，因为每一个带重音符号的字符占用2字节。

从理论上讲，将常规字符串与 *UTF-8* 字符串连接会生成一个 *UTF-8* 字符串。然而，如果常规字符串中含有编码值大于128的字符那么结果很难预测。

** Unicode字符编码

你可以使用转义符指定单独的字符或字符串中的部分字符为Unicode编码(详情请见字符串常量)。使用'\u'转义符加一个16比特十六进制Unicode字符代码。
如果字符编码的数值过大那么使用'\U'转义符加上一个32位十六进制Unicode字符代码(这些代码被称为 /通用字符名/ )。例如：

#+begin_src c
  \u6C34      /* 16-bit code (UTF-16) */
  \U0010ABCD  /* 32-bit code (UTF-32) */
#+end_src

有一种方法可以在 *UTF-8* 字符串常数中使用Unicode编码字符(详情请见UTF-8 字符串常数)。例如：

#+begin_src c
  u8"fóó \u6C34 \U0010ABCD"
#+end_src

你可以在宽字符常数中使用它们(详情请见宽字符常数)，例如：

#+begin_src c
  u'\u6C34'      /* 16-bit code */
  U'\U0010ABCD'  /* 32-bit code */
#+end_src

你可以在宽字符串常数中使用它们(详情请见宽字符串常数)，例如：

#+begin_src c
  u"\u6C34\u6C33"  /* 16-bit code */
  U"\U0010ABCD"    /* 32-bit code */
#+end_src

D800 到 DFFF 范围内的代码在 Unicode 中无效。 除了0024、0040、0060之外，小于00A0的代码也是禁止使用的；
这些字符实际上是 ASCII 控制字符，您可以通过转义序符使用它们。(详情请见字符串常量章节)

** 宽字符常数

宽字符常数表示字符代码超过8位的字符。这是一个我们需要记录但你可能永远不会使用的晦涩功能。如果你只是学习C语言，你不妨跳过这一部分。

原始的C语言宽字符常数看起来像"L"（大写！），紧接着是一个普通字符常量（中间没有空格）。它的数据类型是wchar_t，这是在stddef.h
中为一种标准整数类型定义的别名。根据平台的不同，它可能是16位或32位。如果是16位，这些字符常量使用Unicode的UTF-16形式； 如果是32位，则为UTF-32。

还有明确指定宽度的Unicode宽字符常数。这些常数以"u"或"U"而不是"L"开头。 'u'指定16位Unicode宽字符常量，
'U'指定32位Unicode宽字符常量。它们的类型分别是char16_t和char32_t；它们在头文件uchar.h中声明。即使不包含uchar.h，这些字符常量也是有效的，
但如果不包含它来声明那些类型名称，那么某些时候使用可能会很不方便。

宽字符常数表示的字符可以是普通的 ASCII 字符。 L'a'、u'a' 和 U'a' 都是有效的，它们都等于 'a'。

在所有三种宽字符常量中，您可以在常量本身中写入非 ASCII Unicode 字符； 常量的值是字符的 Unicode 字符代码。 或者您可以使用转义序列指定 Unicode 字符（详情请见Unicode字符代码）。

** 宽字符串常数

宽字符串常数代表16位或32位字符的数组。它们很少被使用；如果你只是学习C语言，你不妨跳过这一部分。

宽字符串常数分为三种，其区别在于字符串中每个字符所使用的数据类型。 每个宽字符串常量都相当于一个整数数组，但这些整数的数据类型取决于宽字符串的种类。
在表达式中使用常量会将数组转换为指向其第一个元素的指针，就像 C 中的数组一样（详情请见访问数组元素）。 对于每一种宽字符串常量，我们在这里声明指针的类型。

 * char16_t

   这是一个16位Unicode宽字符串常数：每个元素都是一个16位Unicode 字符代码，类型为char16_t，因此该字符串的指针类型为char16_t *。
   (这是一个类型指示符；请参阅指针类型指示符。)常数写为"u"(必须小写)后跟(中间没有空格)具有常用语法的字符串常数。

 * char32_t

   这是一个32位Unicode宽字符串常量。每个元素都是一个32位Unicode字符代码，字符串的类型为char32_t *。
   它被写为"U"(必须是大写字母)后跟一个字符串常量（中间没有空格），具有通常的语法。

 * wchar_t

   这是原始的宽字符串常数。 它被写为“L”（必须是大写字母）后跟一个字符串常数（中间没有空格），具有通常的语法，字符串的类型为 wchar_t *。

   数据类型 wchar_t 的宽度取决于目标平台，这使得这种宽字符串在某种程度上不如较新的类型有用。


char16_t 和 char32_t 在头文件 uchar.h 中声明。 wchar_t 在 stddef.h 中声明。


连接同类的连续宽字符串常数，就像普通字符串常数一样。 宽字符串常数与普通字符串常数连接会产生宽字符串常量。 您不能连接两个不同种类的宽字符串常数。
你也不能将宽字符串常数（任何类型的）与 UTF-8 字符串常量连接起来。









