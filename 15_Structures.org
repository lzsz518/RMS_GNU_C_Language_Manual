#+Title: 15 结构体

/结构体/ 是一种用户自定义的数据类型，它可以拥有不同的 /字段/ 。结构体中的字段都拥有名字和类型。

下面我们为给链表排序定义一个合适的结构体。链表的项包含一个整数和一个指向下一项的指针。

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };
#+end_src

这个结构体拥有一个类型标签所以其他代码可以使用它来定义这个结构类型的变量。这里的类型标签是 *intlistlink* 。
上面的结构体使用类型标签进行了递归定义。

你可以定义一个结构体而不使用类型标签，但是定义之后便无法再使用它。这只有在一些特殊场合有用，例如在
*typedef* 和 *联合体* 中。

结构体中的内容是大括号中的字段。每个字段都需要声明。在定义结构体时每一个字段都需要有一个明确的名字，但是
这个名字不会与程序中的其它名字产生冲突。

字段声明看起来就像是变量声明。你可以使用与变量声明相同的命名规则声明字段。

以上结构体有用两个字段。一个叫 *datum* 类型是 *int* 并可以为链表保存一个整数，另一个叫 *next* 类型是指向
另一个 *struct intlistlink* 的指针，从这个指针可以找到剩余的链表项。链表的最后一项中的 *next* 的值应该是 *NULL* 。

这个结构体是一个递归定义，因为 *next* 的类型是 *intlistlink* 类型。这样的递归定义是没有问题的；事实上你可以在
struck intlistlink 定之前使用类型 struct intlistlink *。这是因为在机器码的层级指向所有结构体的指针都是基本相同的。

结构体被定义之后，你可以声明一个 *struct intlistlink* 类型的变量：

#+begin_src c
  struct intlistlink foo;
#+end_src

结构定义本身可以作为变量声明的开始，所以你可以紧接着它声明变量，像这样:

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    } foo;
#+end_src

但是这看起来比较难看。将结构体的定义与使用它分开可以让代码看起来更清晰。

在代码块中声明结构体将会限制这个结构体的作用域仅仅存在于那个代码块中。这意味着这个结构体仅存在于那个代码块中。
在一个函数的参数列表中定义结构体：

#+begin_src c
  int f (struct foo {int a, b} parm);
#+end_src

(假设 *struct foo* 之前没被定义过) *struct foo* 的作用域仅限参数列表中；这没有任何用处所以会产生一个警告。

标准C语言需要结构体最少有一个字段，但是GNU C 没有这个限制。

* 结构体字段引用

结构体最常见的用处是对其字段进行存取，'.'(点)操作符用以完成该操作；写法类似 *对象.字段* 。

定义以下结构体和变量，

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };

  struct intlistlink foo;
#+end_src

你可以通过 *foo.datum* 和 *foo.next* 来引用结构体foo中的两个字段的值。这些字段都是左值所以你可以使用它们存取数值。

结构体经常会被动态分配(下一章节)，我们在引用它时需要通过指针。通过(*p).field 的形式访问有些繁琐，可以通过使用缩略
语的方式来简化访问: p->field. 例如假设程序中包含以下声明:

#+begin_src c
  struct intlistlink *ptr;
#+end_src

你可以使用 ptr->datum 和 ptr->next 来引用结构体指针中的两个字段。

如果一个一元运算符出现在使用'->'的表达式之前那么一元运算符会对'->'所引用的字段产生作用：

#+begin_src c
  -ptr->datum  等于   -(ptr->datum)
#+end_src

你可以在不使用小括号的情况下混合使用'->'和'.':

#+begin_src c
  struct { double d; struct intlistlink l; } foo;

  …foo.l.next->next->datum…
#+end_src

* 动态内存分配

若要给一个对象动态分配内存可以使用库函数 *malloc* (详见： [[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Basic-Allocation][The GNU C Library ]]GNU C 库函数手册)。这里演示如何动态分配一个
*struct intlistlink* 对象。若要使这段代码可以正常工作需要包含 *stdlib.h* :

#+begin_src c
  #include <stddef.h>  /* Defines NULL. */
  #include <stdlib.h>  /* Declares malloc.  */

  …

  struct intlistlink *
  alloc_intlistlink ()
  {
    struct intlistlink *p;

    p = malloc (sizeof (struct intlistlink));

    if (p == NULL)
      fatal ("Ran out of storage");

    /* Initialize the contents. */
    p->datum = 0;
    p->next = NULL;

    return p;
  }
#+end_src

*malloc* 的返回值是 *void* 类型，但是其赋值给 *p* 的时候会自动转换到 *struct intlistlink* *** 。 *malloc* 的返回值
总是充分对齐的(详见对其章节)，这使其可以转换到任意类型。

检测p是否为空是必要的因为当没有足够的可用内存时 *malloc* 会返回一个空指针。我们假设程序定义了 *fatal* 函数来向用户报告
致命错误。

这里展示如何在链表前面增加一个整数：

#+begin_src c
  struct intlistlink *my_list = NULL;

  void
  add_to_mylist (int my_int)
  {
    struct intlistlink *p = alloc_intlistlink ();

    p->datum = my_int;
    p->next = mylist;
    mylist = p;
  }
#+end_src

释放动态分配的对象的方法是调用 *free* 函数。这里是使用 *free* 函数释放链表中所有对象的例子：

#+begin_src c
  void
  free_intlist (struct intlistlink *p)
  {
    while (p)
      {
        struct intlistlink *q = p;
        p = p->next;
        free (q);
      }
  }
#+end_src

我们必须在一个对象被释放之前从其中提取 *next* 指针，因为 *free* 会删除对象中的数据。相同的原因，程序不应该使用被释放过
的对象中的元素。要确保这些不会发生最好清楚存储链表的变量，例如：

#+begin_src c
  free_intlist (mylist);

  mylist = NULL;
#+end_src

* 字段偏移

要确定一个结构体中一个字段的偏移量可以使用在 *stddef.h* 中的宏定义 *offsetof* 。看起来就像：

#+begin_src c
  offsetof (type, field)
#+end_src

例如：

#+begin_src c
  struct foo
  {
    int element;
    struct foo *next;
  };

  offsetof (struct foo, next)
  /* 在大多数机器上是 4.  有些机器上可能是 8.  */
#+end_src

* 结构体内存布局

本章及其后续章节是关于结构体的高级特性，如果你只是想学习C语言那么可以跳过这些章节。

合理的结构体内存布局对于硬件寄存器读写性能，共享内存中的数据存取和网络通信数据包的组合与拆分至关重要。对于避免由于使用结构体
导致的内存浪费同样重要。然而，内存布局依赖于具体的目标平台。每一种平台对于结构体内存布局都有具体的约定，编译器必须遵循这些约定。

以下是大多数平台对于结构体内存布局的约定：

结构体的字段按照其声明的顺序出现在结构体的内存布局中。在可能的情况下连续的字段在结构体中占据连续的字节。然而，如果一个字段需要
更多的字节来满足系统需要对齐的字节数那么C语言会在下一个字段出现之前补齐上一个字段对于对齐要求所缺少的字节。

当所有字段需要占据的字节都安排好之后结构体的对齐方式和大小就可以确定下来了。结构体的对齐方式指的是所有字段中需要最大的对齐字节。
结构体的大小是对齐方式整数倍。这可能需要在结构体的最后一个字段之后补充一些字节。

例如，我们假设 *char* 的大小是1对齐方式是1(永远是这样)， *int* 的大小和对齐方式都是4 (在大多数计算机上是这样)：

#+begin_src c
  struct foo
  {
    char a, b;
    int c;
  };
#+end_src

这个结构体在内存中将以4字节对齐的方式占用8个字节。 *a* 的偏移是0， *b* 的偏移是1， *c* 的偏移是4。在 字段 *b* 与 *c* 之间有
2字节的间隔以满足4字节的对齐方式。

对比下面的结构体：

#+begin_src c
  struct foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

这个结构体在内存中以4字节对齐的方式占用12个字节。 *a* 的偏移是0， *c* 的偏移是4， *b* 的偏移是8. 在字段 *a* 与 *c* 之间
有三个字节的间隔，在字段 *b* 之后又补充了三个字节。

以上两个结构体在C语言中拥有相同的字段，但是由于字段顺序的不同一个占用8字节内存另一个占用12字节内存。一个避免内存浪费的可靠的
途径是按照字节占用从大到小的顺序定义字段。

* 折叠结构体

在GNU C中你可以通过在 *struct* 关键字之后或结构体类型声明之后使用 *__attribute__((packed))* 强制结构体内存布局不进行内存对齐。
例如：

#+begin_src c
  struct __attribute__((packed)) foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

假设 *int* 的对齐方式是4字节，在不使用 *__attribute__((packed))* 时这个结构体将占用12字节内存(如上一章所述)。使用
*__attribute__((packed))* 后它只占用6字节内存，这相当于每一个字段实际占用内存字节数的和。

使用 *__attribute__((packed))* 会经常导致字段不会按照其应有的方式进行对齐。在获取未进行内存对齐的字段的地址时可能会得到一个
非法的指针。在不允许出现未内存地址未对齐的指针的机器上进行指针解引用会产生 *SIGSEGV* 信号。

* 比特字段

当定义一个整数类型的结构体字段时可以指定该字段占用的比特位数，我们称之为 /比特字段/ 。 这样做的好处是可以让连续的比特字段被一起
存储到更大的存储单元中。例如：

#+begin_src c
  unsigned char opcode: 4;
#+end_src

上面的语句指定地段只占用4个比特位。由于是无符号类型所以他的值域为0--15. 一个占用4比特的有符号字段如下：

#+begin_src c
  signed char small: 4;
#+end_src

其值域为 -8--7。

你可以使用以下方法将结构体中的一个有符号字节拆分成两部分:

#+begin_src c
  unsigned char opcode: 4;
  signed char small: 4;
#+end_src

使用比特字段以上两个数字被放到一个有符号 *char* 中。

接下来演示如何点定义一个只能存储0或者1的1比特字段：

#+begin_src c
  unsigned char special_flag: 1;
#+end_src

你也可以使用 *bool* 类型的比特字段：

#+begin_src c
  bool special_flag: 1;
#+end_src

除了使用 *bool* 类型以外(*bool* 类型总是无符号的，详见布尔类型章节)，请总是为比特字段指明是有符号还是无符号的。当没有指定符号类型
时会使用一个默认规则：如果比特字段时普通 *char* 类型那么它是有符号的，除非使用 *-funsigned-bitfields* 编译参数强制它默认为
无符号的。但是不依赖这种默认规则是比较明智的。

比特字段的特别之处是你不可以对其使用取地址符 '&'。它们并没有按照适当的大小和对齐方式来存储到对应的类型中，所以它们不能通过指向其
类型的指针被找到。

* 打包比特字段

当使用底层级硬件接口进行编程时需要使比特字段的布局符合硬件数据的布局，本章将阐述如何做到。

连续的比特字段会被打包到一起，但是每一个比特字段必须只能根据它的类型被填充到一个单一内存对象中。例如：

#+begin_src c
  unsigned short a : 3, b : 3, c : 3, d : 3, e : 3;
#+end_src

以上5个比特字段会被使用一个两字节 *short* 来存储。它们一共需要15比特， *short* 可以提供16比特。相比之下：

#+begin_src c
  unsigned char a : 3, b : 3, c : 3, d : 3, e : 3;
#+end_src

以上5个比特字段需要三个字节来存储。 *a* 和 *b* 可以存储在一个 *char* 中，但是剩余两个比特不足以存储 *c* (存储它们三个需要9个比特)。
所以 *c* 和 *d* 需要第二个 *char* ，在 *b* 和 *c* 之间会留有两个比特的间隔。最后 *e* 存储在第三个 *char* 中。 再对比以下定义：

#+begin_src c
  unsigned char a : 3, b : 3;
  unsigned int c : 3;
  unsigned char d : 3, e : 3;
#+end_src

只需要两个字节： *unsigned int* 允许 *c* 在一个字(2个字节)中跨越两个字节。

你可以通过定义匿名比特字段来在其他字段之间设置间隔。匿名比特字段看起来就像： *： nbits;* 。匿名字段就像其它字段以后会在结构体中被分配
空间。

你可以使用类型 *:0* 强制下一个比特字段存储到经过对齐的下一个内存对象中。

匿名比特字段与 *:0* 在语法上皆可用于普通的比特字段共存。下例展示如何做到：

#+begin_src c
  unsigned int a : 5, : 3, b : 5, : 0, c : 5, : 3, d : 5;
#+end_src

*a* 和 *b* 被存储到一个 *int* 中，它们之间有3比特的间隔，接下来 *:0* 强制 *c* 和 *d* 存储到下一个 *int* 中。

本章讲述的打包比特字段规则适用于大多数目标平台，包含所有常见的真实计算机。有些嵌入式控制器有用特殊的布局规则。

* 常量字段

结构体中定义的常量字段是不可以被赋值的(详见常量章节)。例如让我们来定义一个 *struct intlistlink* 的修改版：

#+begin_src c
  struct intlistlink_ro  /* “ro” for read-only.  */
    {
      const int datum;
      struct intlistlink *next;
    };
#+end_src

这个结构体可以被用来防止其它代码修改该它的 *datum* 字段：

#+begin_src c
  /* p 的类型是 struct intlistlink *.
     转换它到 struct intlistlink_ro *.  */
  struct intlistlink_ro *q
    = (struct intlistlink_ro *) p;

  q->datum = 5;     /* 非法! */
  p->datum = 5;     /* 合法 因为 *p 不是一个struct intlistlink_ro.  */
#+end_src

常量字段可以通过两种方式获取值：通过结构体的整体初始化和通过有用常量字段的结构体的指针来指向一个该字段已经拥有值的结构体对象。

任何常量字段都会使结构体赋值变得不可能(详见结构体赋值)，这是因为结构体赋值会对所有字段进行一对一的赋值。
