#+title: 预处理

当GCC编译器对原文件进行编译时首先会进行文本替换与文件包含，这部分操作被称为预处理。

* 概述

GNU C在编译的第一阶段对C程序的每一行进行预处理。只有当一行包含预处理指令或使用宏时，
预处理器才对其进行处理，其他所有行都会在预处理之后保持不变。

以下是预处理所执行的一些任务。本章的其余部分将详细介绍这些内容。

 * 头文件的包含：头文件通常包含声明和宏定义，可以被替换到程序中。

 * 宏展开：您可以定义宏，宏是对任意C代码片段的缩写。预处理将宏替换为其定义。有些宏是自动预定义的。

 * 条件编译：您可以根据不同条件包含或排除程序的部分代码。

 * 行控制：如果您使用程序将源文件组合或重新排列成中间文件，然后再进行编译，您可以使用行控制来通知编译器每行源代码最初来自哪个文件。

 * 编译控制：#pragma和_Pragma可以调用一些特殊的编译器功能来处理特定的结构。

 * 诊断：您可以在编译时检测问题并输出错误或警告信息。

除了预定义宏的展开之外，所有这些操作仅在您使用预处理指令来请求它们时才会发生。

* 指令

预处理指令是程序中以‘#’开头的行。在‘#’之前和之后允许有空白字符。‘#’后面紧跟一个标识符，表示指令名称，
它指定要执行的操作。以下是一些示例：

#+begin_src c
#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
#+end_src

通常我们将指令写为#name，其中name是指令名称。例如，#define 表示定义宏的指令。

以‘#’开头的指令不能来自宏展开。另外，指令名称不会进行宏展开。因此，如果将foo定义为一个展开为define的宏，
那么#foo就不是一个有效的预处理指令。

C语言拥有固定数量的合法预处理指令，程序员不能自己定义新的预处理指令。

一些指令需要参数；这些参数位于指令行的其余部分，并且必须与指令名称用空白分隔开。
例如，#define 后面必须跟着宏的名称和宏的预期展开内容。

预处理指令不能跨越多行。但是，可以使用反斜杠换行符（backslash-newline）或者使用/*...*/风格的注释来延续行。
在指令被处理之前，这些反斜杠换行符或注释将被替换掉（替换为空白或删除），以便保持指令的连续性。

* 标记

预处理将C代码（去除其注释）划分为预处理标记，这些标记类似于C标记，但并不完全相同。以下是预处理标记的特点。

预处理标记的主要类别包括标识符、预处理数值、字符串常量、字符常量和标点符号；还有一些其他类型的预处理标记。

*标识符*

	标识符预处理标记在语法上类似于C中的标识符：它可以是由字母、数字或下划线组成的任意序列，
	还可以使用'\U'或'\u'表示非ASCII字符，但不能以数字开头。

	在预处理阶段，C语言的关键字没有特殊意义；在这个阶段，它们只是普通的标识符。
	因此，您可以定义一个宏，其名称是一个关键字。在预处理期间，唯一具有特殊意义的标识符是defined（请参阅defined）。

*预处理数值*

	预处理数值是指预处理阶段将其文本视为数字的内容，包括C语言的数值常量以及其他类似数值常量的字符序列。
	预处理并不尝试验证预处理数值是否在C语言中是有效的数字，实际上它不一定是一个合法的C语言数值。

	更准确地说，预处理数值以可选择以小数点开始，接着是必需的十进制数字，然后继续包含任意序列的字母、数字、下划线、
	小数点和指数部分。指数部分由两个字符组成，包括 'e+'、'e-'、'E+'、'E-'、'p+'、'p-'、'P+' 和 'P-'。
	（以 'p' 或 'P' 开头的指数部分是C99引入的，它们用于表示十六进制浮点常量。）

*标点*

	标点符号在语法上类似于运算符。以下是有效的标点符号：

#+begin_src c
	[  ]   (  )  {  }  .  ->
	++ --  &  *  +  -  ~  !
	/  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
	?  :   ;  ...
	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
	,  #   ##
	<: :>  <% %>  %:  %:%:
#+end_src

*字符串常量*

	在源代码中的字符串常量在预处理阶段被识别为一个单一的预处理标记。

*字符常量*

	在源代码中的字符常量在预处理阶段被识别为一个单一的预处理标记。

*头文件名*

	在#include指令内部，预处理器识别头文件名标记。它由'"name"'组成，
	其中name是除换行符和双引号之外的源代码字符序列，或者由'<name>'组成，
	其中name是除换行符和尖括号之外的源代码字符序列。

	在实际使用中，更方便的做法是将#include行视为不需要进行标记化的例外情况。

*其他*

	除此之外，在C源程序中任何其他有效的字符都会被视为独立的预处理标记。


一旦程序被划分为预处理标记，它们会保持独立直到预处理结束。
宏生成的两个连续标记会在必要时插入空格来保持它们的独立性。例如，

#+begin_src c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
#+end_src

唯一的例外是使用##预处理运算符，它将标记粘贴在一起（参见拼接）。

预处理将空字符（字符代码0）视为空格，但是对其生成警告，因为它可能对用户不可见（许多终端根本不显示它），
而且在文件中出现它很可能是一个错误。

* 头文件

头文件是一种C代码文件，通常包含C声明和宏定义（参见宏），用于在多个源代码文件之间共享。
您可以通过使用C预处理指令 #include 来请求在程序中使用头文件。

头文件有两个目的:

 * 操作系统使用头文件提供接口。您将操作系统提供的头文件包含在您的程序中，以提供您需要调用系统调用和库的定义和声明。

 * 特定程序的头文件包含特定程序源文件之间的接口声明。如果所有或大部分接口声明和宏定义在多个不同的源文件中都需要使用，那么为相关声明和宏定义创建一个头文件是一个不错的主意。

如果没有头文件那么就需要将相同内容在每个源文件中重新书写一遍，但是这样的重写不但浪费时间还容易出错。
有了头文件，相关的声明只出现在一个地方。如果它们需要被修改，您可以在一个地方进行修改，然后包含该头文件的程序在下次重新编译时会自动使用新版本。
头文件消除了查找和更改所有副本的工作量，同时也消除了未更改一个副本会导致程序内部不一致的风险。

在C语言中，通常的约定是给头文件命名以 .h 结尾。在头文件名称中，最好只使用字母、数字、破折号和下划线，并且最多只有一个点，这样可移植性最好。

** 包含头文件语法

您可以使用预处理指令 #include 来指定包含用户和系统头文件。它有两种变体：

#+begin_src c
#include <file>
#+end_src

	这个变体用于包含系统头文件。它在标准系统目录列表中搜索名为 "file" 的文件。您可以使用 -I 选项在此列表前添加目录
	（参见《使用GNU编译器集合》中的 "调用GCC"）。

#+begin_src c
#include "file"
#+end_src

	这个变体用于包含您自己程序的头文件。它首先在包含当前文件的目录中搜索名为 "file" 的文件，然后在引号目录中搜索，
	最后在用于 <file> 的相同目录中搜索。您可以使用 -iquote 选项在引号目录列表前添加目录。


在 #include 的参数中，无论是用引号括起来还是用尖括号括起来，它都像一个字符串常量一样运行，即不识别注释，并且不会展开宏名称。
因此，#include <x/*y> 表示包含一个名为 x/*y 的系统头文件。

一些系统将 ‘\’ 解释为文件名与路径的分隔符。所有系统以相同的方式解释 ‘/’。为了最大的可移植性，最好只使用 ‘/’。

在 #include 行的文件名后面放置除注释以外的任何内容都是错误的。
