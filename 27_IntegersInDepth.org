#+title: 深入整数

本章解释了整数类型的机器级细节：它们如何在内存中以位的形式表示，以及每种整数类型可能值的范围。

* 整数的表示

现代计算机将整数值存储为占用单个存储单元的二进制（以2为基数）数字，
通常作为8位的`char`、16位的`short int`、32位的`int`，
或者可能是64位的`long long int`。`long int` 是32位或64位值是系统相关的。 

在`limits.h`中定义的宏`CHAR_BIT`给出了`char`类型中的位数。在任何真正的操作系统中，该值是8。

数值类型的固定大小必然限制了它们的值范围，整数的特定编码决定了范围的大小。

对于无符号整数，整个空间用于表示非负值。有符号整数使用二进制补码表示：
具有n位的有符号整数的范围从-2^(n-1)到-1，然后到0，再到1，最后到+2^(n-1)-1，
包括这些值。最左边或最高位的位被称为符号位。

只有一个值表示零，最小负数没有相应的正数对应值。因此，对该数取反会导致溢出；
在实践中，其结果是再次得到该数。例如，一个二进制补码的有符号8位整数可以表示从-128到+127的所有十进制数。
我们将很快重新讨论这一特点。

几十年前，有些计算机并没有使用二进制补码表示整数（参见深入了解整数），但它们早已淘汰，不值得为之提供支持。

当一个算术操作产生一个无法表示的值时，该操作被称为溢出。在C中，
整数溢出不会中断控制流程或引发错误。它的行为取决于是否带符号。

对于无符号算术，溢出的操作结果是正确值的n个低位比特。如果正确的值可以用n比特表示，
那就总是这个结果；因此我们经常说“整数算术是精确的”，省略了关键的修饰词组“只要精确结果可以表示”。

原则上，C程序应该这样编写，以确保带符号整数永远不会溢出，但在GNU C中，
您可以指定各种处理这种溢出的方式（请参见整数溢出）。

通过查看一个小整数大小的表格，可以更好地理解整数表示；以下是一个具有三个比特的整数的可能值：


| Unsigned | Signed | Bits | 2s Complement |
|----------+--------+------+---------------|
|        0 |      0 |  000 |        000(0) |
|        1 |      1 |  001 |       111(-1) |
|        2 |      2 |  010 |       110(-2) |
|        3 |      3 |  011 |       101(-3) |
|        4 |     -4 |  100 |       100(-4) |
|        5 |     -3 |  101 |        011(3) |
|        6 |     -2 |  110 |        010(2) |
|        7 |     -1 |  111 |        001(1) |


最后一列中括号中的十进制数表示该行值的二进制补码的带符号含义。
请记住，在二进制补码编码中，当数字为非负数时，最高位为0。

现在我们可以理解对最负的二进制补码整数取反的奇特行为：从0b100开始，取反位得到0b011，
再加1：我们得到0b100，与我们最初的值相同。

我们也可以在二进制补码中看到溢出行为：

#+begin_src
3 + 1 = 0b011 + 0b001 = 0b100 = (-4)
3 + 2 = 0b011 + 0b010 = 0b101 = (-3)
3 + 3 = 0b011 + 0b011 = 0b110 = (-2)
#+end_src

两个非负的有符号值相加而导致溢出的结果，在符号位的值为1，因此精确的正值结果被截断为负值。

* 最大和最小值

对于每种原始整数类型，在limits.h中都定义了一个标准宏，用于给出该类型可以容纳的最大值。
例如，对于int类型，最大值是INT_MAX。在32位计算机上，这等于2,147,483,647。
无符号整数的最大值是UINT_MAX，在32位计算机上等于4,294,967,295。
同样，还有SHRT_MAX、LONG_MAX 和 LLONG_MAX，以及对应的无符号极限 USHRT_MAX、ULONG_MAX 和 ULLONG_MAX。

于有三种指定char类型的方式，因此也有三个限制：CHAR_MAX、SCHAR_MAX 和 UCHAR_MAX。

对于每种有符号或可能有符号的类型，还有另一个符号表示它可以容纳的最小值
（只需将上面列出的名称中的MAX替换为MIN）。对于使用unsigned指定的类型，
没有最小限制符号，因为它们的最小值通常为零。

INT_MIN 不是 INT_MAX 的负数。在二进制补码表示法中，最负的数是最正的数的负数再减1。
因此，在32位计算机上，INT_MIN 的值为-2,147,483,648。
实际上，您不能在C中以这种方式写出该值，因为它会溢出。这是使用 INT_MIN 来指定该值的一个很好的理由。
它的定义是为了避免溢出。
