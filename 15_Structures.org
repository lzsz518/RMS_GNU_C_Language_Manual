#+Title: 15 结构体

/结构体/ 是一种用户自定义的数据类型，它可以拥有不同的 /字段/ 。结构体中的字段都拥有名字和类型。

下面我们为给链表排序定义一个合适的结构体。链表的项包含一个整数和一个指向下一项的指针。

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };
#+end_src

这个结构体拥有一个类型标签所以其他代码可以使用它来定义这个结构类型的变量。这里的类型标签是 *intlistlink* 。
上面的结构体使用类型标签进行了递归定义。

你可以定义一个结构体而不使用类型标签，但是定义之后便无法再使用它。这只有在一些特殊场合有用，例如在
*typedef* 和 *联合体* 中。

结构体中的内容是大括号中的字段。每个字段都需要声明。在定义结构体时每一个字段都需要有一个明确的名字，但是
这个名字不会与程序中的其它名字产生冲突。

字段声明看起来就像是变量声明。你可以使用与变量声明相同的命名规则声明字段。

以上结构体有用两个字段。一个叫 *datum* 类型是 *int* 并可以为链表保存一个整数，另一个叫 *next* 类型是指向
另一个 *struct intlistlink* 的指针，从这个指针可以找到剩余的链表项。链表的最后一项中的 *next* 的值应该是 *NULL* 。

这个结构体是一个递归定义，因为 *next* 的类型是 *intlistlink* 类型。这样的递归定义是没有问题的；事实上你可以在
struck intlistlink 定之前使用类型 struct intlistlink *。这是因为在机器码的层级指向所有结构体的指针都是基本相同的。

结构体被定义之后，你可以声明一个 *struct intlistlink* 类型的变量：

#+begin_src c
  struct intlistlink foo;
#+end_src

结构定义本身可以作为变量声明的开始，所以你可以紧接着它声明变量，像这样:

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    } foo;
#+end_src

但是这看起来比较难看。将结构体的定义与使用它分开可以让代码看起来更清晰。

在代码块中声明结构体将会限制这个结构体的作用域仅仅存在于那个代码块中。这意味着这个结构体仅存在于那个代码块中。
在一个函数的参数列表中定义结构体：

#+begin_src c
  int f (struct foo {int a, b} parm);
#+end_src

(假设 *struct foo* 之前没被定义过) *struct foo* 的作用域仅限参数列表中；这没有任何用处所以会产生一个警告。

标准C语言需要结构体最少有一个字段，但是GNU C 没有这个限制。

* 结构体字段引用

结构体最常见的用处是对其字段进行存取，'.'(点)操作符用以完成该操作；写法类似 *对象.字段* 。

定义以下结构体和变量，

#+begin_src c
  struct intlistlink
    {
      int datum;
      struct intlistlink *next;
    };

  struct intlistlink foo;
#+end_src

你可以通过 *foo.datum* 和 *foo.next* 来引用结构体foo中的两个字段的值。这些字段都是左值所以你可以使用它们存取数值。

结构体经常会被动态分配(下一章节)，我们在引用它时需要通过指针。通过(*p).field 的形式访问有些繁琐，可以通过使用缩略
语的方式来简化访问: p->field. 例如假设程序中包含以下声明:

#+begin_src c
  struct intlistlink *ptr;
#+end_src

你可以使用 ptr->datum 和 ptr->next 来引用结构体指针中的两个字段。

如果一个一元运算符出现在使用'->'的表达式之前那么一元运算符会对'->'所引用的字段产生作用：

#+begin_src c
  -ptr->datum  等于   -(ptr->datum)
#+end_src

你可以在不使用小括号的情况下混合使用'->'和'.':

#+begin_src c
  struct { double d; struct intlistlink l; } foo;

  …foo.l.next->next->datum…
#+end_src

* 动态内存分配

若要给一个对象动态分配内存可以使用库函数 *malloc* (详见： [[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Basic-Allocation][The GNU C Library ]]GNU C 库函数手册)。这里演示如何动态分配一个
*struct intlistlink* 对象。若要使这段代码可以正常工作需要包含 *stdlib.h* :

#+begin_src c
  #include <stddef.h>  /* Defines NULL. */
  #include <stdlib.h>  /* Declares malloc.  */

  …

  struct intlistlink *
  alloc_intlistlink ()
  {
    struct intlistlink *p;

    p = malloc (sizeof (struct intlistlink));

    if (p == NULL)
      fatal ("Ran out of storage");

    /* Initialize the contents. */
    p->datum = 0;
    p->next = NULL;

    return p;
  }
#+end_src

*malloc* 的返回值是 *void* 类型，但是其赋值给 *p* 的时候会自动转换到 *struct intlistlink* *** 。 *malloc* 的返回值
总是充分对齐的(详见对其章节)，这使其可以转换到任意类型。

检测p是否为空是必要的因为当没有足够的可用内存时 *malloc* 会返回一个空指针。我们假设程序定义了 *fatal* 函数来向用户报告
致命错误。

这里展示如何在链表前面增加一个整数：

#+begin_src c
  struct intlistlink *my_list = NULL;

  void
  add_to_mylist (int my_int)
  {
    struct intlistlink *p = alloc_intlistlink ();

    p->datum = my_int;
    p->next = mylist;
    mylist = p;
  }
#+end_src

释放动态分配的对象的方法是调用 *free* 函数。这里是使用 *free* 函数释放链表中所有对象的例子：

#+begin_src c
  void
  free_intlist (struct intlistlink *p)
  {
    while (p)
      {
        struct intlistlink *q = p;
        p = p->next;
        free (q);
      }
  }
#+end_src

我们必须在一个对象被释放之前从其中提取 *next* 指针，因为 *free* 会删除对象中的数据。相同的原因，程序不应该使用被释放过
的对象中的元素。要确保这些不会发生最好清楚存储链表的变量，例如：

#+begin_src c
  free_intlist (mylist);

  mylist = NULL;
#+end_src

* 字段偏移

要确定一个结构体中一个字段的偏移量可以使用在 *stddef.h* 中的宏定义 *offsetof* 。看起来就像：

#+begin_src c
  offsetof (type, field)
#+end_src

例如：

#+begin_src c
  struct foo
  {
    int element;
    struct foo *next;
  };

  offsetof (struct foo, next)
  /* 在大多数机器上是 4.  有些机器上可能是 8.  */
#+end_src

* 结构体内存布局

本章及其后续章节是关于结构体的高级特性，如果你只是想学习C语言那么可以跳过这些章节。

合理的结构体内存布局对于硬件寄存器读写性能，共享内存中的数据存取和网络通信数据包的组合与拆分至关重要。对于避免由于使用结构体
导致的内存浪费同样重要。然而，内存布局依赖于具体的目标平台。每一种平台对于结构体内存布局都有具体的约定，编译器必须遵循这些约定。

以下是大多数平台对于结构体内存布局的约定：

结构体的字段按照其声明的顺序出现在结构体的内存布局中。在可能的情况下连续的字段在结构体中占据连续的字节。然而，如果一个字段需要
更多的字节来满足系统需要对齐的字节数那么C语言会在下一个字段出现之前补齐上一个字段对于对齐要求所缺少的字节。

当所有字段需要占据的字节都安排好之后结构体的对齐方式和大小就可以确定下来了。结构体的对齐方式指的是所有字段中需要最大的对齐字节。
结构体的大小是对齐方式整数倍。这可能需要在结构体的最后一个字段之后补充一些字节。

例如，我们假设 *char* 的大小是1对齐方式是1(永远是这样)， *int* 的大小和对齐方式都是4 (在大多数计算机上是这样)：

#+begin_src c
  struct foo
  {
    char a, b;
    int c;
  };
#+end_src

这个结构体在内存中将以4字节对齐的方式占用8个字节。 *a* 的偏移是0， *b* 的偏移是1， *c* 的偏移是4。在 字段 *b* 与 *c* 之间有
2字节的间隙以满足4字节的对齐方式。

对比下面的结构体：

#+begin_src c
  struct foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

这个结构体在内存中以4字节对齐的方式占用12个字节。 *a* 的偏移是0， *c* 的偏移是4， *b* 的偏移是8. 在字段 *a* 与 *c* 之间
有三个字节的间隙，在字段 *b* 之后又补充了三个字节。

以上两个结构体在C语言中拥有相同的字段，但是由于字段顺序的不同一个占用8字节内存另一个占用12字节内存。一个避免内存浪费的可靠的
途径是按照字节占用从大到小的顺序定义字段。

* 折叠结构体

在GNU C中你可以通过在 *struct* 关键字之后或结构体类型声明之后使用 *__attribute__((packed))* 强制结构体内存布局不进行内存对齐。
例如：

#+begin_src c
  struct __attribute__((packed)) foo
  {
    char a;
    int c;
    char b;
  };
#+end_src

假设 *int* 的对齐方式是4字节，在不使用 *__attribute__((packed))* 时这个结构体将占用12字节内存(如上一章所述)。使用
*__attribute__((packed))* 后它只占用6字节内存，这相当于每一个变量实际占用内存字节数的和。

使用 *__attribute__((packed))* 会经常导致字段不会按照其应用的方式进行对齐。在获取未进行内存对齐的字段的地址时可能会得到一个
非法的指针。在不允许出现未内存地址未对齐的指针的机器上进行指针解引用会产生 *SIGSEGV* 信号。
