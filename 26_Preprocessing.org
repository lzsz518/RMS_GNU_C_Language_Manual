#+title: 预处理

当GCC编译器对原文件进行编译时首先会进行文本替换与文件包含，这部分操作被称为预处理。

* 概述

GNU C在编译的第一阶段对C程序的每一行进行预处理。只有当一行包含预处理指令或使用宏时，
预处理器才对其进行处理，其他所有行都会在预处理之后保持不变。

以下是预处理所执行的一些任务。本章的其余部分将详细介绍这些内容。

 * 头文件的包含：头文件通常包含声明和宏定义，可以被替换到程序中。

 * 宏展开：您可以定义宏，宏是对任意C代码片段的缩写。预处理将宏替换为其定义。有些宏是自动预定义的。

 * 条件编译：您可以根据不同条件包含或排除程序的部分代码。

 * 行控制：如果您使用程序将源文件组合或重新排列成中间文件，然后再进行编译，您可以使用行控制来通知编译器每行源代码最初来自哪个文件。

 * 编译控制：#pragma和_Pragma可以调用一些特殊的编译器功能来处理特定的结构。

 * 诊断：您可以在编译时检测问题并输出错误或警告信息。

除了预定义宏的展开之外，所有这些操作仅在您使用预处理指令来请求它们时才会发生。

* 指令

预处理指令是程序中以‘#’开头的行。在‘#’之前和之后允许有空白字符。‘#’后面紧跟一个标识符，表示指令名称，
它指定要执行的操作。以下是一些示例：

#+begin_src c
#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
#+end_src

通常我们将指令写为#name，其中name是指令名称。例如，#define 表示定义宏的指令。

以‘#’开头的指令不能来自宏展开。另外，指令名称不会进行宏展开。因此，如果将foo定义为一个展开为define的宏，
那么#foo就不是一个有效的预处理指令。

C语言拥有固定数量的合法预处理指令，程序员不能自己定义新的预处理指令。

一些指令需要参数；这些参数位于指令行的其余部分，并且必须与指令名称用空白分隔开。
例如，#define 后面必须跟着宏的名称和宏的预期展开内容。

预处理指令不能跨越多行。但是，可以使用反斜杠换行符（backslash-newline）或者使用/*...*/风格的注释来延续行。
在指令被处理之前，这些反斜杠换行符或注释将被替换掉（替换为空白或删除），以便保持指令的连续性。

* 标记

预处理将C代码（去除其注释）划分为预处理标记，这些标记类似于C标记，但并不完全相同。以下是预处理标记的特点。

预处理标记的主要类别包括标识符、预处理数值、字符串常量、字符常量和标点符号；还有一些其他类型的预处理标记。

*标识符*

	标识符预处理标记在语法上类似于C中的标识符：它可以是由字母、数字或下划线组成的任意序列，
	还可以使用'\U'或'\u'表示非ASCII字符，但不能以数字开头。

	在预处理阶段，C语言的关键字没有特殊意义；在这个阶段，它们只是普通的标识符。
	因此，您可以定义一个宏，其名称是一个关键字。在预处理期间，唯一具有特殊意义的标识符是defined（请参阅defined）。

*预处理数值*

	预处理数值是指预处理阶段将其文本视为数字的内容，包括C语言的数值常量以及其他类似数值常量的字符序列。
	预处理并不尝试验证预处理数值是否在C语言中是有效的数字，实际上它不一定是一个合法的C语言数值。

	更准确地说，预处理数值以可选择以小数点开始，接着是必需的十进制数字，然后继续包含任意序列的字母、数字、下划线、
	小数点和指数部分。指数部分由两个字符组成，包括 'e+'、'e-'、'E+'、'E-'、'p+'、'p-'、'P+' 和 'P-'。
	（以 'p' 或 'P' 开头的指数部分是C99引入的，它们用于表示十六进制浮点常量。）

*标点*

	标点符号在语法上类似于运算符。以下是有效的标点符号：

#+begin_src c
	[  ]   (  )  {  }  .  ->
	++ --  &  *  +  -  ~  !
	/  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
	?  :   ;  ...
	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
	,  #   ##
	<: :>  <% %>  %:  %:%:
#+end_src

*字符串常量*

	在源代码中的字符串常量在预处理阶段被识别为一个单一的预处理标记。

*字符常量*

	在源代码中的字符常量在预处理阶段被识别为一个单一的预处理标记。

*头文件名*

	在#include指令内部，预处理器识别头文件名标记。它由'"name"'组成，
	其中name是除换行符和双引号之外的源代码字符序列，或者由'<name>'组成，
	其中name是除换行符和尖括号之外的源代码字符序列。

	在实际使用中，更方便的做法是将#include行视为不需要进行标记化的例外情况。

*其他*

	除此之外，在C源程序中任何其他有效的字符都会被视为独立的预处理标记。


一旦程序被划分为预处理标记，它们会保持独立直到预处理结束。
宏生成的两个连续标记会在必要时插入空格来保持它们的独立性。例如，

#+begin_src c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
#+end_src

唯一的例外是使用##预处理运算符，它将标记粘贴在一起（参见拼接）。

预处理将空字符（字符代码0）视为空格，但是对其生成警告，因为它可能对用户不可见（许多终端根本不显示它），
而且在文件中出现它很可能是一个错误。
