#+Title: 10 执行顺序

* 10 执行顺序

C语言程序的执行顺序并不总是显而易见的，并且是不可预测的。本章将介绍这其中有什么是你可以信任的。

** 操作数的重新排序

C语言并不总是按照表达式在代码中出现的顺序去执行它们。例如下面的表达式：
#+begin_src c
  foo () + bar ()
#+end_src
foo和bar都有可能先被执行。如果foo先更新了数据集然后bar使用了它们那么表达式的执行结果将是不可预测的。

当表达式含有赋值操作时那么它也会使子表达式的计算顺序变得不可预测。我们之间就看过一个坏的的例子：

#+begin_src c
  x = 20;
  printf ("%d %d\n", x, x = 4);
#+end_src

第二个参数x的只完全依赖第三个参数执行赋值的先后顺序。

** 关联性和执行顺序

当重复使用关联二元操作符时可以关联任意数量的操作数，例如'+'。这些被关联的操作数可能以任何顺序进行计算。

如果数值时整数并且溢出可以被忽略，那么他们可以任何顺序进行结合。因此，调用四个返回值是无符号整数的函数
并将他们相加，最后结果可能以任何计算顺序得出：

#+begin_src c
  (foo () + bar ()) + (baz () + quux ())
#+end_src

对比之下，带有溢出的有符号整数的算数运算并不真正具有关联性(详见整数溢出章节)。因此，加法必须使用小括号
指定向左关联的执行顺序。这意味着首先计算(foo() + bar())和(baz() + quux())然后再将两个表达式的结果
相加。

这同样食用于浮点数的算术运算，因为它们实际上并不相关。然而，GCC的 *-funsafe-math-optimizations*
选项允许当关联运算符(数学意义上的关联)将多个运算数结合起来时改变它们的计算顺序。该现象将再编译一个
模块时生效(详见编译章节)。改变关联顺序可以使程序对浮点数进行流水线操作。

这四个函数在任何情况下都可能以不同的顺序被执行，这无关对错。

** 序列点

C语言中存在一种被成为顺序点的事物用来有限的保证运算符的执行顺序。序列点将出现再下列地点：

 * 完整 /表达式/ 的最后；就是说一个不是更大表达式的一部分的表达式。表达式的执行效果再之后的代码
   执行之前显现。

 * 特定运算符的第一个操作数的结尾：','，'&&'，'||'，和'?'。代表第一个操作数的表达式的执行效果
   将在执行代表第二个操作数的表达式执行之前显现。
   在函数的参数列表中用来分隔参数的逗号并不是逗号运算符，它并不产生序列点。函数参数的规则和运算符
   的规则是不同的(详见运算符重排序章节)

 * 函数调用之前。参数中的表达式的的执行效果在函数调用之前都会显现。
   如果将要调用的函数不是一个常量--就是说，如果它是被表达式所计算出来的--表达式的所有执行效果都会在
   函数调用之前显现。

执行顺序只会被序列点应用于有限范围内的局部代码，如同上述的几种情况。例如，使用逗号运算符规定执行顺序
并不能影响逗号运算符作用范围以外的操作数。因此在下面的代码中：

#+begin_src c
  (x = 5, foo (x)) + x * x
#+end_src

逗号运算符仅限定了x = 5在f(x)之前执行，但是x * x可能在他们之前之后执行。

** 后缀递增和执行顺序

执行顺序对于后缀递增和后缀递减的需求比较宽松(详见后缀递增/后缀递减)，其中特定的执行效果将在‘晚些时候’显现。
它们必须在下一个序列点之前显现，但是仍然为多种可能留下了空间。在下面的表达式中：

#+begin_src c
  z = x++ - foo ()
#+end_src

x的值在调用foo之前或之后增加是不可预测的。如果foo引用了x，那么它可能得到x原始的值或者递增过的值。

这个反常的表达式：

#+begin_src c
  x = x++
#+end_src

x的值肯定会递增但是增加之后的值可能并不会持久。如果x的递增在赋值之后发生，那么递增之后的值将保留在x中。但是
如果递增先发生，赋值将重写还没有递增的x，所以整个表达式将使x的值保持不变。

** 操作数的顺序

操作数和参数可以以任何顺序进行计算，但是在GNU C中对这种不确定的执行顺序有一些限制：

 * 二元算术运算符的操作数可能以任意顺序计算，但是绝不可能同时被计算：先计算其中一个，然后再计算另一个。
   先被计算的操作数的执行效果必定再后被计算的操作数的执行效果之前显现。

 * 上述规则同样适用于赋值运算符，除非在左边操作数被赋值之前的值未被使用的简单赋值的情况下。

 * 函数调用中的参数可以以任意顺序计算，但是它们不可能同时被计算。因此，一个参数将先被计算然后是另外一个，
   直到所有参数都被计算完成。每一个参数的执行效果都将在计算下一个参数之前显现。

上面的规则并不适用于前缀递增和前缀递减运算符产生的执行效果，它们可以将效果的显现延后到下一个序列点。

如果你希望更咬文嚼字一些，那么实际上GCC在不影响程序运行结果的情况下提供多种优化方式来重新排列计算顺序。
然而，由于这样做并不影响程序的运行结果所以完全可以对其置之不理，除非你担心其他进程看到某些变量的值与
当前进程不同步。对于这种情况你可以使用 *volatile* 关键字声明变量以防止编译器优化给变量带来的奇怪行为。

** 优化与重排序

序列点限制了编译器自由的任意重新排列运算的顺序，但是如果编译器检测到优化并不会影响最终结果那么仍然可以重新
排列运算顺序。因此对于一下代码：

#+begin_src c
  x++;
  y = z;
  x++;
#+end_src

每一条语句都有一个序列点，所以以上代码应该是在给y赋值之前将x的加1。然而，x加1并不会对y或z产生影响，并且
给y赋值也不会影响x，所以代码可以被优化成：

#+begin_src c
  y = z;
  x += 2;
#+end_src

通常情况下这样的优化除了使程序运行的更快以外不会产生其他任何影响。但是有一些特殊情况会在编译器不知情的优化下
产生一些麻烦，例如共享内存。要限制这些地方的优化请使用 *volatile* 类型修饰(详见volatile章节)
