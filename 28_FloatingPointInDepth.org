#+title: 深入浮点数

* 浮点数的呈现方式

将数字存储为浮点数允许表示具有分数值的数字，其范围大于硬件整数的范围。浮点数由一个符号位、
一个尾数（也称为尾数）、以及一个固定基数的幂组成。GNU C 使用IEEE 754-2008《浮点运算标准》规定的浮点表示法。

IEEE 754-2008 规范定义了五种不同大小的基本二进制浮点格式：16位、32位、64位、128位和256位。
其中，32位、64位和128位的格式用于标准C类型 float、double 和 long double。
GNU C 在某些平台上支持16位浮点类型 _Float16，但不支持256位浮点类型。

每种格式都将浮点数编码为一个符号位。接下来是一个指数，指定了2的幂（带有一个固定偏移）。然后是尾数。

尾数的第一个位，在二进制点之前，始终为1，因此无需将其存储在内存中。它称为隐藏位，因为它在计算机本身使用的浮点数中不可见。

所有这些浮点格式都是带符号的幂表示法，因此+0和-0是不同的值。

除了IEEE 754格式的128位浮点数之外，GNU C 还提供了由一对64位浮点数组成的格式。
这种格式不具备IEEE 128位格式的完整指数范围，但在底层硬件平台不支持该格式时很有用。

* 浮点数的规格

标准库头文件 float.h 定义了一些常量，用于描述平台对浮点类型 float、double 和 long double 的实现。这些常量包括：

#+begin_src c
FLT_MIN

DBL_MIN

LDBL_MIN
#+end_src

它们定义了可以用该类型表示的最小规格化正浮点值。

#+begin_src c
FLT_HAS_SUBNORM

DBL_HAS_SUBNORM

LDBL_HAS_SUBNORM
#+end_src

它们定义了浮点类型是否支持次正规（或“非规格化”）数，参见非规格化数。

#+begin_src c
FLT_TRUE_MIN

DBL_TRUE_MIN

LDBL_TRUE_MIN
#+end_src

它们定义了可以用该类型表示的最小正值（包括次正规值）。

#+begin_src c
FLT_MAX

DBL_MAX

LDBL_MAX
#+end_src

它们定义了可以用该类型表示的最大值。

#+begin_src c
FLT_DECIMAL_DIG

DBL_DECIMAL_DIG

LDBL_DECIMAL_DIG
#+end_src

它们定义了一个十进制数字 n 的数量，使得可以将任何可以用该类型表示的浮点数四舍五入为具有 n 位小数的浮点数，
然后再转换回来，而不会失去任何值的精度。

* 特殊的点数值


IEEE浮点数提供了一些特殊的值，它们不是普通的数字。

 * infinities(无限)

 +Infinities和-Infinty是两个不同的无限大值。它们是由诸如1 / 0、Infinity + Infinity、Infinity * Infinity、Infinity + finite
 等操作产生的，还可以由一个有限但大于最大可能值或小于最小可能值的结果产生。

 有关处理无穷大的更多信息，请参阅"处理无穷大"。

 * NaNs(非数值)

 有两个特殊的值，称为非数值（NaN）：安静的NaN（QNaN）和信号NaN（SNaN）。

 **QNaN** 由于在实数运算中其值未定义而产生，例如0 / 0、sqrt(-1)、Infinity - Infinity以及任何基本操作中的一个操作数是QNaN。

 **信号NaN（SNaN）** 旨在初始化未分配的存储空间，与QNaN不同，SNaN会引发一个中断，可以被软件处理程序捕获、诊断和报告。
 实际上，鲜有使用信号NaN，因为桌面和便携计算机中最常见的CPU未实现完整的IEEE 754标准，只提供了一种NaN，即安静的NaN。
 此外，编程语言标准需要几十年的时间来跟上IEEE 754标准的步伐，这些语言标准的实现在程序员愿意使用这些特性之前还需要额外的时间。

 要启用对信号NaN的支持，请使用GCC命令行选项`-fsignaling-nans`，但这是一个实验性功能，并且在每种情况下都可能无法按预期工作。

 NaN具有一个符号位，但其值毫无意义。

 有关处理NaN的更多信息，请参阅"处理NaN"。   

* 非规格化数

可能发生计算出的浮点值太小而无法表示的情况，例如当两个非常小的数相乘时。
结果被称为"下溢"。在IEEE 754标准出现之前，传统的行为是将结果设为零，并且可能在某种程序输出中报告下溢。

IEEE 754标准对于舍入是否在检测到浮点下溢和上溢之前发生或之后发生模糊不清，CPU设计者可以选择其中之一。

然而，与早期设计相比，该标准采用了一种不同寻常的方式，即当结果小于最小可规格化值（即前导尾数位为1的值）时，
放宽了规格化要求，允许前导零位，并逐渐丧失精度，直到尾数不再有位。这种现象称为"渐进下溢"，
它在数值计算中具有重要作用，尽管它会降低最终结果的精度。一些浮点设计允许您在编译时甚至在运行时选择下溢是渐进的还是突然变为零。
已进入渐进下溢区域的数字称为"次规格化数"。

您可以使用库函数 fesetround 和 fegetround 来设置和获取舍入模式。
舍入模式在 fenv.h 中定义（如果平台支持）：FE_UPWARD 用于朝正无穷舍入；
FE_DOWNWARD 用于朝负无穷舍入；FE_TOWARDZERO 用于朝零舍入；
FE_TONEAREST 用于舍入到最接近的可表示值，这是默认模式。除非有特殊需要，最好使用 FE_TONEAREST 模式。

* 无效优化

有符号零、无穷大和NaN使得程序员和编译器可能会放弃一些本来似乎很明显的优化：

 * x + 0 和 x - 0 当 x 为零时不同，因为结果取决于舍入规则。有关舍入规则的更多信息，请参阅"舍入"。
 * x * 0.0 与 0.0 不同，当 x 为无穷大、NaN 或负零时。
 * x / x 与 1.0 不同，当 x 为无穷大、NaN 或零时。
 * (x - y) 与 -(y - x) 不同，因为当操作数有限且相等时，一个计算为+0，另一个计算为-0。
 * x - x 与 0.0 不同，当 x 为无穷大或NaN时。
 * x == x 和 x != x 与 1 和 0 不等同，当 x 为NaN时。
 * x < y 和 isless (x, y) 不等同，因为前者在操作数为NaN时设置一个粘性异常标志（请参阅异常标志），而后者不会影响该标志。对于与关系运算符配对的其他isxxx函数也是如此。请参阅GNU C库参考手册中的FP比较函数。

选项 `-funsafe-math-optimizations` 启用了这些优化。

* 浮动算术异常标志

粘性异常标志记录特定条件的发生：一旦设置，它们将保持设置状态，直到程序明确清除它们。

这些条件包括无效操作数、除以零、不精确的结果（即需要四舍五入的结果）、下溢和上溢。一些扩展的浮点设计提供了几个额外的异常标志。
函数 `feclearexcept`、`feraiseexcept`、`fetestexcept`、`fegetexceptflags` 和
`fesetexceptflags` 提供了一个标准化的接口来访问这些标志。有关操作状态位的信息，请参阅GNU C库参考手册中的"状态位操作"。

其中一个重要用途是执行通常在浮点算术中被认为是精确的计算，但偶尔可能不精确，此时需要采取纠正措施。
您可以通过调用 `feclearexcept(FE_INEXACT)` 来清除不精确结果标志，进行计算，然后使用 `fetestexcept(FE_INEXACT)`
测试标志；如果标志未设置（没有进行四舍五入），那么该调用的结果为0，当进行四舍五入时（我们假设这意味着程序需要进行修正）结果为1。

* 精确浮点数算术

只要数字可以精确表示（分母是2的幂的分数），且中间结果不需要舍入，那么浮点算术就是精确的。很容易预测算术操作的结果需要多少位数字：

 * 具有相同指数的两个n位值的加法和减法最多需要n + 1位数字，但当指数不同时，可能需要更多位数字；

 * 两个n位值的乘法需要精确的2n位数字；

 * 尽管整数除法产生的商和余数都不超过n位数字，但浮点余数和平方根可能需要无限多位数字，而商可能需要比存储空间多得多的位数。

每当结果需要超过n位数字时，就需要进行舍入。

* 四舍五入

当浮点算术产生一个结果，无法完全容纳在正在使用的类型的尾数中时，就必须对该值进行舍入。
基本的算术操作，如加法、减法、乘法、除法和平方根，总是产生一个等价于准确结果（可能是无限精度）按照当前的舍入规则舍入到存储精度的结果。

舍入会设置 `FE_INEXACT` 异常标志（参见异常标志）。这使得程序可以确定发生了舍入。

舍入包括调整指数，使尾数返回到所需的基点对齐，然后根据当前的舍入规则将尾数压缩到固定的可用大小。

当前规则是在运行时从四个选项中选择的。以下是它们：

 * 最近舍入，如果遇到一半的情况则舍入到最接近的偶数；

 * 向上舍入，朝正无穷舍入；

 * 向下舍入，朝负无穷舍入；

 * 向零舍入。

在这四个舍入规则下，一个要舍入为四位数字结果的十进制值 -1.2345 会分别变为 -1.234、-1.234、-1.235 和 -1.234。

默认的舍入规则是最近舍入，因为它具有最小的偏差，并且产生最低的平均误差。当真实结果恰好处于两个可表示的机器数之间时，
结果会舍入为以偶数数字结尾的那一个。

向零舍入规则在许多早期计算机设计中很常见，因为它最容易实现：它只需要对所有额外的位进行静默截断。

另外两个规则，向上舍入和向下舍入，对于实现区间算术至关重要，其中每个算术操作产生下限和上限，这些下限和上限被保证包围精确结果。

有关获取和设置当前舍入模式的详细信息，请参阅"舍入控制"。

* 舍入问题

默认的IEEE 754舍入模式最小化了误差，大多数常规计算不应该因舍入而积累严重的误差。

当然，你可以构造一些例子来证明这一点。以下是一个例子：迭代计算一个数的平方根，然后尝试通过重复平方来恢复原始值。

#+begin_src c
#include <stdio.h>
#include <math.h>

int main (void)
{
  double x = 100.0;
  double y;
  for (n = 10; n <= 100; n += 10)
    {
      y = x;
      for (k = 0; k < n; ++k) y = sqrt (y);
      for (k = 0; k < n; ++k) y *= y;
      printf ("n = %3d; x = %.0f\ty = %.6f\n", n, x, y);
    }
  return 0;
}
#+end_src

输出如下：

#+begin_src c
n =  10; x = 100        y = 100.000000
n =  20; x = 100        y = 100.000000
n =  30; x = 100        y = 99.999977
n =  40; x = 100        y = 99.981025
n =  50; x = 100        y = 90.017127
n =  60; x = 100        y = 1.000000
n =  70; x = 100        y = 1.000000
n =  80; x = 100        y = 1.000000
n =  90; x = 100        y = 1.000000
n = 100; x = 100        y = 1.000000
#+end_src

经过50次迭代，y仅有一位正确的数字，而不久后，将没有正确的数字。

* 精度损失

在浮点计算中，更严重的误差来源之一是从几乎相等的值相减中导致的精度损失。
这意味着结果的尾数中的位数比该值的大小允许的位数要少。如果被相减的值足够接近但仍不相等，
单次减法可能会抹掉所有正确的数字，可能污染所有未来的计算。

浮点计算有时可以精心设计，以确保不会发生有精度损失，例如求和一系列所有项具有相同符号的级数。
例如，三角函数和双曲正弦的泰勒级数展开具有相同幅度的项，一般形式为 x**(2*n + 1) / (2*n + 1)!。
然而，三角函数正弦级数中的项在符号上交替，而双曲正弦级数中的项都是正数。
以下是两个小程序的输出，它们对sin(x)级数的前k项求和，并将计算得到的和与已知精确的库函数进行比较：

#+begin_src c
x = 10      k = 51
s (x)   = -0.544_021_110_889_270
sin (x) = -0.544_021_110_889_370

x = 20      k = 81
s (x)   = 0.912_945_250_749_573
sin (x) = 0.912_945_250_727_628

x = 30      k = 109
s (x)   = -0.987_813_746_058_855
sin (x) = -0.988_031_624_092_862

x = 40      k = 137
s (x)   = 0.617_400_430_980_474
sin (x) = 0.745_113_160_479_349

x = 50      k = 159
s (x)   = 57_105.187_673_745_720_532
sin (x) = -0.262_374_853_703_929

// sinh(x) series summation with positive signs
// with k terms needed to converge to machine precision

x = 10      k = 47
t (x)    = 1.101_323_287_470_340e+04
sinh (x) = 1.101_323_287_470_339e+04

x = 20      k = 69
t (x)    = 2.425_825_977_048_951e+08
sinh (x) = 2.425_825_977_048_951e+08

x = 30      k = 87
t (x)    = 5.343_237_290_762_229e+12
sinh (x) = 5.343_237_290_762_231e+12

x = 40      k = 105
t (x)    = 1.176_926_334_185_100e+17
sinh (x) = 1.176_926_334_185_100e+17

x = 50      k = 121
t (x)    = 2.592_352_764_293_534e+21
sinh (x) = 2.592_352_764_293_536e+21
#+end_src

我们已经在数字中添加了下划线以增强可读性。

正项的sinh(x)级数可以被求和到高精度。相比之下，sin(x)级数会受到逐渐增加的有效数字损失的影响，
因此当x = 30时，只有两位正确的数字保留下来。不久后，所有数字都是错误的，答案毫无意义。

数值编程中的一个重要技能是识别何时有效数字损失可能会影响计算，并修改算法以减少这个问题。
有时，唯一可行的方法是以更高的中间精度进行计算，这就是扩展类型如long double之类的重要性所在。

* 融合乘法-加法

1990年，IBM引入了POWER架构时，CPU提供了一条之前未知的指令，即融合乘法-加法（FMA）。
它计算值x * y + z，通过精确的双长度乘积，然后进行一次舍入后的加法。在数值计算中，经常需要一对乘法和加法操作，FMA非常适合这种需求。

在POWER架构中，有两个专用寄存器用于存储永久值0.0和1.0，而普通的乘法和加法指令只是FMA的包装器，分别计算x * y + 0.0和x * 1.0 + z。

在早期，FMA的主要优点似乎是以一个操作的价格获得两个浮点操作，几乎将某些算法的性能翻倍。
然而，自那时以来，数值分析家已经展示了FMA在显著提高精度方面的许多用途。我们将在下一节讨论其中一个最重要的用途。

自那时以来，一些其他架构已经包括了FMA，并且大多数提供了相关操作x * y - z（FMS）、-x * y + z（FNMA）和-x * y - z（FNMS）的变种。

函数`fmaf`、`fma`和`fmal`实现了浮点、双精度和长双精度数据类型的融合乘法-加法。
在软件中正确实现FMA是困难的，一些系统似乎提供了这些函数，但不满足单次舍入的要求。
随着越来越多的程序员使用FMA操作，以及更多的CPU在硬件中提供FMA，这种情况应该会发生改变。

使用`-ffp-contract=fast`选项允许生成FMA指令，或使用`-ffp-contract=off`选项禁止它。


