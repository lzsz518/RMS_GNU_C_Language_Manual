#+title: 12 常数

常数是显式呈现恒定值的表达式。C语言允许的常量类型有数值，字符和字符串。前面已经使用过数值和字符串常量。

** 整型常数

整型常数是一个指定的数值并且通过字符后缀指定常量为哪种类型的整数。

最简单的整型常数是十进制数字，例如 5，77，403。十进制整型常数不能以字符'0'开始因为这让它变成八进制数。

你可以给整型常数前面加上负号让它变成一个负数。从语法上讲这将使其成为一个算术表达式而不是常量，但是它
的行为和真正的常数一样。

常数也能以八进制，十六进和二进制形式表示。八进制常量以字符'0'作为前缀，之后是任意数量的八进制数('0'--'7'):

#+begin_src c
  0      // zero
  077    // 63
  0403   // 259
#+end_src

如果非要咬文嚼字，常数 *0* 是一个八进制常数，但是也可以认为它是一个十进制常数，尽管不论那种进制它的值都是相同的。

十六进制常量以字符'0x'(x 大小写均可)作为前缀，之后是任意十六进制数('0'--'9','a'--'f'大小写均可)：

#+begin_src c
  0xff   // 255
  0XA0   // 160
  0xffFF // 65535
#+end_src

二进制常数以字符'0b'(大小写均可)，之后是任意二进制数('0'--'1')：

#+begin_src c
  0b101   // 5
#+end_src

二进制常数仅仅被GNU C支持，它并不被标准C支持。

有些时候整型常数后面需要一个空格以防止与后续标记产生歧义。详情请见非法数值。

** 整型常数类型

一般情况下如果整型常数的大小适合与 *int* 型那么这就是它的类型，但是对于如何决定类型仍然存在完整的规则。
一个整型常数的类型是一下列表中第一个可以正确存储该值的类型：

 1. int
 1. unsigned int
 1. long int
 1. unsigned long int
 1. long long int
 1. unsigned long long int

对以上列表还有下面的例外规则：

 * 如果常数后缀为'l'或'L'，忽略列表前两项
 * 如果常数后缀为'll'或'LL'，忽略列表前四项
 * 如果常数后缀为'u'或'U'，忽略所有有符号项
 * 如果常数是十进制的，忽略无符号项

例如：

#+begin_src c
  3000000000u      // three billion as unsigned int.
  0LL              // zero as a long long int.
  0403l            // 259 as a long int.
#+end_src 

整型常数中的后缀很少使用。当类型的精确性很重要时使用显示类型转换是明智的选择。详情请见显示类型准换与整数类型章节。


** 浮点常数

浮点数常量必须有一个小数点或一个十的指数又或两者兼备；它们是辨别整型常数还是浮点常数的标志。

'e'或'E'加上随后的数字表示指数。指数总是使用十进制数字，它前面还可以加正负号。指数 /n/ 的意义是将常数乘以10的
n次方。

因此，'1500.0'，'15e2'，'15e+2'，'1.5e+3'，'.15e4'，与 '15000e-1' 的值都等于1500。

使用小数点的例子：

#+begin_src c
  1.0
  1000.
  3.14159
  .05
  .0005
#+end_src

对于以上数值这里是一些等价表示法：

#+begin_src c
  1e0, 1.0000e0
  100e1, 100e+1, 100E+1, 1e3, 10000e-1
  3.14159e0
  5e-2, .0005e+2, 5E-2, .0005E2
    .05e-2
#+end_src

通常情况下浮点常数的类型是 *double* 。但是你可以通过后缀'f'或'F'指定它们为 *float* ：

#+begin_src c
  3.14159f
  3.14159e0f
  1000.f
  100E1F
  .0005f
  .05e-2f
#+end_src

同样的，后缀'l'或'L'强制指定类型为 *long double* 。

你也可以在十六进制浮点数中使用指数，但是因为'e'属于十六进制数的基数所以需要使用'p'或'P'(意为'power')来代替它。

十六进制常数中的指数可以是有符号的十进制整数，指数在这里的底数是2而不是10或16。

例如：

#+begin_src c
0xAp2        // 40 in decimal
0xAp-1       // 5 in decimal
0x2.0Bp4     // 16.75 decimal
0xE.2p3      // 121 decimal
0x123.ABCp0  // 291.6708984375 in decimal
0x123.ABCp4  // 4666.734375 in decimal
0x100p-8     // 1
0x10p-4      // 1
0x1p+4       // 16
0x1p+8       // 256
#+end_src

详情请见浮点数数据类型章节

** 虚数常数

复数由实部和虚部组成。(其中一个或两个部分都可以为零)。本节说明如何用虚数值书写复数常数。
通过将这些添加到普通的实数值常数，我们可以创建具有复数值的常量。

书写虚数常量的简单方法是给整数或浮点常量添加后缀'i'或'I'，或'j'或'J'。 例如，2.5fi 的类型为 _Complex float，
而 3i 的类型为 _Complex int。 四个后缀字母都是等价的。

另一种数写虚常数的方法是将实常数乘以 _Complex_I，它表示虚数 i。 标准 C 不支持后缀为'i'或'j'，因此需要这种笨拙的方式。

要书写具有非零实部和非零虚部的复数常数，请分别书写并添加它们，如下所示：

#+begin_src c
  4.0 + 3.0i
#+end_src

这将赋予 4+3i *_Complex double* 。

如同求和时可以使用0个或多个实数常数，同样的也可以使用0个或多个虚数常数：

#+begin_src c
  _Complex double foo, bar, quux;
  foo = 2.0i + 4.0 + 3.0i; /* Imaginary part is 5.0. */
  bar = 4.0 + 12.0; /* Imaginary part is 0.0. */
  quux = 3.0i + 15.0i; /* Real part is 0.0. */
#+end_src

详情请见复数数据类型。

** 非法数值

在预处理指令中，一些不是真正有效的数字常数的类似数字的结构被视为数字。 如果这些结构出现在预处理之外，
它们就是错误的。 请参阅预处理标记。

有时我们需要插入空格来分隔标记，这样它们就不会组合成一个类似数字的结构。 例如，0xE+12 是一个预处理数字，
它不是一个有效的数字常量，因此它是一个语法错误。 如果我们想要的是 0xE + 12 这三个标记，我们必须使用这些空格作为分隔符。

** 字符常数

单引号之内的字符被成为字符常数，例如'c'。在这个简单的例子中 /c/ 是最终被显示的单一ASCII字符。字符常数的类型是 *int* ,
它的值是对应的ASCII码。例如，呈现字符'a'的字符常数的值是97。

要将'''(单引号)作为字符常量需要使用反斜杠('\')来引用它，写出来就是：'\''。这个以反斜杠开始的序列被称为转义序列，
反斜杠在这里作为转移字符是使用。

要将'\'(反斜杠)作为字符常量需要使用他自己引用它。写出来就是：'\\'。

以下是字符常数中的所有转义序列。 显示的数值是相应的 ASCII 字符代码，为十进制数。

#+begin_src c
  '\a' ⇒ 7       /* alarm, CTRL-g */
  '\b' ⇒ 8       /* backspace, BS, CTRL-h */
  '\t' ⇒ 9       /* tab, TAB, CTRL-i */
  '\n' ⇒ 10      /* newline, CTRL-j */
  '\v' ⇒ 11      /* vertical tab, CTRL-k */
  '\f' ⇒ 12      /* formfeed, CTRL-l */
  '\r' ⇒ 13      /* carriage return, RET, CTRL-m */
  '\e' ⇒ 27      /* escape character, ESC, CTRL-[ */
  '\\' ⇒ 92      /* backslash character, \ */
  '\'' ⇒ 39      /* singlequote character, ' */
  '\"' ⇒ 34      /* doublequote character, " */
  '\?' ⇒ 63      /* question mark, ? */
#+end_src

'\e' 是GNU C的扩展，要兼容标准C请使用 '\33'。

也可以使用八进制和十六进制的字符代码例如：'\otcalcode'或'\xhexcode'。十进制并不是唯一选择，八进制并不需要以'0'前缀开始。

字符常数是 *int* 类型。然而字符的值却被初始化成 *char* 类型，然后转换成 *int* 。如果字符值大于127(八进制数0177)，那么
对于 *char* 类型为8比特有符号数的平台转换的结果在 *int* 中有可能是负数。

** 字符串常数

字符串常数由一系列写在双引号之间的字符组成。在字符串常数中书写'"'，'\'和'\n'等特殊字符和在字符常数中的方法一样。在字符串
常量里单引号不需要转义字符('\')。

字符串常数定义了一个以字符0结尾包含特定字符的数组。使用字符串常数如同使用包含相同内容的数组。一般情况下，
字符串常量的字节长度比其中写入的字符数大1。

和C语言里的数组一样，在表达式中使用字符串常量其会被转换成一个指向数组中第一个元素的指针(详情请见指针章节)。
因为这个指针是指向以 *char* 类型为元素的数组所以这个指针将是 *char ** 类型的。 *char* 是一个指针类型的类型指定的例子。
(详情请见指针类型指定)。 字符串变量也通常*char** 类型，而不仅仅只有字符串常量使用它它。

因此，字符串常数 *"Foo!"* 近乎等价于声明一个如下数组：

#+begin_src c
  char string_array_1[] = {'F', 'o', 'o', '!', '\0' };
#+end_src

然后在程序中使用名为 *string_array_1* 的数组。字符串常数与数组有两点不同：

 * 字符串常数并不定义数组名。
 * 字符串常数多半存储在只读内存区域。

字符串常数的文本中不允许使用换行符。这条禁令的目的是捕获丢失结束双引号'"'的错误。要在字符串常数中使用换行请使用'\n'转义字符。

源代码中字符串常量内的真正空字符会导致警告。 要在字符串常量中间放置一个空字符，请使用‘\0’或‘\000’。

连续的字符串常量将被视为有效字符串而连接起来，因此：
#+begin_src c
  "Fo" "o!"   等价于   "Foo!" 
#+end_src

这是书写包含多行的字符串非常有用的方法，例如：

#+begin_src c
  "This message is so long that it needs more than\n"
  "a single line of text.  C does not allow a newline\n"
  "to represent itself in a string constant, so we have to\n"
  "write \\n to put it in the string.  For readability of\n"
  "the source code, it is advisable to put line breaks in\n"
  "the source where they occur in the contents of the\n"
  "constant.\n"
#+end_src

反斜杠和换行符的序列在 C 程序中的任何地方都被忽略，也包括在字符串常数中。 因此，你可以这样书写多行字符串常数：

#+begin_src c
  "This is another way to put newlines in a string constant\n\
  and break the line after them in the source code."
#+end_src

然而，推荐使用的方式是串联的方式。


你也可以用这样反常的方式书写字符串：

#+begin_src c
  "Fo\
  o!"
#+end_src

不过做个人吧，请使用正常方式书写：

#+begin_src c
  "Foo!"
#+end_src

需要非常小心的避免将一个字符串常数当参数传递给一个可能修改该字符串的函数。存储字符串常数的内存区域多半是只读的，修改这部分内存中的
内容会触发终止函数执行的 *SIGSEGV* 信号。(详见信号章节)。更糟糕的是如果那部分内存不是只读的时候那么函数修改该字符串常数之后将会导致
由编译器统一生成的其它字符串常量的内容被破坏。
