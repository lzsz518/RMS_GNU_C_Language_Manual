#+title: 数组

数组是一种存储一系列拥有相同类型的元素的数据对象。每一个数组中的元素都被给予一个数值索引。

我们在这个手册较早的部分曾经展示过存储数值的数组(详见4.2章)。然而数组可以存储任意数据类型的元素，
其中包括指针、结构体、联合体和其它数组。

如果了解其它编程语言那么你应该对于数组已经有了足够的了解，但是在C语言中数组有一些特性所以本章
我们就来阐述这些特性。

C语言数组中的元素都被存储在没有间隙的连续内存空间中，每一个元素都按照它的类型进行了对齐
(详见对齐章节)

* 访问数组元素

如果变量 *a* 是一个数组那么 *a[n]* 就是第n个元素。你可以使用这个表达式来访问元素中的值或给
元素赋值：

#+begin_src c
  x = a[5];
  a[6] = 1;
#+end_src

因为变量 *a* 是左值所以 *a[n]* 也是左值。

数组最小的索引是0而不是1，最大的数组索引是素组长度减1。

当代码使用一个超出范围的索引来访问数组时C语言并不会检测索引是否在索引的范围内，这将访问数组
之外的内存。

*警告* ： 在C语言中使用合法的索引时程序员的责任。

数组的索引在C语言中不是一个原生的操作： 它是以指针算术和解引用的形式来定义的。现在我们知道
了 *a[i]* 都做了什么，我们可以来了解 *a[i]* 如何工作。

在C语言中，x[y] 是 *(x+y) 的缩略语。因此 a[i] 的意思是 *(a+i)。详见指针于数组章节。

当一个较长的表达式中出现数组类型(例如a)那么它会被自动转换为指向索引为0的元素的指针。例如，*a*
在表达式中相当于 *&a[0]* 。因此，*(a+i) 相当于 *(&a[0]+i)。

现在我们可以分析一下这个表达式是如何给我们提供所需的数组元素的。通过一个指向*a*的0号索引的元素,
然后通过 *i* 计算它在数组中的偏移，最后对其进行解引用。

另一种等价的表达方式是（&a[0]）[i]。

* 声明数组

要声明数组，请在数组变量名之后书写 *[长度值]* 。这个结构在变量、函数参数、函数值类型（值不能是数组，但可以是指向数组的指针）、
结构体或联合体替代类型的声明中有效。

声明的前面部分指明了数组元素的类型；可以是除了 *void* 或 函数以外的任意类型。例如：

#+begin_src c
  double a[5];
#+end_src

上例声明 *a* 为一个长度为5的数组。

#+begin_src c
  struct foo bstruct[length];
#+end_src

声明 *bstruct* 为一个长度为length元素类型为struct foo的数组。 当数组作用域不是文件范围时，像这样的可变数组大小是允许的。

另一种可以于数组声明相结合的声明方式：

#+begin_src c
  struct foo *b[length];
#+end_src

将 *b* 声明为一个长度为 *lenght* 并且指向 *struct foo* 的指针数组。这里的长度不必是一个常量(详见变长数组)。

#+begin_src c
  double (*c)[5];
#+end_src

将 *c* 声明为一个长度为5的 *double* 型数组

#+begin_src c
  char *(*f (int))[5];
#+end_src

将 *f* 声明为一个接受 *int* 型参数并且返回长度为5的字符串(指向一系列字符的指针)的函数。

#+begin_src c
  double aa[5][10];
#+end_src

将 *aa* 声明为一个拥有5个元素并且每一个元素都是一个长度为10的 *double* 型数组的变量。这里展示的是C语言中声明多维数组的方法。
(详见多维数组)

以上所有声明都指定了数组的长度，其被用来给数组分配存储空间。

* 字符串

在C语言中字符串是指以数值0作为结束符的一系列类型为 *char* 的元素。

计算机程序经常需要使用字符串存储特定的、固定的内容。 *"Take me to you leader!"* 是一个典型的C语言 /字符串常量/  。
它的数据类型是 char * 。完整的字符串常量句法请参考字符串常量章节。

若需要一个空间存储非常量的字符串请声明一个 *char* 数组。请记得必须申请一个多余的 *char* 来存结束符。例如：

#+begin_src c
  char text = { 'H', 'e', 'l', 'l', 'o', 0 };
#+end_src

将 *'text'* 声明为拥有6个元素的数组--5个字符和结束符。不同的方式得到相同的结果：

#+begin_src c
  char text = "Hello";
#+end_src

它拷贝了包括了结束符在内的字符串常量的元素。

#+begin_src c
  char message[200];
#+end_src

声明一个足以存储199个ASCII字符外加一个结束符的数组。

当你存储一个字符串到 *message* 中请确认或证明其长度不超过数组声明的长度，例如：

#+begin_src c
  void
  set_message (char *text)
  {
    int i;
    for (i = 0; i < sizeof (message); i++)
      {
        message[i] = text[i];
        if (text[i] == 0)
          return;
      }
    fatal_error ("Message is too long for `message');
   }
#+end_src

使用库函数 *strncpy* 可以更轻松的完成这份工作，它将根据指定的长度连同结束符一起填充整个目标数组。因此如果目标
字符串最后一个字符不是结束符那么说明字符串的长度不合适。包括GNU C在内的很多系统的库函数都对 *strncpy* 进行过优化
以使其比显式循环(for-loop)运行的更快。

使用 *strncpy* 的代码类似：

#+begin_src c
  void
  set_message (char *text)
  {
    strncpy (message, text, sizeof (message));
    if (message[sizeof (message) - 1] != 0)
      fatal_error ("Message is too long for `message');
  }
#+end_src

更多字符串操作函数相关函数的信息请参考[[https://www.gnu.org/software/libc/manual/html_mono/libc.html#String-and-Array-Utilities][C语言手册]]

你可以通过动态分配空间来避免给你构建或操作的字符串设置固定的长度限制。

* 数组类型指定器

每一个C语言的类型都有类型指定器，你可以通过删除声明中的变量名和分号来实现（参见类型指定符）。数组类型的指定符遵循这一规则，
但它们可能会显得令人惊讶。

#+begin_src c
  type   int a[5];           指定器 int [5]
  type   double a[5][3];     指定器 double [5][3]
  type   struct foo *a[5];   指定器 struct foo *[5]
#+end_src

* 不完整数组类型

通常情况下数组相当于一个指向第0个元素的指针。当这是事实时数组的长度便不那么重要。长度仅仅在为数组分配空间时或使用 *sizeof*
和 *typeof* 时需要(详见自动类型)。因此C语言在某些方面允许：

 * 使用外部声明(extern)来说明一个变量的空间被在其它地方分配。它不需要为该变量分配空间，所以如果它是一个数组，你可以省略其长度。例如：

   #+begin_src c
     extern int foo[];
   #+end_src

 * 当函数的参数被声明为数组，那么当实参传递到函数时会以指向数组第0个元素的指针的形式传递。这个值并不说明这个数组到底有多长，
   没有必要声明它。例如：

   #+begin_src c
     int
     func (int foo[]) 
   #+end_src

这些声明是不完整数组类型的例子，这些类型没有被完全指定。不完整对于访问数组中的元素来说没有什么区别，但是对于其他一些事情来说却很重要。
例如，在一个不完整的类型上不允许使用sizeof。

对于多维数组，只有第一维可以被省略：

#+begin_src c
  extern struct chesspiece *funnyboard foo[][8];
#+end_src

换句话说，代码不需要说有多少行，但必须说明每行有多长。

* C语言数组的限制

由于数组在C语言中并不是"头等公民"(原生类型)所以有时候它显得很奇怪：在C语言中你是没有办法将数组作为一个单位来操作的。

C语言中的复合对象结构体和联合体是"头等公民"：C语言程序可以在赋值时拷贝结构体或联合体的值，或者将他们作为参数传递给函数，或者
将它们作为函数的返回值。你却不可以对数组进行以上操作，这是因为数组从来都不是一个可以被操作的数据类型。

C语言的表达式中可以含有数组类型，但是数组并不是作为一个值出现在其中。数组会被自动转换为指向0号索引的元素的指针。代码可以对指针
进行操作，并且对数组中的每一个元素进行遍历，但是对整个数组进行操作。

对于数组转换为指针的规则一共有三个例外情况，但是它们也都不会将数组视为一个整体进行操作。

第一，'&'应用于具有数组类型的表达式时可以将数组地址作为数组类型返回给你。然而，你不能以这种形式对整个数组进行操作--如果你
使用'*'将数组取回那么表达式将得到一个指向索引为0的元素的指针。

第二，操作符 *sizeof* ， *_Alignof* 和 *typeof* 并不会将数组转换为指针；它们会保持数组类型不变，但是他们不会对数组内
的数据进行任何操作--它们仅仅返回数组的信息。

第三，用来初始化数组的的字符串常量不会被转换为指针--相反对于这种情况声明式会拷贝字符串常量的内容到数组中。

你不能使用赋值操作来拷贝数组中的内容。你可以使用库函数 *memcpy* 或 *memmove* (详见[[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Copying-and-Concatenation][C语言参考手册]])
同样的，含有数组的结构体是不能被拷贝的。

数组变量被声明后它便称为一个左值，或者它是结构体或联合体的一部分时也是左值。当你从元素中构造一个数组时（详见构造数组值），该数组不是一个lvalue。

* 多维数组

严格的说，C语言中的所有数组都是一维的。然而你却可以创建数组的数组，这从某种意义上说相当于多维数组。例如：

#+begin_src c
  struct chesspiece *board[8][8];
#+end_src

上面声明了一个拥有8个元素每一个元素拥有8个指向 *struct chesspiece* 的指针的数组。这个数据类型可以呈现国际象棋的状态。要访问其中的一个元素
需要两个数组索引操作，每一个维度一个索引。例如，你可以写 *board[row][column]* ，假设 *row* 和 *column* 是在合理范围内的整型变量。

C语言是如何理解 *board[row][column]* 的？首先， *board* 将被自动转换为指向0号索引元素的指针。然后将 *row* 的值加到指针地址上，因此，
*board[row]* 的值是 *board* 的第8个指针。

然而，作为一个数组类型的表达式，它被自动转换为指向数组第一个元素的指针。第二个数组索引操作， *[column]*  被用来访问该数组中选定的元素。

正如下面显式的，指向指针的数组在C语言中是有用处的。你可以像这样声明一个指向棋盘中的行的变量：

#+begin_src c
  struct chesspiece *(*rowptr)[8];
#+end_src

这个指针指向一个拥有8个指针的数组 *struct chesspiece* 。你可以像下面这样对它赋值：

#+begin_src c
  rowptr = &board[5];
#+end_src

多维数组的每一个维度可以是不同的长度。在这里，我们声明一个名为 *statepop* 的数组，用来保存美国自1900年以来每年的各州人口。

#+begin_src c
  #define NSTATES 50
  {
    int nyears = current_year - 1900 + 1;
    int statepop[NSTATES][nyears];
    …
  }
#+end_src

变量statepop是一个由NSTATES子数组组成的数组，每个子数组以年份为索引（从1900年开始计算）。因此，为了获得某个州和年份的元素，
我们必须首先用表示该州的数字对其进行下标，然后用年份的索引进行下标。

#+begin_src c
  statepop[state][year - 1900]
#+end_src

多维数组内的子数组在内存中的空间是连续分配的，在每个子数组内，其元素在内存中的空间也是连续分配。处理数组中所有元素的最有效方法是在最内层循环中通过下标遍历数组
最后一个维度。这种持续访问连续的内存空间的目的是优化处理器缓存的使用。比如说：

#+begin_src c
  int total = 0;
  float average;

  for (int state = 0; state < NSTATES, ++state)
    {
      for (int year = 0; year < nyears; ++year)
        {
          total += statepop[state][year];
        }
    }

  average = total / nyears;
#+end_src


C语言中多维数组的内存布局不同于Fortran语言。在Fortran语言中，多维数组并不是数组的数组而是一个原生的多维数组类型，而且连续访问它的第一个维度是最有效
的内存访问方式。因此，C语言中50x114数组的内存布局与Fortran中114x50数组的内存布局一致。

* 创建数组的值

可以通过在大括号中写入数值并在大括号之前加上元素类型来创建数组。以这种方式创建数组时并不需要指定数组的长度，因为长度是大括号中元素的数量决定的。
创建方式如同：

#+begin_src c
  (elttype[]) { elements };
#+end_src

下面是一个例子，它构建了一个字符串指针的数组:

#+begin_src c
  (char *[]) { "x", "y", "z" };
#+end_src

这实际上等同于用同样的初始化器声明一个数组，例如:

#+begin_src c
  char *array[] = { "x", "y", "z" };
#+end_src

之后就可以使用该数组了。

如果所有的元素都是简单的常量表达式，或者是由常量表达式组成的，那么类型与元素值的文字组合可以被强制转换为一个指向第0个元素的指针，并用于初始化文件作用域
范围内的变量(详见文件作用域)，例如：

#+begin_src c
  char **foo = (char *[]) { "x", "y", "z" };
#+end_src

*foo* 的类型是 char**，这是一个指针类型而不是数组类型。该声明等同于定义然后使用一个数组类型的变量：

#+begin_src c
  char *nameless_array[] = { "x", "y", "z" };
  char **foo = &nameless_array[0];
#+end_src

* 变长数组

在GNU C中你可以像声明其它数组一样声明变长数组，它的长度不是一个常量表达式。存储空间在声明时被分配，当程序退出变量所在的代码块时存储空会被回收。例如：

#+begin_src c
  #include <stdio.h>  /* Defines FILE. */
  #include <string.h> /* Declares str. */

  FILE *
  concat_fopen (char *s1, char *s2, char *mode)
  {
    char str[strlen (s1) + strlen (s2) + 1];
    strcpy (str, s1);
    strcat (str, s2);
    return fopen (str, mode);
  }
#+end_src

(这使用了一些标准库函数；见GNU C库参考手册中 的 [[https://www.gnu.org/software/libc/manual/html_mono/libc.html#String-and-Array-Utilities][字符串和数组实用工具]]）。

当存储空间被分配时，数组的长度被计算一次，并且在数组的范围内被记住，以便在sizeof中使用。

警告：如果变长数组的大小可能非常大（超过100,000），或者在一个递归函数中，不要分配变长数组，因为这很可能导致堆栈溢出。改为动态分配数组。

跳出或脱离数组名称的范围，数组的存储空间就会被回收。不允许跳入作用域；这将得到一个错误信息。

你也可以使用可变长度的数组作为函数的参数：

#+begin_src c
  struct entry
  tester (int len, char data[len][len])
  {
    …
  }
#+end_src

像往常一样，一个用数组类型声明的函数参数实际上是一个指向已经存在的数组的指针。调用函数并不分配数组的存储空间，所以使用这种结构没有特别的堆栈溢出的危险。

要在传递数组之后再传递其长度，额可以在函数的参数列表中使用 /前置声明/ 。 例如：

#+begin_src c
  struct entry
  tester (int len; char data[len][len], int len)
  {
    …
  }
#+end_src

分号前的 *int len* 是一个前置声明的参数，它的作用是在解析数据声明时让人知道 *len* 这个变量。

你可以在参数列表中使用前置声明声明任意数量的参数。它们可以用逗号或分号隔开，但最后一个必须以分号结束，
分号后面是 "真实"参数声明。每个前置声明必须在参数名称和数据类型上与 "真实"声明相匹配。ISO C11不支持参数前置声明。
