#+title: 算术

* 算术运算

C语言中的算术运算符试图尽可能地类似于现实中的算术运算，但是不可能做到完全一样。计算机可以表示的数值都被
限定在一个范围内，并且对于非整数的数值在精度上也有一定的限制。尽管如此，在大多数情况下不必对使用'+'表示加法，
'-'表示减法，'*'表示乘法感到意外。

C语言的运算符都具有优先级--一种规定运算符在各种表达式中运算先后顺序的等级。优先级最高的运算符首先对相邻的
操作数产生作用；然后这些表达式将成为优先级较低的运算符的操作数。本章我们仅讨论本章所使用到的运算符的优先级，
对于全部运算符优先级的讨论请见二元运算符语法章节。

算数运算符在对其操作数产生作用之前总是先提升他们的域。这意味着总是转换表示较小范围的数据类型到较大范围的
数据类型。详情请见操作数提升章节。如果只是学习C语言那么可以暂时忽略这部分内容。


如果操作符有两个操作数那么总是将他们转换为 /公共类型/ 。例如：一个int 和一个 double变量在一起那么他们
的 /公共类型/ 就是 double(这是因为double可以表示int可以容纳的所有数值，但反之则不然）。详情请见公共类型章节。

** 基础运算

C语言中的基础算数通常是两个操作数的代数：加法（'+'），减法（'-'），乘法（'*'）和除法（'/'）。一元运算符'-'用于更改数字的符号。
'+'也可以作为一元操作符，但是它不会对操作数产生任何影响。

'/'是除法操作符，但是整数除法可能不会得到你所期望的值。当除法是一个分数时其值是整数但是不等于数学上的商。当有必要时使用'%'来取得
除法的余数。详情请见除法和余数章节。浮点除法产生的数值比较接近数学上的商数。

这些运算符使用现实中代数上的先乘除后加减的优先级规则(详情请见二元操作语法)，但是你可以使用小括号来指定他们的运算顺序。他们是向
左结合的，因此：

#+begin_src c
  -a + b - c + d * e / f
#+end_src

等价于

#+begin_src c
  (((-a) + b) - c) + ((d * e) / f)
#+end_src

** 整数运算

C语言的运算都可以使用两种类型的整数： 有符号型和无符号型。操作数的类型将决定使用那种类型。

C语言中的每个整数数据类型都是有符号或无符号的。有符号类型可以容纳包括0在内何其左右数量近乎相等的正负整数(可以容纳的正整数总是比负整数少一个)。
无符号数可以容纳大于等于0的整数。

多数整数变量被声明为 /int/ 型， /int/ 型可以容纳的数值范围从 -2,147,483,648 到 2,147,483,647, /unsigned int/ 型可以容纳数值范围从0 到 4,294.967,295。
(这里假设 /int/ 型变量为32 bits 位宽，这对于GNU C 编译器和桌面型计算机总是成立但是对于嵌入式系统却不一定。) 关于整数类型详情请见整数类型章节。

如果给予算术运算符两个有符号操作数那么结果为有符号数，如果给予两个无符号数那么结果为无符号数。

如果一个操作数是无符号但是另一个是有符号的那么运算符会将他们都当作无符号操作数对待。更通用的情况是操作数的公共类型将决定运算是否有符号。

使用'%d'打印数值较大的无符号数可能会得到令人意外的结果。尽管按照上面所说的规则计算时是使用的无符号数但是打印的结果可能会出现负号！

对于上述现象的解释是加法、减法和乘法对于操作数产生的位模式对于有符号数和无符号数都是一样的。区别只在于结果的数据类型，它影响到结果位模式的解释，
以及算术运算是否会溢出（见下一节）。

但是'%d'并不知道参数的数据类型，它只知道参数的位模式，并且将其按照有符号整数对待。如果需要打印无符号数那么需要使用'%u'来代替'%d'。
详情请见[[https://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output][The GNU C Library]]

C语言中的算数运算从来不直接在位宽小于 /int/ 的整数类型上进行(详情请见窄整数)。

** 整数溢出


当一个算术运算的数学值不符合所使用的数据类型的范围时，这被称为溢出。当它发生在整数运算中时，就是 /整数溢出/ 。

整数溢出只发生在算术操作中。根据定义类型转换操作不会导致溢出，即使是当结果不能适应其新类型时也不会。见整数转换。

有符号数使用补码形式表示，大多数负整数都找不到与其对应的正整数，因此应用'-'一元运算符在有符号整数上时有可能导致溢出。

*** 无符号数溢出

C语言忽略无符号数运算的溢出；真实的结果将是产生溢出的数值的2^n模，其中n是数据类型的比特位数。我们将这种行为称为"截断"，真是结果将取产生溢出的
数值的最低n位。

一个负数结果当取2^n的模后会得到一个正数，例如：
#+begin_src c
  unsigned int x = 1;
  unsigned int y;

  y = -x;
#+end_src

以上代码会导致溢出，因为-1不能被存储在无符号类型标量中。实际的结果是-1对2^n求模,结果是2^n-1。这时无符号整形变量可以表示的最大的数值，对于32位
usigned int 型数据那个数字将是4,294,967,295。

将上述数字和它自己相加：

#+begin_src c
  unsigned int z;

  z = y + y;
#+end_src

应该得到8,489,934,590；然而，这又大到32位整型变量无法容纳，所以溢出将该值截断为4,294,967,294。如果这是一个有符号的整数，它将意味着-2，这（并非巧合）等于-1+-1。

















