#+title: 函数定义

我们已经在很多例子中呈现了函数定义，如果你已经阅读到了这里那么你已经基本理解了函数的概念。
尽管如此，使用一整章的篇幅来汇集有关函数的信息仍然使必要的。

* 函数定义

我们已经在很多例子中呈现了函数定义。函数定义的规则总体看开如同下面的例子：

#+begin_src c
    returntype
    functionname (parm_declarations…)
    {
      body
    }
#+end_src

大括号之前的部分被称为函数头。

如果函数没有返回值则使用 /void/ 作为 /returntype/ 。

** 函数参数变量


函数参数变量是在函数内部使用的局部变量（请参阅局部变量），用于存储在调用函数时作为参数传递的值。通常我们简称为“函数参数”或者“参数”，不特别提到它是一个变量的事实。

我们在函数定义的开头，在参数列表中声明这些变量。例如，

#+begin_src c
    fib (int n)
#+end_src

以上函数的参数列表中只有一个参数类型为int的参数--n。

函数参数声明与普通变量声明在几个方面有所不同：

+ 在函数定义的头部，逗号分隔参数声明，每个参数都需要完整的声明，包括类型。例如，如果一个函数 foo 有两个 int 参数，可以这样写：

  #+begin_src c
    foo (int a, int b)
  #+end_src

  你不能在这两个声明之间共享相同的 int 声明：

  #+begin_src c
    foo (int a, b) /* Invalid! */
  #+end_src

+ 函数参数变量在函数调用时被初始化为传递的值，因此它的声明不能指定初始值。

+ 在函数参数声明中写入数组类型会使其声明为指针。指定的数组大小没有任何影响，通常我们省略大小。因此，

  #+begin_src c
    foo (int a[5])
    foo (int a[])
    foo (int *a )
  #+end_src

  是等价的。

+ 参数变量的作用域是整个函数体，尽管它们写在函数头部，而函数头部实际上是在函数体的外部。

  如果一个函数没有参数，那么在其定义中，参数列表为空是最自然的方式。但是，在C语言中，由于历史原因，这样做有着特殊的含义：
  “函数调用时不检查其是否拥有正确的参数个数”。因此，

  #+begin_src c
    int
    foo ()
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  在将 x 作为参数传递给 foo 时，不会报告编译错误。相比之下，

  #+begin_src c
    int
    foo (void)
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  将会报告一个错误，因为 foo 不应该接收任何参数。

** 前置函数声明
在源代码中，函数定义的顺序并不重要，除了每个函数在被使用之前需要被定义或声明之外。

函数的定义同时也为其所在作用域的其余部分声明了该函数的名称。但是如果你想在函数定义之前调用该函数怎么办？为了允许这样做，可以在第一次调用之前编写一个兼容的同名函数声明。这种预示后续定义的声明被称为前向声明（forward declaration）。函数声明可以在顶层或块内，并且在其所在作用域的末尾之前都适用。

** 静态函数
在函数定义中使用关键字 *static* 可以将函数名的可见性限制在当前编译模块中。（这与变量声明中的 static 的作用相同；请参阅文件范围变量。）例如，如果一个编译模块包含以下代码：

#+begin_src c
    static int
    foo (void)
    {
    …
    }
#+end_src

那么该编译模块的代码可以在函数定义之后的任何位置调用 foo，但其他编译模块则无法引用它。

为了在函数定义之前调用 foo，它需要一个前置声明，并且应该使用static，因为函数定义中使用了static。
对于这个函数，前向声明的形式如下：

#+begin_src c
    static int foo (void);
#+end_src

通常明智的做法是在不会从同一编译模块外部调用的函数定义上使用
static。这样可以确保调用不会在其他模块中添加。如果程序员决定更改函数的调用约定，或者理解其使用的所有后果，
他们只需检查同一编译模块中的调用即可。

** 数组参数
在C中，数组不是原生对象：它们无法直接复制。因此，它们不能像其他值一样作为参数传递。请参考C数组的限制。相反，数组参数以一种特殊的方式
工作。

*** 数组参数等于指针

在C中，将函数参数变量声明为数组实际上给它赋予了指针类型。C之所以这样做，如果在函数调用中用作参数使用数组类型的表达式会被自动转换为
指针（指向数组的第一个元素）。如果您将相应的参数声明为“数组”，它将正确接收实际传递给函数的指针值。

这与C语言在访问数组元素时不检查数组边界有关（请参阅访问数组元素）。

例如在下面的函数中：

#+begin_src c
    void
    clobber4 (int array[20])
    {
      array[4] = 0;
    }
#+end_src

参数数组的实际类型是int *；指定的长度20对程序没有影响。您可以省略长度并写成以下形式：

#+begin_src c
    void
    clobber4 (int array[])
    {
    array[4] = 0;
    }
#+end_src

或者可以明确地将参数声明为指针形式：

#+begin_src c
    void
    clobber4 (int *array)
    {
    array[4] = 0;
    }
#+end_src

以上函数定义是等价的。

*** 解析数组参数

函数调用时指针的值被传递给函数，就像C语言中的所有参数值一样。然而，结果是矛盾的，因为数组本身是按引用传递的：
它的内容被视为共享内存——在调用者和被调用函数之间共享。当clobber4给数组的第4个元素赋值时，效果就是修改了调用中指定的数组的第4个元素。

#+begin_src c
#include <stddef.h>  /* Defines NULL. */
#include <stdlib.h>  /* Declares malloc, */
                     /* Defines EXIT_SUCCESS. */

int
main (void)
{
  int data[] = {1, 2, 3, 4, 5, 6};
  int i;

  /* Show the initial value of element 4. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  clobber4 (data);

  /* Show that element 4 has been changed. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  return EXIT_SUCCESS;
}
#+end_src

上面的程序将会显示'0'因为调用clobber4之后data[4]的值被改写为0。

数组data有6个元素，但将其传递给参数类型写为int[20]的函数不会报错，因为它实际上代表的是int*。真正的参数指针并没有携带指向的数组长
度的指示。它也不需要指向数组的开头。例如，

#+begin_src c
clobber4 (data+1);
#+end_src

传递的是一个从data的第1个元素开始的“数组”，其效果是将data[5]清零，而不是data[4]。

如果所有对该函数的调用都将提供一个特定大小的数组，您可以将数组的大小指定为静态大小：

#+begin_src c
void
clobber4 (int array[static 20])
…
#+end_src

将对编译器作出始终以一个包含20个元素的数组作为函数调用时的参数的承诺，这有助于编译器可以优化代码。如果代码违反了这个承诺，并且以一个较短的数组调用该函数，可能会发生不可预测的情况。

*** 在数组参数上使用类型限定符

您可以对数组参数中使用类型限定符const、restrict和volatile，例如：

#+begin_src c
void
clobber4 (volatile int array[20])
…
#+end_src

表示array等同于一个指向volatile int的指针。或者：

#+begin_src c
void
clobber4 (int array[const 20])
…
#+end_src


将数组参数等同于一个指向int的常量指针。如果我们希望clobber4函数成功执行，将以下参数声明是没有意义的：

#+begin_src c
void
clobber4 (const int array[20])
…
#+end_src

这样的写法会告诉编译器参数应该指向一个包含常量int值的数组，那么我们将无法在函数中对array进行赋值。

在具有多个数组参数的函数中，您可以使用restrict关键字告诉编译器每个传入的数组参数都是不同的：

#+begin_src c
void
foo (int array1[restrict 10], int array2[restrict 10])
…
#+end_src

使用restrict关键字向编译器承诺函数调用者不会将同一个数组传递给多个restrict数组参数。了解这一点使得编译器能够进行更好的代码优化。这与使用restrict指针具有相同的效果（参见restrict指针），但在阅读代码时明确表示期望一个特定大小的数组。

** 接受结构体参数的函数

在GNUC中，结构体是原生对象，因此可以以自然的方式将它们用作函数参数和参数。下面是一个名为swapfoo的函数，它接受一个具有两个字段的结构体foo作为参数，并返回一个具有相同类型但字段交换的结构体。

#+begin_src c
struct foo { int a, b; };

struct foo x;

struct foo
swapfoo (struct foo inval)
{
  struct foo outval;
  outval.a = inval.b;
  outval.b = inval.a;
  return outval;
}
#+end_src

这种更简单的swapfoo定义避免了使用一个局部变量来保存即将返回的结果，而是使用结构体构造函数（参见结构体构造函数）来实现，如下所示：

#+begin_src c
struct foo
swapfoo (struct foo inval)
{
  return (struct foo) { inval.b, inval.a };
}
#+end_src

在函数的参数列表中定义结构体类型是有效的，就像下面的例子一样：

#+begin_src c
int
frob_bar (struct bar { int a, b; } inval)
{
  body
}
#+end_src

函数体body可以访问inval的字段，因为整个函数体都定义了结构体类型struct bar。然而，除非通过一些不正规的手段，否则无法创建一个struct  bar参数来传递给frob_bar函数。因此，在实际中，在参数列表中定义结构体类型是没有用的。

* 函数声明

要调用一个函数或者将其名称作为指针必须在其之前对函数名进行 /声明/ 。函数的定义同时也为其所在作用域的其余部分声明了该函数的名称，但是如果你想在函数定义之前调用该函或者从其他编译模块调用它那么必须先进行单独的函数声明。

函数声明看起来像函数定义的开始。它以返回值类型（如果没有，则为void）和函数名开头，后面跟着括号中的参数声明（尽管有时可以省略这些参数声明）。但相似之处就到此为止了：声明部分不包含函数体，而是使用分号结束。

指定参数类型的声明称为函数原型（function prototype）。您可以包含参数名称，也可以省略它们。如果在声明中包含参数名称，它们不会起到任何作用，但可以作为文档说明。

这种形式的原型指定了固定的参数类型：

#+begin_src c
rettype function (argtypes…);
#+end_src

这种形式表示函数不接受任何参数：

#+begin_src c
rettype function (void);
#+end_src

这种形式为某些参数声明了类型，并允许使用未指定类型的额外参数：

#+begin_src c
rettype function (argtypes…, ...);
#+end_src

对于长度可变的数组参数，您可以在数组通常应该放置“长度”的位置上使用 '*' 来编写它的声明；例如，以下声明是等价的。

#+begin_src c
double maximum (int n, int m, double a[n][m]);
double maximum (int n, int m, double a[*][*]);
double maximum (int n, int m, double a[ ][*]);
double maximum (int n, int m, double a[ ][m]);
#+end_src

旧式的声明形式，不是一个原型，它不指定参数的类型或数量：

*警告：* 传递给没有原型声明的函数的参数将使用默认参数提升进行转换（参见参数提升）。同样，对于类型未指定的额外参数也是如此

函数声明通常写在源文件的顶层，但您也可以将它们放在代码块内部。这样，函数名在包含范围的其余部分都是可见的。例如：

#+begin_src c
void
foo (char *file_name)
{
  void save_file (char *);
  save_file (file_name);
}
#+end_src

如果代码的其他部分尝试调用save_file函数，那么这个声明在那里将不会生效。因此，该函数将获得隐式声明，形式为extern int save_file ();。这与此处的显式声明冲突，导致差异产生警告。

传统上，C的语法允许在函数声明中省略数据类型，如果该声明指定了存储类或限定符。此时，类型默认为int。例如：

#+begin_src c
static foo (double x);
#+end_src

默认将返回类型设定为int。这是不好的实践；如果您看到这种情况，请进行修正。

调用一个未声明的函数将在最内层的包含范围中创建一个隐式声明，相当于以下声明形式：

#+begin_src c
extern int function ();
#+end_src

这个声明表示该函数返回int类型，但未指定其参数类型。如果这不准确地描述了函数本身，那么程序需要一个带有参数类型的显式声明才能正确地调用它。

隐式声明已经被弃用，因此创建隐式声明的函数调用会引发警告。

* 函数调用

在程序启动时，会自动调用名为main的函数（请参阅主函数）。除此之外，函数除非被调用，否则不会执行任何操作。
函数被调用发生在指定该函数的函数调用表达式执行期间。

函数调用表达式看起来就像：

#+begin_src
function (arguments…)
#+end_src

大多数情况下，/function/ 是一个函数名。然而，它也可以是具有函数指针值的表达式；
这样，程序可以在运行时确定要调用哪个函数。

/arguments/ 是由逗号分隔的一系列表达式。每个表达式指定一个要传递给函数的参数。

函数调用中的参数列表看起来就像使用逗号运算符（请参阅逗号运算符）一样，但当他们出现在括号之中便具有了不同的含义。

这是一个函数调用的示例，摘自一个接近本书开头的例子（请参阅完整程序）。

#+begin_src c
printf ("Fibonacci series item %d is %d\n",
        19, fib (19));
#+end_src

对于printf函数，给定的三个参数是一个常量字符串、整数19以及fib(19)返回的整数。

* 函数调用语义

函数调用的含义是计算指定的参数表达式，根据函数的声明将它们的值进行转换，然后运行函数，并将转换后的值的副本传递给函数。（这种参数传递的方法被称为按值调用。）当函数执行完成时，它返回的值将成为函数调用表达式的值。


按值调用意味着对函数参数变量的赋值对调用者没有直接影响。例如，

#+begin_src c
#include <stdlib.h>  /* Defines EXIT_SUCCESS. */
#include <stdio.h>   /* Declares printf. */

void
subroutine (int x)
{
  x = 5;
}

void
main (void)
{
  int y = 20;
  subroutine (y);
  printf ("y is %d\n", y);
  return EXIT_SUCCESS;
}
#+end_src

打印的结果是 "y is 20"。调用子程序会将 x 初始化为 y 的值，但这不会建立两个变量之间的任何其他关系。因此，在子程序内部对 x 的赋值只会改变该变量 x。

如果函数的声明指定了参数的类型，函数调用将尽可能将参数表达式转换为该类型。如果转换不可能，则会产生错误。

如果函数的声明没有指定该参数的类型，那么将应用默认的参数提升规则。参见参数提升（Argument Promotions）。

* 函数指针

函数名指的是一个固定的函数。有时候，在运行时再确定该调用哪个函数非常有用；为了实现这一点，可以使用指向所选函数的函数指针值（请参阅指针）。  

可以使用函数指针这种数据类型声明其他数据，包括数组元素、结构体字段和联合体的成员。它们还可以用于函数参数和返回值。
这些类型有一个特点，就是它们永远不会自动转换为void *，反之亦然。然而，您可以通过强制类型转换来进行这种转换。

** 声明函数指针

函数指针变量（或结构字段）的声明几乎与函数声明相似，只是在变量名之前多了一个额外的"*"。正确的嵌套需要在它们周围加上一对括号。
例如，int (a) (); 的意思是："声明a为一个指针，使得a是一个返回int的函数。"

对比以下三个声明：

#+begin_src c
/* 声明一个返回 char * 的函数.  */
char *a (char *);
/* 声明一个指向返回 char 的函数的函数指针.  */
char (*a) (char *);
/* 声明一个指向返回 char * 的函数的函数指针.  */
char *(*a) (char *);
#+end_src

函数指针所指向的函数的参数类型与函数声明中的参数类型相同。您可以编写一个原型，指定所有的参数类型：

#+begin_src c
rettype (*function) (arguments…);
#+end_src


或者可以编写一个指定了一部分参数类型并将其余部分保留为未指定的原型：

#+begin_src c
rettype (*function) (arguments…, ...);
#+end_src

或者声明为无参数形式：

#+begin_src c
rettype (*function) (void);
#+end_src

您还可以编写一个非原型声明，其中不指定参数类型：

#+begin_src c
rettype (*function) ();
#+end_src

例如，这是一个变量声明，它应该指向某个对两个双精度浮点数执行算术操作的函数：

#+begin_src c
double (*binary_op) (double, double);
#+end_src

结构体字段、联合体成员和数组元素可以是函数指针，参数变量也可以是函数指针。函数指针声明结构还可以与其他允许在声明中使用的运算符结合使用。例如，

声明foo为一个指向返回类型为int **的函数的指针，并且：
#+begin_src c
int **(*foo)();
#+end_src

声明foo为一个包含30个指向返回类型为int **的函数指针的数组，可以这样写：

#+begin_src c
int **(*foo[30])();
#+end_src

声明foo为一个指向指向返回类型为int **的函数的指针的指针，可以这样写

#+begin_src c
int **(**foo)();
#+end_src

** 函数指针赋值

假设我们已经像上一节中声明了变量binary_op，给它赋值需要一个合适的函数。因此，让我们定义一个适合让该变量指向的函数。下面是一个例子：

#+begin_src c
double
double_add (double a, double b)
{
  return a+b;
}
#+end_src

现在我们可以给它赋一个值：

#+begin_src c
binary_op = double_add;
#+end_src

函数指针的目标类型必须与函数的类型向上兼容（请参阅兼容类型）。

在double_add前面不需要加上'&'。使用函数名（例如double_add）作为表达式会自动将其转换为函数的地址，
并具有适当的函数指针类型。然而，如果您认为使用'&'更清晰，也可以使用它：

#+begin_src c
binary_op = &double_add;
#+end_src

** 通过数指针调用函数

要调用由函数指针指定的函数，只需在函数调用中写入函数指针的值。例如，以下是对binary_op指向的函数进行调用的示例：

#+begin_src c
binary_op (x, 5)
#+end_src

由于binary_op的数据类型明确指定了参数的类型为double，因此调用会将x和5转换为double类型。

函数调用在概念上对指针binary_op进行解引用，以获取它所指向的函数，并调用该函数。如果您愿意，可以通过写入*运算符来明确表示解引用操作：

#+begin_src c
(*binary_op) (x, 5)
#+end_src


'*'提醒代码阅读者binary_op是一个函数指针，而不是特定函数的名称。




