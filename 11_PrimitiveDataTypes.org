#+title: 基本数据类型

本章将讲述C语言的所有基本数据类型，即所有不是从其他数据类型构建起来的类型。这其中就包括
之前章节涵盖过的 *int* 和 *double* 类型。

这些类型都是由字节组成的。

** 整数类型(Integer)

本节讲述说有整数类型和它们的基本特性。若要从比特级更多的了解整数数据的呈现和算术请参考
深入整数章节。

*** 整数基础

C语言中的整形数据可以是有符号或无符号的。无符号类型只能呈现整数和零。有符号类型可以呈现
正数和负数，它们的范围是以零为中心正负数绝对值几乎相同的一个区间。

除了整数的符号以外，整数数据类型的大小各不相同：它们一共有多少个字节。字节数决定该类型
可以存储多大的整数值。

下面的列表是有符号整数数据类型和它们所拥有的字节数。它们都有与其对应的无符号数。
详情请见有符号和无符号类型章节。

*signed char*

    1个字节(8比特位)。这种整数类型主要用于代表字符的整数，作为数组或其他数据结构的一部分。

*short*
*short int*

    2个字节(16比特位)。

*int*

    4个字节(32比特位)。

*long*
*long int*

    4字节(32比特位)或8字节(64比特位)，根据不同的平台而定。通常，在32位计算机上是32位，
    在64位计算机上是64位，但也有例外。

*long long*
*long long int*

    8字节(64比特位)。GNU C在1980年代开始支持此类型，国际标准化组织(ISO)在1999年的
    C99标准中开始支持此类型。

当你使用long或short时，你可以省略int。这是无害和惯用的。

*** 有符号与无符号类型
无符号类型只能呈现整数和零。有符号类型可以呈现正数和负数，它们的范围是以零为中心正负数
绝对值几乎相同的一个区间。比如说， *unsigned char* 可以容纳的数值从0到255(在大多数计算机中)，
而 *signed char* 可以容纳的数值从-128到127。每个类型都可以容纳256个不同的数值，因为它们
都是8比特位宽。

在类型关键字之前使用 *signed* 或 *unsigned* 可以指定类型是有符号或无符号的。然而，除了
*char* 之外的整数类型都是默认有符号的，对他们使用 *signed* 是没有意义的。

普通 *char* 可以是有符号或无符号的；这取决于编译器、使用的机器和其操作系统。

在许多程序中，char是否有符号并无区别。当符号确实重要时，不要让编译器决定，请明确使用
*signed char* 或 *unsigned char* 。

*** 窄整数

比 *int* 拥有更少字节的的类型(窄整形)很少用于普通变量--我们使用 *int* 替代它们，因为C语言会将
任何算术运算中较 *int* 拥有更少字节的类型转换成 *int* 类型。比如说从字面上来看没有理由
将一个局部变量声明为 *char* 类型。

特别是即使数值是一个 *char* 类型也应该该将其声明成 *int* 类型而不是 *char* ! 使用窄整形将会
迫使编译器为了类型转换二阶段数值，这时一种浪费。此外，一些函数要么返回一个字符值，要么返回-1表示
"无字符"。使用int可以保持这些值的区别。

窄的整数类型作为其他对象的一部分是很有用的，如数组和结构。比较一下这些数组声明，
它们在32位处理器上的大小显示出来了：

#+begin_src c
  signed char ac[1000];   /* 1000 bytes */
  short as[1000];         /* 2000 bytes */
  int ai[1000];           /* 4000 bytes */
  long long all[1000];    /* 8000 bytes */
#+end_src

此外，字符串必须由字符组成，因为这也是所有标准库中的字符串函数所期望的。因此，数组ac可以作为字符串使用，
但其他的就不行了。

*** 整数类型之间的转换

在许多情况下，C语言在整数类型之间进行隐式转换。在任何算术运算中 *char* 和 *short* 类型都会被转换成
*int* 类型。对一个变量进行赋值(或者其他左值)会将值转换成变量的类型。

你也可以使用类型转换运算符转换一个整数类型到另外一个指定的类型。详见显式类型转换。

转换到较宽整形的操作非常直接：数值不会被改变。唯一例外是转换一个负值(一个明显的有符号类型)到较宽的
类型。在这种情况下转换的结果是将符号位直接作为数值的最高位的正整数。(详见深入整数)。

转换到较窄的整数类型也被成为 /截断/ ，这涉及到丢弃被转换数值的一些比特位。这不被认为是溢出因为有效
比特位的丢失是阶段的正常后果。对于拥有同样位宽的有符号和无符号类型之间的转换同样不被视为溢出。

更多关于赋值类型缓缓的信息在赋值类型转换章节，关于算术运算类型转换的信息在参数类型提升章节。

*** 布尔类型

无符号整型 *bool* 用来保存真值：0和1。转换所有非零值到 *bool* 都被转换为1。例如：

#+begin_src c
  bool a = 0;
  bool b = 1;
  bool c = 4; /* Stores the value 1 in c.  */
#+end_src

与 *int* 不同， *bool* 不是一个关键字。它被定义在stdbool.h头文件中。

*** 整数多样性

C语言的整数类型们都有标准的 /名字/ ，但是他们的 /意义/ 却取决于不同的平台：不同的计算机，
不同的操作系统,不同的编译器，甚至不同的编译器选项。

普通的 *char* 也许是有符号的或无符号的；这也取决于不同的平台。甚至GUN C 也没有一个通用的规则。

理论上所有的整数类型的字节数都是可变的。 在C语言中 *cahr* 总被认为是一个"字节"，但是一个字节
并不一定必须只能拥有8个比特位；有些平台上可能多于8比特。ISO C标准仅规定平台上的整数类型必能比
基础整数章节中规定的比特数更少，并且 *short* 最少需要拥有16比特。

GNU C在未来将会支持整型数为64比特位长度的平台。然而实际上，在现今的计算机之间区别不大，具体可以
参考前面给出的表格(基础整数章节)

为了完全确定整数类型的比特位数，使用类型 *int16_t* ， *int32_t* 和 *int64_t* 。对于无符号类型
只需要在每个关键字前面增加 'u'即可。它们都被定义在 *stdint.h* 头文件中。

GNU C编译器在一些嵌入式设备上编译程序时将 *int* 类型定义为两字节。在一些平台上 *int* 只有一字节，
所以它是 *short int* 但是这里的"字节"可能包含16比特或32比特。这些嵌入式设备的处理器不支持普通操作系统
(它们有自己专用的操作系统)，并且大多数C语言程序也不会试图支持它们。



