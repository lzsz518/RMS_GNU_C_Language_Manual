#+title: 函数定义

我们已经在很多例子中呈现了函数定义，如果你已经阅读到了这里那么你已经基本理解了函数的概念。
尽管如此，使用一整章的篇幅来汇集有关函数的信息仍然使必要的。

* 函数定义

我们已经在很多例子中呈现了函数定义。函数定义的规则总体看开如同下面的例子：

#+begin_src c
    returntype
    functionname (parm_declarations…)
    {
      body
    }
#+end_src

大括号之前的部分被称为函数头。

如果函数没有返回值则使用 /void/ 作为 /returntype/ 。

** 函数参数变量


函数参数变量是在函数内部使用的局部变量（请参阅局部变量），用于存储在调用函数时作为参数传递的值。通常我们简称为“函数参数”或者“参数”，不特别提到它是一个变量的事实。

我们在函数定义的开头，在参数列表中声明这些变量。例如，

#+begin_src c
    fib (int n)
#+end_src

以上函数的参数列表中只有一个参数类型为int的参数--n。

函数参数声明与普通变量声明在几个方面有所不同：

+ 在函数定义的头部，逗号分隔参数声明，每个参数都需要完整的声明，包括类型。例如，如果一个函数 foo 有两个 int 参数，可以这样写：

  #+begin_src c
    foo (int a, int b)
  #+end_src

  你不能在这两个声明之间共享相同的 int 声明：

  #+begin_src c
    foo (int a, b) /* Invalid! */
  #+end_src

+ 函数参数变量在函数调用时被初始化为传递的值，因此它的声明不能指定初始值。

+ 在函数参数声明中写入数组类型会使其声明为指针。指定的数组大小没有任何影响，通常我们省略大小。因此，

  #+begin_src c
    foo (int a[5])
    foo (int a[])
    foo (int *a )
  #+end_src

  是等价的。

+ 参数变量的作用域是整个函数体，尽管它们写在函数头部，而函数头部实际上是在函数体的外部。

  如果一个函数没有参数，那么在其定义中，参数列表为空是最自然的方式。但是，在C语言中，由于历史原因，这样做有着特殊的含义：
  “函数调用时不检查其是否拥有正确的参数个数”。因此，

  #+begin_src c
    int
    foo ()
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  在将 x 作为参数传递给 foo 时，不会报告编译错误。相比之下，

  #+begin_src c
    int
    foo (void)
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  将会报告一个错误，因为 foo 不应该接收任何参数。

** 前置函数声明
在源代码中，函数定义的顺序并不重要，除了每个函数在被使用之前需要被定义或声明之外。

函数的定义同时也为其所在作用域的其余部分声明了该函数的名称。但是如果你想在函数定义之前调用该函数怎么办？为了允许这样做，可以在第一次调用之前编写一个兼容的同名函数声明。这种预示后续定义的声明被称为前向声明（forward declaration）。函数声明可以在顶层或块内，并且在其所在作用域的末尾之前都适用。

** 静态函数
在函数定义中使用关键字 *static* 可以将函数名的可见性限制在当前编译模块中。（这与变量声明中的 static 的作用相同；请参阅文件范围变量。）例如，如果一个编译模块包含以下代码：

#+begin_src c
    static int
    foo (void)
    {
    …
    }
#+end_src

那么该编译模块的代码可以在函数定义之后的任何位置调用 foo，但其他编译模块则无法引用它。

为了在函数定义之前调用 foo，它需要一个前置声明，并且应该使用static，因为函数定义中使用了static。
对于这个函数，前向声明的形式如下：

#+begin_src c
    static int foo (void);
#+end_src

通常明智的做法是在不会从同一编译模块外部调用的函数定义上使用
static。这样可以确保调用不会在其他模块中添加。如果程序员决定更改函数的调用约定，或者理解其使用的所有后果，
他们只需检查同一编译模块中的调用即可。

** 数组参数
在C中，数组不是原生对象：它们无法直接复制。因此，它们不能像其他值一样作为参数传递。请参考C数组的限制。相反，数组参数以一种特殊的方式
工作。

*** 数组参数等于指针

在C中，将函数参数变量声明为数组实际上给它赋予了指针类型。C之所以这样做，如果在函数调用中用作参数使用数组类型的表达式会被自动转换为
指针（指向数组的第一个元素）。如果您将相应的参数声明为“数组”，它将正确接收实际传递给函数的指针值。

这与C语言在访问数组元素时不检查数组边界有关（请参阅访问数组元素）。

例如在下面的函数中：

#+begin_src c
    void
    clobber4 (int array[20])
    {
      array[4] = 0;
    }
#+end_src

参数数组的实际类型是int *；指定的长度20对程序没有影响。您可以省略长度并写成以下形式：

#+begin_src c
    void
    clobber4 (int array[])
    {
    array[4] = 0;
    }
#+end_src

或者可以明确地将参数声明为指针形式：

#+begin_src c
    void
    clobber4 (int *array)
    {
    array[4] = 0;
    }
#+end_src

以上函数定义是等价的。
