#+title: 预处理
#+OPTIONS: ^:{}

当GCC编译器对原文件进行编译时首先会进行文本替换与文件包含，这部分操作被称为预处理。

* 概述

GNU C在编译的第一阶段对C程序的每一行进行预处理。只有当一行包含预处理指令或使用宏时，
预处理器才对其进行处理，其他所有行都会在预处理之后保持不变。

以下是预处理所执行的一些任务。本章的其余部分将详细介绍这些内容。

 * 头文件的包含：头文件通常包含声明和宏定义，可以被替换到程序中。

 * 宏展开：您可以定义宏，宏是对任意C代码片段的缩写。预处理将宏替换为其定义。有些宏是自动预定义的。

 * 条件编译：您可以根据不同条件包含或排除程序的部分代码。

 * 行控制：如果您使用程序将源文件组合或重新排列成中间文件，然后再进行编译，您可以使用行控制来通知编译器每行源代码最初来自哪个文件。

 * 编译控制：#pragma和_Pragma可以调用一些特殊的编译器功能来处理特定的结构。

 * 诊断：您可以在编译时检测问题并输出错误或警告信息。

除了预定义宏的展开之外，所有这些操作仅在您使用预处理指令来请求它们时才会发生。

* 指令

预处理指令是程序中以‘#’开头的行。在‘#’之前和之后允许有空白字符。‘#’后面紧跟一个标识符，表示指令名称，
它指定要执行的操作。以下是一些示例：

#+begin_src c
#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
#+end_src

通常我们将指令写为#name，其中name是指令名称。例如，#define 表示定义宏的指令。

以‘#’开头的指令不能来自宏展开。另外，指令名称不会进行宏展开。因此，如果将foo定义为一个展开为define的宏，
那么#foo就不是一个有效的预处理指令。

C语言拥有固定数量的合法预处理指令，程序员不能自己定义新的预处理指令。

一些指令需要参数；这些参数位于指令行的其余部分，并且必须与指令名称用空白分隔开。
例如，#define 后面必须跟着宏的名称和宏的预期展开内容。

预处理指令不能跨越多行。但是，可以使用反斜杠换行符（backslash-newline）或者使用/*...*/风格的注释来延续行。
在指令被处理之前，这些反斜杠换行符或注释将被替换掉（替换为空白或删除），以便保持指令的连续性。

* 标记

预处理将C代码（去除其注释）划分为预处理标记，这些标记类似于C标记，但并不完全相同。以下是预处理标记的特点。

预处理标记的主要类别包括标识符、预处理数值、字符串常量、字符常量和标点符号；还有一些其他类型的预处理标记。

*标识符*

	标识符预处理标记在语法上类似于C中的标识符：它可以是由字母、数字或下划线组成的任意序列，
	还可以使用'\U'或'\u'表示非ASCII字符，但不能以数字开头。

	在预处理阶段，C语言的关键字没有特殊意义；在这个阶段，它们只是普通的标识符。
	因此，您可以定义一个宏，其名称是一个关键字。在预处理期间，唯一具有特殊意义的标识符是defined（请参阅defined）。

*预处理数值*

	预处理数值是指预处理阶段将其文本视为数字的内容，包括C语言的数值常量以及其他类似数值常量的字符序列。
	预处理并不尝试验证预处理数值是否在C语言中是有效的数字，实际上它不一定是一个合法的C语言数值。

	更准确地说，预处理数值以可选择以小数点开始，接着是必需的十进制数字，然后继续包含任意序列的字母、数字、下划线、
	小数点和指数部分。指数部分由两个字符组成，包括 'e+'、'e-'、'E+'、'E-'、'p+'、'p-'、'P+' 和 'P-'。
	（以 'p' 或 'P' 开头的指数部分是C99引入的，它们用于表示十六进制浮点常量。）

*标点*

	标点符号在语法上类似于运算符。以下是有效的标点符号：

#+begin_src c
	[  ]   (  )  {  }  .  ->
	++ --  &  *  +  -  ~  !
	/  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
	?  :   ;  ...
	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
	,  #   ##
	<: :>  <% %>  %:  %:%:
#+end_src

*字符串常量*

	在源代码中的字符串常量在预处理阶段被识别为一个单一的预处理标记。

*字符常量*

	在源代码中的字符常量在预处理阶段被识别为一个单一的预处理标记。

*头文件名*

	在#include指令内部，预处理器识别头文件名标记。它由'"name"'组成，
	其中name是除换行符和双引号之外的源代码字符序列，或者由'<name>'组成，
	其中name是除换行符和尖括号之外的源代码字符序列。

	在实际使用中，更方便的做法是将#include行视为不需要进行标记化的例外情况。

*其他*

	除此之外，在C源程序中任何其他有效的字符都会被视为独立的预处理标记。


一旦程序被划分为预处理标记，它们会保持独立直到预处理结束。
宏生成的两个连续标记会在必要时插入空格来保持它们的独立性。例如，

#+begin_src c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
#+end_src

唯一的例外是使用##预处理运算符，它将标记粘贴在一起（参见拼接）。

预处理将空字符（字符代码0）视为空格，但是对其生成警告，因为它可能对用户不可见（许多终端根本不显示它），
而且在文件中出现它很可能是一个错误。

* 头文件

头文件是一种C代码文件，通常包含C声明和宏定义（参见宏），用于在多个源代码文件之间共享。
您可以通过使用C预处理指令 #include 来请求在程序中使用头文件。

头文件有两个目的:

 * 操作系统使用头文件提供接口。您将操作系统提供的头文件包含在您的程序中，以提供您需要调用系统调用和库的定义和声明。

 * 特定程序的头文件包含特定程序源文件之间的接口声明。如果所有或大部分接口声明和宏定义在多个不同的源文件中都需要使用，那么为相关声明和宏定义创建一个头文件是一个不错的主意。

如果没有头文件那么就需要将相同内容在每个源文件中重新书写一遍，但是这样的重写不但浪费时间还容易出错。
有了头文件，相关的声明只出现在一个地方。如果它们需要被修改，您可以在一个地方进行修改，然后包含该头文件的程序在下次重新编译时会自动使用新版本。
头文件消除了查找和更改所有副本的工作量，同时也消除了未更改一个副本会导致程序内部不一致的风险。

在C语言中，通常的约定是给头文件命名以 .h 结尾。在头文件名称中，最好只使用字母、数字、破折号和下划线，并且最多只有一个点，这样可移植性最好。

** 包含头文件语法

您可以使用预处理指令 #include 来指定包含用户和系统头文件。它有两种变体：

#+begin_src c
#include <file>
#+end_src

	这个变体用于包含系统头文件。它在标准系统目录列表中搜索名为 "file" 的文件。您可以使用 -I 选项在此列表前添加目录
	（参见《使用GNU编译器集合》中的 "调用GCC"）。

#+begin_src c
#include "file"
#+end_src

	这个变体用于包含您自己程序的头文件。它首先在包含当前文件的目录中搜索名为 "file" 的文件，然后在引号目录中搜索，
	最后在用于 <file> 的相同目录中搜索。您可以使用 -iquote 选项在引号目录列表前添加目录。


在 #include 的参数中，无论是用引号括起来还是用尖括号括起来，它都像一个字符串常量一样运行，即不识别注释，并且不会展开宏名称。
因此，#include <x/*y> 表示包含一个名为 x/*y 的系统头文件。

一些系统将 ‘\’ 解释为文件名与路径的分隔符。所有系统以相同的方式解释 ‘/’。为了最大的可移植性，最好只使用 ‘/’。

在 #include 行的文件名后面放置除注释以外的任何内容都是错误的。

** 包含头文件操作

#include指令的工作原理是在继续处理当前文件之前扫描指定的头文件。预处理的结果包括已经生成的文本，
后跟预处理包含文件的结果，然后是继续处理#include指令之后的文本。
例如，如果有一个名为header.h的头文件，内容如下：

#+begin_src c
char *test (void);
#+end_src

假设main函数在名为program.c的源文并使用上面提到的头文件：

#+begin_src c
int x;
#include "header.h"

int
main (void)
{
  puts (test ());
}
#+end_src

结果等同于直接把头文件中的内容放置到program.c中

#+begin_src c
int x;
char *test (void);

int
main (void)
{
  puts (test ());
}
#+end_src


包含的文件不仅限于声明和宏定义；这些只是典型的用法。C程序的任何片段都可以从另一个文件中包含进来。
包含的文件甚至可以包含在包含文件中开始的语句的开头，或者在包含文件中结束的语句的结尾。
然而，被包含的文件必须由完整的标记组成。在被包含的文件中，如果注释或字符串文字在文件结束时没有关闭，
那么它们是无效的。为了错误恢复，编译器将在文件结束时终止它们的处理。

为了避免混淆，最好让头文件只包含完整的语法单元，例如函数声明或定义、类型声明等。

不管被包含的文件是否缺少最后的换行符，紧随#include指令的那一行始终被视为一个单独的行。在这里放置预处理指令也没有问题。

** 搜寻路径

GCC在寻找要包含的头文件时会查找多个不同的位置。在GNU系统和Unix系统上，系统头文件的默认目录包括：

#+begin_src 
libdir/gcc/target/version/include
/usr/local/include
libdir/gcc/target/version/include-fixed
libdir/target/include
/usr/include/target
/usr/include
#+end_src

在一些操作系统中，这个列表可能会有所不同。此外，对于C++，可能会添加其他目录用于头文件的查找。


在上述内容中，target是GCC配置为编译代码的系统的规范名称；通常情况下，
但并不总是与运行GCC的系统的规范名称相同。version是正在使用的GCC版本。

你可以通过命令行选项"-Idir"来增加这个列表。所有由"-I"指定的目录将按照从左到右的顺序在默认目录之前进行搜索。
唯一的例外是当"dir"已经是默认搜索目录之一时。在这种情况下，该选项会被忽略，系统目录的搜索顺序保持不变。

在将使用引号与尖括号所引用的路径合并之前，重复的路径将从他们各自的集合中移除。因此，如果一个路径分别出现在
使用引号和尖括号的引用集合之中，那么他可能在合并的路径集合中出现两次。

你可以通过使用"-nostdinc"选项来阻止GCC搜索任何默认目录。这在编译操作系统内核或其他不使用标准C库设施或标准C库本身
的程序时非常有用。当启用"-nostdinc"选项时，GCC之搜索-I指定的路径。

GCC首先在包含当前文件的目录中查找使用#include "file"指令请求的头文件，
然后在由"-iquote"选项指定的引号目录中查找，最后在它通常搜索系统头文件的位置查找。
例如，如果"/usr/include/sys/stat.h"文件中包含了#include "types.h"，
GCC将首先在"/usr/include/sys"目录中查找types.h，然后在引号目录中查找，最后在其通常的搜索路径中查找。

#line（参见Line Control）指令不会改变GCC对包含当前文件的目录的理解。

"-I-"是一种过时的、老式的方式来指定引号目录（quote directories）。要在名为"-"的目录中查找头文件，可以使用"-I./-"。
调整头文件搜索路径还有其他几种方法，请参阅《使用GNU编译器集合》中的《调用GCC》章节。

** 单次包含头文件


如果一个头文件被包含两次，编译器将会处理它的内容两次。这很可能导致错误，例如当编译器看到相同的结构体定义两次时会发生错误。

防止头文件重复包含的标准方法是使用条件编译将整个文件的真实内容包裹起来，就像这样：

#+begin_src c
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

the entire file

#endif /* !FILE_FOO_SEEN */
#+end_src

这个构造通常被称为包装器 #ifndef。当头文件再次被包含时，条件将为假，因为FILE_FOO_SEEN已经被定义。预处理器会跳过整个文件的内容，
因此在同一个模块中编译时将不会“再次看到”文件内容。

GCC在这种情况下甚至进一步优化了处理方式。它会记住哪些头文件有包装器 #ifndef。如果后续的#include指定了该头文件，
并且#ifndef中的宏仍然被定义，GCC将不再重新扫描整个文件。

你可以将注释放在头文件的包装器之外，这些注释不会干扰优化。

宏FILE_FOO_SEEN被称为控制宏或守卫宏。在用户头文件中，宏的名称不应以'=_='开头。
在系统头文件中，它应该以'=__='（或'=_='后跟一个大写字母）开头，以避免与用户程序发生冲突。在任何类型的头文件中，
宏的名称应包含文件的名称和一些额外的文本，以避免与其他头文件发生冲突。


** 计算式包含

有时候需要从几个不同的头文件中选择一个包含到程序中。这些头文件可能指定了在不同类型的操作系统上使用的配置参数，
例如，你可以通过一系列条件语句来实现这一点。

#+begin_src c
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
/* … */
#endif
#+end_src

那样很快就会变得乏味。GNU C提供了使用宏作为头文件名的功能。这被称为计算式包含（Computed Include）。
在#include的直接参数中，你只需放置一个宏名即可，而不是写上头文件名：

#+begin_src c
#define SYSTEM_H "system_1.h"
/* … */
#include SYSTEM_H
#+end_src


SYSTEM_H被展开后，system_1.h会被包含，就好像#include指令是用system_1.h这个名字写的。
SYSTEM_H可以通过你的Makefile使用-D选项进行定义。


在定义这样的宏时必须小心。#define保存的是标记（tokens），而不是文本。GCC无法知道宏将作为#include指令的参数使用，
因此它生成普通的标记，而不是头文件名。如果你使用双引号包含（double-quote includes），
这与字符串常量在语法上相似，那么这可能不会引起问题。然而，如果你使用尖括号包含（angle brackets），可能会遇到问题。

计算式包含的语法实际上比上述所述的更加通用。如果在#include指令后的第一个非空白字符不是'“'或'<'，
那么整行代码将会像普通代码一样进行宏展开。

如果计算式包含展开为一个单独的字符串常量，那么该字符串常量的内容将作为要包含的文件名。
预处理器不会重新检查字符串中是否有嵌套的引号，也不会处理字符串中的反斜杠转义符。
因此，计算式包含是在宏展开阶段进行处理的，不会再次解析字符串中的引号或反斜杠转义符。

#+begin_src c
#define HEADER "a\"b"
#include HEADER
#+end_src

查找名为a\"b的文件，计算式包含会根据双引号包含（double-quoted includes）的规则来搜索这个文件。

如果计算式包含展开的结果是一个以'<'标记开头且包含'>'标记的标记流（token stream），
那么位于'<'和第一个'>'之间的标记将被组合成要包含的文件名。在组合文件名时，任何标记之间的空格都会被缩减为一个空格；
然后在初始的'<'后面的空格会保留，但在结束的'>'之前的末尾空格将被忽略。
预处理器会根据尖括号包含（angle-bracket includes）的规则来搜索该文件。

在任何情况下，如果在文件名之后的行上存在任何标记，都会导致错误，并且该指令不会被处理。
如果展开的结果不符合预期的两种形式之一，也会引发错误。

这些规则是根据C标准定义的实现定义行为。为了最大限度地减少不同编译器对计算式包含的解释差异，
我们建议你只使用一个类似对象的宏，其展开结果是一个字符串常量。这样做也有助于程序读者更好地理解代码。

* 宏定义

宏（Macro）是一段被赋予名称的代码片段。无论何时使用该名称，它都会被宏的内容所替代。
宏分为两种类型，它们在使用时的外观主要有所不同。类似数据的宏在使用时类似于数据对象，
而类似函数的宏则类似于函数调用。

你可以将任何有效的标识符定义为宏，即使它是C语言的关键字也可以。在预处理阶段，GCC（GNU编译器集合）
对关键字一无所知。如果你希望隐藏像 const 这样的关键字，以使其不被旧的不理解它的编译器识别，
这会很有用。然而，预处理操作符 defined（参见 defined）永远不能被定义为宏，
而C++的命名操作符（参见在使用GNU编译器集合中的C++命名操作符）在编译C++代码时也不能作为宏使用。

** 类数据式宏

类数据宏（Object-like macro）是一个简单的标识符，它将被一个代码片段所替代。
之所以称之为类数据，是因为在大多数情况下，宏的使用类似于对使用它的代码中的数据对象的引用。
这些宏通常用于为数值常量赋予符号名称。

定义宏需要使用 #define 指令。#define 后面跟着宏的名称，然后是它应该代表的标记序列，
这个序列在不同的情况下也被称为宏的主体、展开或替换列表。例如，

#+begin_src c
#define BUFFER_SIZE 1024
#+end_src

定义了一个名为 BUFFER_SIZE 的宏，将其缩写为标记 1024。
如果在这个 #define 指令之后的某个地方出现一个形如下面的 C 语句

#+begin_src c
foo = (char *) malloc (BUFFER_SIZE);
#+end_src

那么预处理将会识别并将 BUFFER_SIZE 展开，因此编译过程将会看到以下标记：

#+begin_src c
foo = (char *) malloc (1024);
#+end_src

按照惯例，宏的名称使用大写字母书写。当能够一眼就看出哪些名称是宏时，程序更容易阅读。
以“__”开头的宏名称被保留供内部使用，并且其中许多是自动定义的，因此除非你确切知道自己在做什么，
否则不要定义此类宏名称。同样，以“_”和大写字母开头的宏名称也是如此。

宏的主体在 #define 行的末尾结束。如果需要的话，你可以使用反斜杠换行将定义延续到多行。
然而，当宏被展开时，所有内容将会放在一行上。例如，

#+begin_src c
#define NUMBERS 1, \
                2, \
                3
int x[] = { NUMBERS };
     → int x[] = { 1, 2, 3 };
#+end_src

这种情况最常见的显而易见的后果是错误消息中出现令人惊讶的行号。

在宏主体中可以放置任何内容，只要它分解为有效的预处理标记即可。括号不需要配对，
主体也不需要类似于有效的 C 代码。（如果不是有效的 C 代码，当你使用宏时可能会从 C 编译器得到错误消息。）

预处理会按顺序扫描程序。宏定义在出现后立即生效。因此，以下输入:

#+begin_src c
foo = X;
#define X 4
bar = X;
#+end_src

将会产生以下结果：

#+begin_src c
foo = x;
bar = 4;
#+end_src

当预处理展开一个宏名称时，宏的展开将替宏名称，然后会对展开后的内容进行更多的宏展开。例如，

#+begin_src c
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     → BUFSIZE
     → 1024
#+end_src

首先，TABLESIZE 被展开为 BUFSIZE，然后该宏被展开为最终结果，即 1024。

请注意，当定义 TABLESIZE 时并没有定义 BUFSIZE。对于 TABLESIZE 的 #define 指令完全使用你指定的展开内容，
即在此情况下为 BUFSIZE，并且不会检查其是否也包含宏名称。只有当你使用 TABLESIZE 时，
其展开结果才会被扫描以进行更多的宏替换。


如果在源文件的某个地方更改了 BUFSIZE 的定义，这将产生差异。
如上所示定义的 TABLESIZE 将始终使用当前有效的 BUFSIZE 定义进行展开：

#+begin_src c
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
#+end_src

现在展开后的 TABLESIZE 为37。

如果宏的展开内容包含自己的名称，无论是直接还是通过中间宏，当对展开内容进行更多的宏展开时，它不会再次被展开。
这样可以防止无限递归。有关详细信息，请参阅《自引用宏》（Self-Referential Macros）。

** 类函数宏

你还可以定义类似于函数调用的宏。这些被称为类函数宏。要定义一个类函数宏，
请在宏名称后面紧跟一对括号，使用#define 指令。例如，

#+begin_src c
#define lang_init()  c_init()
lang_init()
     → c_init()
#+end_src

类函数宏只有在其名称后面跟着一对括号时才会展开。如果只写名称而没有括号，它将保持不变。
当你有一个同名的函数和宏，而你有时希望使用函数时，这会很有用。在调用宏时，括号前面或括号之间的空格和换行将被忽略。

#+begin_src c
extern void foo(void);
#define foo() /* optimized inline version */
/* … */
  foo();
  funcptr = foo;
#+end_src

这里对foo()的调用会展开宏，但是函数指针funcptr会获得真实函数foo的地址。如果在这里展开宏，将会导致语法错误。

如果在宏定义中在宏名称和括号之间加上空格，那不会定义一个类似函数的宏，而是定义一个对象类似的宏，
其展开恰好以一对括号开头。这里是一个示例：

#+begin_src c
#define lang_init ()    c_init()
lang_init()
     → () c_init()()
#+end_src

这个展开中的前两对括号来自于宏。第三对括号是宏调用的原始括号。由于lang_init是一个类对象宏，它不会消耗那些括号。

任何名称一次只能有一个宏定义。因此，你不能同时将同一个名称定义为类对象宏和类函数宏。

** 宏参数

类函数宏可以像真正的函数一样带参数。要定义一个带参数的宏，你需要在宏定义的一对括号中插入参数，
使宏变得类似函数。这些参数必须是有效的 C 标识符，用逗号和可选的空格分隔。

要调用带有参数的宏，你需要在宏名称后面用括号括起来的实际参数列表，参数之间用逗号分隔。
宏的调用不必局限于单个逻辑行 - 它可以跨越源文件中的多行。你提供的参数数量必须与宏定义中的参数数量相匹配。
当宏被展开时，在宏体内每次使用一个参数时，都会被相应参数的标记所替代。（宏体不一定要使用所有参数。）

例如，这里有一个在许多 C 程序中定义的计算两个数值的最小值的宏，以及一些用法示例：

#+begin_src c
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
  x = min(a, b);      → x = ((a) < (b) ? (a) : (b));
  y = min(1, 2);      → y = ((1) < (2) ? (1) : (2));
  z = min(a+28, *p);  → z = ((a+28) < (*p) ? (a+28) : (*p));
#+end_src

在这个小例子中，你已经可以看到宏参数的一些危险之处。详细的解释可以查看“宏陷阱”部分。

每个参数中的前导和尾随空白都会被删除，参数中标记之间的所有空白会被缩减为单个空格。
每个参数中的括号必须保持平衡；括号内的逗号不会结束参数。但是，方括号或大括号不需要保持平衡，
并且它们不会阻止逗号分隔参数。因此，

#+begin_src c
macro (array[x = y, x + 1])
#+end_src

向宏传递了两个参数：array[x = y 和 x + 1]。如果你想将array[x = y, x + 1]作为参数提供，
可以写成array[(x = y, x + 1)]，这与等效的 C 代码是相同的。然而，将赋值放在数组下标内部是要避免的。

所有传递给宏的参数在被替换到宏体之前都会完全宏展开。在替换后，完整的文本会再次被扫描以展开宏，包括参数。
这个规则可能看起来很奇怪，但它经过精心设计，所以你不必担心任何函数调用是否实际上是宏调用。
不过，如果你过于聪明，可能会遇到问题。详细讨论请参阅“参数预扫描”。

例如， min (min (a, b), c) 首先被展开为：

#+begin_src c
min (((a) < (b) ? (a) : (b)), (c))
#+end_src

然后继续被展开为：

#+begin_src c
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
#+end_src

（换行只是为了使代码看起来清晰真实的代码中并不会产生换行。）

#+begin_src c
min(, b)        → ((   ) < (b) ? (   ) : (b))
min(a, )        → ((a  ) < ( ) ? (a  ) : ( ))
min(,)          → ((   ) < ( ) ? (   ) : ( ))
min((,),)       → (((,)) < ( ) ? ((,)) : ( ))

min()      error→ macro "min" requires 2 arguments, but only 1 given
min(,,)    error→ macro "min" passed 3 arguments, but takes just 2
#+end_src

空格不是预处理标记，因此如果一个宏foo接受一个参数，foo () 和 foo ( ) 都会提供一个空参数给它。

出现在字符串字常量内部的宏参数不会被它们对应的实际参数替换。

#+begin_src c
#define foo(x) x, "x"
foo(bar)        → bar, "x"
#+end_src

请参见下一小节，了解如何将宏参数插入字符串字面量中。

即使看起来可能合并成一个标记，紧随宏调用的标记和宏展开的最后一个标记也不会成为一个标记：

#+begin_src c
#define foo()  abc
foo()def        → abc def
#+end_src

** 字符串化

有时您可能希望将宏参数转换为字符串常量。在字符串常量内部，参数不会被替换，但您可以使用 # 预处理运算符来实现。
当一个宏参数以 # 开头使用时，预处理会将其替换为实际参数的字面文本，转换为字符串常量。
与普通的参数替换不同，这里的参数不会先进行宏展开。这被称为字符串化。

没有办法将参数与周围的文本结合起来并一起转化为字符串。但是您可以编写一系列的字符串常量和字符串化的参数。
在预处理将字符串化的参数替换为字符串常量后，连续的字符串常量将被连接成一个长的字符串常量（参见字符串常量）。

这里有一个使用字符串化和字符串常量连接的示例：

#+begin_src c
#define WARN_IF(EXP) \
  do { if (EXP) \
          fprintf (stderr, "Warning: " #EXP "\n"); } \
  while (0)

WARN_IF (x == 0);
     →
  do { if (x == 0)
          fprintf (stderr, "Warning: " "x == 0" "\n"); }
  while (0);
#+end_src

对于 EXP 的参数会被替换一次，原样地放入 if 语句中，并被字符串化后放入 fprintf 的参数中。
如果 x 是一个宏，它会在 if 语句中被展开，但不会在字符串中展开。


do 和 while (0) 的使用是一种权宜之计，使得可以编写 WARN_IF (arg);。WARN_IF 与函数的相似性使其成为一种自然的编写方式。
详见吞噬分号。


在 C 语言中的字符串化不仅仅涉及将双引号字符放在片段周围。它还会使用反斜杠转义符将引号放置到字符串常量周围，
以及字符串和字符常量内的所有反斜杠，以获得具有正确内容的有效 C 字符串常量。
因此，将 p = "foo\n"; 进行字符串化将得到 "p = "foo\n";"。
然而，在不在字符串或字符常量内部的反斜杠不会被复制：独立的 ‘\n’ 字符串化为 "\n"。

在被字符串化的文本中，所有前导和尾随的空白都会被忽略。在文本中间的任何一系列空白会在字符串化结果中转换为单个空格。
注释会在字符串化发生之前被替换为空白，因此它们永远不会出现在被字符串化的文本中。

无法将宏参数转换为字符常量。

要将宏参数的展开结果转化为字符串，您需要使用两层宏，就像这样：

#+begin_src c
#define xstr(S) str(S)
#define str(s) #s
#define foo 4
str (foo)
     → "foo"
xstr (foo)
     → xstr (4)
     → str (4)
     → "4"
#+end_src

当 s 在 str 中使用时会被字符串化，因此它不会先进行宏展开。但是 S 是传递给 xstr 的普通参数，
因此在 xstr 自身展开之前，它会被完全宏展开（参见参数预扫描）。因此，当 str 到达其参数文本时，
该文本已经进行了宏展开。






