#+title: 11 基本数据类型

本章将讲述C语言的所有基本数据类型，即所有不是从其他数据类型构建起来的类型。这其中就包括
之前章节涵盖过的 *int* 和 *double* 类型。

这些类型都是由字节组成的。

** 整数类型(Integer)

本节讲述说有整数类型和它们的基本特性。若要从比特级更多的了解整数数据的呈现和算术请参考
深入整数章节。

*** 整数基础

C语言中的整形数据可以是有符号或无符号的。无符号类型只能呈现整数和零。有符号类型可以呈现
正数和负数，它们的范围是以零为中心正负数绝对值几乎相同的一个区间。

除了整数的符号以外，整数数据类型的大小各不相同：它们一共有多少个字节。字节数决定该类型
可以存储多大的整数值。

下面的列表是有符号整数数据类型和它们所拥有的字节数。它们都有与其对应的无符号数。
详情请见有符号和无符号类型章节。

*signed char*

    1个字节(8比特位)。这种整数类型主要用于代表字符的整数，作为数组或其他数据结构的一部分。

*short*
*short int*

    2个字节(16比特位)。

*int*

    4个字节(32比特位)。

*long*
*long int*

    4字节(32比特位)或8字节(64比特位)，根据不同的平台而定。通常，在32位计算机上是32位，
    在64位计算机上是64位，但也有例外。

*long long*
*long long int*

    8字节(64比特位)。GNU C在1980年代开始支持此类型，国际标准化组织(ISO)在1999年的
    C99标准中开始支持此类型。

当你使用long或short时，你可以省略int。这是无害和惯用的。

*** 有符号与无符号类型
无符号类型只能呈现整数和零。有符号类型可以呈现正数和负数，它们的范围是以零为中心正负数
绝对值几乎相同的一个区间。比如说， *unsigned char* 可以容纳的数值从0到255(在大多数计算机中)，
而 *signed char* 可以容纳的数值从-128到127。每个类型都可以容纳256个不同的数值，因为它们
都是8比特位宽。

在类型关键字之前使用 *signed* 或 *unsigned* 可以指定类型是有符号或无符号的。然而，除了
*char* 之外的整数类型都是默认有符号的，对他们使用 *signed* 是没有意义的。

普通 *char* 可以是有符号或无符号的；这取决于编译器、使用的机器和其操作系统。

在许多程序中，char是否有符号并无区别。当符号确实重要时，不要让编译器决定，请明确使用
*signed char* 或 *unsigned char* 。

*** 窄整数

比 *int* 拥有更少字节的的类型(窄整形)很少用于普通变量--我们使用 *int* 替代它们，因为C语言会将
任何算术运算中较 *int* 拥有更少字节的类型转换成 *int* 类型。比如说从字面上来看没有理由
将一个局部变量声明为 *char* 类型。

特别是即使数值是一个 *char* 类型也应该该将其声明成 *int* 类型而不是 *char* ! 使用窄整形将会
迫使编译器为了类型转换二阶段数值，这时一种浪费。此外，一些函数要么返回一个字符值，要么返回-1表示
"无字符"。使用int可以保持这些值的区别。

窄的整数类型作为其他对象的一部分是很有用的，如数组和结构。比较一下这些数组声明，
它们在32位处理器上的大小显示出来了：

#+begin_src c
  signed char ac[1000];   /* 1000 bytes */
  short as[1000];         /* 2000 bytes */
  int ai[1000];           /* 4000 bytes */
  long long all[1000];    /* 8000 bytes */
#+end_src

此外，字符串必须由字符组成，因为这也是所有标准库中的字符串函数所期望的。因此，数组ac可以作为字符串使用，
但其他的就不行了。

*** 整数类型之间的转换

在许多情况下，C语言在整数类型之间进行隐式转换。在任何算术运算中 *char* 和 *short* 类型都会被转换成
*int* 类型。对一个变量进行赋值(或者其他左值)会将值转换成变量的类型。

你也可以使用类型转换运算符转换一个整数类型到另外一个指定的类型。详见显式类型转换。

转换到较宽整形的操作非常直接：数值不会被改变。唯一例外是转换一个负值(一个明显的有符号类型)到较宽的
类型。在这种情况下转换的结果是将符号位直接作为数值的最高位的正整数。(详见深入整数)。

转换到较窄的整数类型也被成为 /截断/ ，这涉及到丢弃被转换数值的一些比特位。这不被认为是溢出因为有效
比特位的丢失是阶段的正常后果。对于拥有同样位宽的有符号和无符号类型之间的转换同样不被视为溢出。

更多关于赋值类型缓缓的信息在赋值类型转换章节，关于算术运算类型转换的信息在参数类型提升章节。

*** 布尔类型

无符号整型 *bool* 用来保存真值：0和1。转换所有非零值到 *bool* 都被转换为1。例如：

#+begin_src c
  bool a = 0;
  bool b = 1;
  bool c = 4; /* Stores the value 1 in c.  */
#+end_src

与 *int* 不同， *bool* 不是一个关键字。它被定义在stdbool.h头文件中。

*** 整数多样性

C语言的整数类型们都有标准的 /名字/ ，但是他们的 /意义/ 却取决于不同的平台：不同的计算机，
不同的操作系统,不同的编译器，甚至不同的编译器选项。

普通的 *char* 也许是有符号的或无符号的；这也取决于不同的平台。甚至GUN C 也没有一个通用的规则。

理论上所有的整数类型的字节数都是可变的。 在C语言中 *cahr* 总被认为是一个"字节"，但是一个字节
并不一定必须只能拥有8个比特位；有些平台上可能多于8比特。ISO C标准仅规定平台上的整数类型必能比
基础整数章节中规定的比特数更少，并且 *short* 最少需要拥有16比特。

GNU C在未来将会支持整型数为64比特位长度的平台。然而实际上，在现今的计算机之间区别不大，具体可以
参考前面给出的表格(基础整数章节)

为了完全确定整数类型的比特位数，使用类型 *int16_t* ， *int32_t* 和 *int64_t* 。对于无符号类型
只需要在每个关键字前面增加 'u'即可。它们都被定义在 *stdint.h* 头文件中。

GNU C编译器在一些嵌入式设备上编译程序时将 *int* 类型定义为两字节。在一些平台上 *int* 只有一字节，
所以它是 *short int* 但是这里的"字节"可能包含16比特或32比特。这些嵌入式设备的处理器不支持普通操作系统
(它们有自己专用的操作系统)，并且大多数C语言程序也不会试图支持它们。


** 浮点数

浮点数是类似科学计数法的二进制符号：在其内部以一个小数和一个二进制指数来表示；实际的数值是该小数乘以2的指数
次方。

例如：要表示浮点数6，小数部分应该是0.75而指数部分应该是3；用它们在一起计算就是 *0.75x2^3* ，
即 *0.75x8* 。 浮点数1.5的小数部分应该是0.75而指数部分应该1。浮点数0.75的小数部分应该是0.75
而指数部分应该是0。浮点数0.375的小数部分应该是0.75而指数部分应该是-1。

这些二进制指数是由机器指令使用的。如果你愿意，你可以用十六进制的方式来写浮点数常数；但是通常我们用十进制来写浮点数。
详情请见浮动常数。

C语言拥有三种浮点数类型：

 * *double*

   "双精度"浮点数，64比特位宽。这是最常用的浮点数类型，现代计算机通常用这种类型或更宽的类型进行浮点计算。除非有特殊原因，
   否则这就使用这种类型的浮点数。

 * *float*

   "单精度"浮点数，32比特位宽。它的用处是当不需要"双精度"浮点数时在结构体和数组中以该类型存储数据以节省存储空间。
   此外，单精度算术在某些计算机上更快，偶尔也会有用。但并不经常，大多数程序都不使用 *float* 类型。

 * *long double*

   "扩展精度"浮点数，80或128比特位宽。取决于所使用的机器。在某些机器上，由于没有比 *double* 更宽的浮点格式，该类型位宽等于 *double* 。

浮点运算会引起许多微妙的问题。更多信息请参见深入浮点数章节。

** 复数

复数包含实部和虚部。实部是一个实数常量，虚部由一个实数常量加后缀 'i'组成。

可以使用 *_Complex* 关键字将一个数字变量声明成复数。标准C语言复数类型时浮点数，

#+begin_src c
  _Complex float foo;
  _Complex double bar;
  _Complex long double quux;
#+end_src 

但是GNU C也支持整数类型的复数。

由于 *_Complex* 是一个与 *float* 和 *double* 一样的关键字所以它在变量生声明中的位置无关紧要，但是上面示例中的顺序更有逻辑性。
详情请见虚数常量章节。

GNU C提供了 *__real__* 和 *__imag__* 关键字来获取复数中获取实部和虚部：

#+begin_src c
  _Complex double foo = 4.0 + 3.0i;

  double a = __real__ foo; /* a is now 4.0. */
  double b = __imag__ foo; /* b is now 3.0. */
#+end_src

标准C语言并不包含上述关键字，它以complex.h中定义的一系列函数来替代上述关键字： *crealf* , *creal* 和 *creall* 用来提取
单精度，双精度和扩展精度浮点数的实数部分； *cimagf* , *cimag* 和 *cimagl* 用来提取虚数部分。

GNU C 还定义了 ‘~’ 运算符用以计算共轭复数，它将对操作数的虚数部分的符号取反：

#+begin_src c
  _Complex double foo = 4.0 + 3.0i;
  _Complex double bar = ~foo; /* bar is now 4 - 3i. */
#+end_src

为了兼容标准C语言，你可以使用对应的库函数： *conjf* , *conj* 或 *confl* 。

** 虚空类型

*void* 类型是一个无意义的类型--它不允许任何操作。它的真正意义是"没有任何数值"。当一个函数没有返回值那么我们使用 *void* 作为
它的返回值类型。那么 *return* 不需要指定任何值。详见返回语句。例如：

#+begin_src c
  void
  print_if_positive (double x, double y)
  {
    if (x <= 0)
      return;
    if (y <= 0)
      return;
    printf ("Next point is (%f,%f)\n", x, y);
  }
#+end_src

在一些其他编程语言中使用"过程" 来称呼C语言中的无返回值函数。

** 其他类型

基础类型之外，C语言提供多种方法用以构造新的数据类型。例如：存储其他数据内存地址的指针类型，很多其他语言也拥有结构体，在
同一内存空间存储多种类型的联合体。用来命名整数集合的枚举类型。详情请见指针，结构，联合，枚举类型章节。

C语言中的数组类型用于为对象分配空间，但C语言不允许将数组值作为一个整体进行操作。详见数组章节。

** 类型代号

某些C语言结构需要一种途径独立于变量和表达式指定一个具体的数据类型。这种途径被成为类型代号。
这些结构包括类型转换(详见显示类型转换)和求取类型字节数(详见类型大小)。

在C语言中，我们也使用类型代号来谈论一个值的类型，所以你会在本手册中看到许多类型代号。
当我们说 "这个值的类型是int "时， *int* 就是一个类型代号。

例如：指定完全字节整数数据，我们声明一个该类型变量 *foo* :

#+begin_src c
  int foo;
#+end_src

然后我们删除变量名 *foo* 和分号，留下 *int* --正是这种声明中使用的关键字。因此，这个类型的类型代号是 *int* 。

以下声明的类型修代号是什么？

#+begin_src c
  unsigned long int foo;
#+end_src

我们确定类型代号是 *unsigned long int* 。

按照这个过程，任何原始类型的代号都只是在声明中指定该类型的一组关键字。对于复合类型，如结构、联合体和枚举，也是如此。

指针类型的代号同样遵循了删除变量名和分号的规则，但结果却不是那么简单。
详情请见指针类型指定器，作为关于指针的章节的一部分。关于数组类型的指定器，参见数组类型指定器。

为了理解一个代号代表什么类型，想象一个变量的名字插入到代号的正确位置，使之成为一个有效的声明。
这个变量会被声明为什么类型？这就是代号所指定的类型。
