#+title: 语句

语句指定希望产生的结果所需要的计算；它并不像表达式一样产生一个值。通常情况下语句以一个分号(';')作为结尾，但是块(一条或多条语句组成)是个例外。(详见块章节)

语句将被使用在块中或其它复合语句中。一个复合语句包含一个或两个为嵌套语句的部件。每一个组件必须有且只有一条语句组成。
在这样的组件中放置多个语句的方法是将它们组合成一个块（详见块章节），这被视为一个语句。

以下章节将讲述多种语句。

* 表达式语句

C语言中最常见的语句是表达式语句。它是一个以分号结尾的表达式。表达式的值在执行后将被丢弃，所以若要使表达式有用则必须让它产生其本身作用之外的作用：
赋值表达式，自增和自减表达式，函数调用。例如：

#+begin_src c
  x = 5;              /* Assignment expression. */
  p++;                /* Increment expression. */
  printf ("Done\n");  /* Function call expression. */
  *p;                 /* Cause SIGSEGV signal if p is null. */
  x + y;              /* Useless statement without effect. */
#+end_src

在非常不寻常的情况下，我们使用一个表达式语句，其目的是在地址无效的情况下获得一个错误：

#+begin_src c
  volatile char *p;
  …
  *p;                 /* Cause signal if p is null. */
#+end_src

如果变量 *p* 没有被声明为volatile，编译器可能会优化掉内存访问，因为它知道这个值并没有被真正使用。详见volatile。

* if 语句

*if* 语句通过计算一个表达式来决定是否执行后续的语句，例如：

#+begin_src c
  if (condition)
    execute-if-true
#+end_src

首先将计算 /condition/ 的值，如果值为真(非0)那么将执行语句 /execute-if-true/ 。如果值为假(0)，那么将不会执行 /execute-if-true/，
以什么都不做作为替代。

这是一个复合语句因为它包含 /if-true-substatement/ 这样的嵌套语句。它必须有且只有一条语句。
把多个语句放在那里的方法是把它们组合成一个块（详见块章节）。

* if-else 语句

*if-else* 语句通过计算一个表达式来决定下面两个嵌套语句中的哪一个将被执行。例如：

#+begin_src c
  if (condition)
    if-true-substatement
  else
    if-false-substatement
#+end_src


首先将计算 /condition/ 的值，如果值为真(非0)那么将执行语句 /if-true-substatement/ 。如果值为假(0)，那么将执行 /if-false-substatement/
作为替代。


这是一个复合语句因为它包含 /if-true-substatement/ 和 /if-else-substatement/ 这样的嵌套语句。它必须有且只有一条语句。
把多个语句放在那里的方法是把它们组合成一个块（详见块章节）。

* 块

块是一种包含多条各种语句的结构。它以'{'开始'}'结束，并在其中存在一系列语句和声明。块的另一个名称是 /复合语句/ 。

块是语句吗？ 是也不是。它看起来并不像普通的语句，它并不以分号作为结尾。但是你可以像使用语句一样使用它；在任何需要或允许声明的地方，
你都可以写一个块，并将该块视为一个声明。

到目前为止，似乎区块是一种具有特殊语法的语句。但这样说不完全正确：函数体也是块，并且绝对不是语句。函数头后面的文字不作为语句处理；
函数值允许拥有一个函数体，多余的都没有意义。

在形式化的语法中，我们将不得不选择--要么一个块是一种声明，要么不是。但这本手册是为人类编写的，而不是为分析器生成器编写的。对人类来说，
最清楚的答案是："在某些方面，块是一种声明"。

一个不是函数体的块被称为内部块或嵌套块。你可以把一个嵌套块直接放在另一个块里面，但更多的时候，嵌套块是在一些复杂的语句里面，如for语句或if语句。

C语言中的嵌套块有两种用途：

 * 指定局部声明的范围。例如，一个局部变量的作用域的范围只存在于所有包含它的块中最内层的块。

 * 编写一系列的语句，从语法上讲，它们在被调用时被视为一条语句。例如，一个if语句的execute-if-true就是一个语句。要把多个语句放在那里，
   必须用一个块来包装，像这样：

   #+begin_src c
     if (x < 0)
       {
         printf ("x was negative\n");
         x = -x;
       }
   #+end_src

下面的例子（从头开始循环）显示了一个嵌套块，它有两个目的：它在while语句的主体中包含了两个语句（加上一个声明），并且为 *q* 的声明提供了范围。

#+begin_src c
  void
  free_intlist (struct intlistlink *p)
  {
    while (p)
      {
        struct intlistlink *q = p;
        p = p->next;
        free (q);
      }
  }
#+end_src

* return 语句

*return* 语句使包含其的函数立即结束执行。它有两中形式，这里是一种没有返回值的形势：

#+begin_src c
  return;
#+end_src

这种形式是为返回类型为void的函数准备的（见 "Void类型"）。你也可以在一个返回非void数据的函数中使用它，但这是一个坏主意，因为它使函数返回垃圾值。

下面是有用返回值的形式：

#+begin_src c
  return value;
#+end_src

计算表达式的值并使函数返回该值。如果有必要，该值会进行类型转换，变成函数声明的返回值类型，这就像把该值分配给一个该类型的变量一样。

* 循环语句

当你需要重复执行一系列的语句时，你可以使用循环语句对它们进行迭代。C语言提供了几种不同类型的循环语句，它们将在下面的小节中进行了描述。

因为每种循环语句都包含一个组件所以它们都是复合语句，这个组件通常被称为循环体，它是一个嵌套语句。循环体通常是一个代码块。

** while 语句

while 语句是简单的循环结构，它看起来就像：

#+begin_src c
  while (test)
    body
#+end_src

在这里，循环体是一个语句（通常是一个嵌套代码块），需要重复执行，而test是控制是否再次重复执行循环体的测试表达式。循环的每次迭代都会先计算test，
如果test为真（非0），则表示循环应该再次执行循环体，如此往复。

以下是一个示例，它可以通过"next"字段遍历以其链接在一起的一系列结构体直到其中最有一个结构体：

#+begin_src c
  #include <stddef.h> /* Defines NULL. */
  …
  while (chain->next != NULL)
    chain = chain->next;
#+end_src

这段代码假定链表起始时不为空；如果链表为空（即，如果chain是一个空指针），则该代码会在尝试引用空指针时得到SIGSEGV信号（详见信号）。

** do-while 语句

do-while语句是一种简单的循环结构，它在每次迭代结束时执行test。

#+begin_src c
  do
    body
  while (test);
#+end_src 
在这里，body是一个语句（可能是一个代码块），需要重复执行，而test是控制是否再次重复执行循环体的表达式。

循环的每次迭代都会先执行循环体，然后计算test，如果test为真(非0)，则返回并重新开始执行循环体。如果test为假(0)，
则循环停止重复执行，程序继续向下执行。

** break 语句

*break* 语句的形式为 *'break;'* ，它的作用是立即退出最内层的循环结构或switch语句(详见switch语句)。

例如，下面这个循环会将p向前推进，直到下一个空字符或换行符：

#+begin_src c
  while (*p)
    {
      /* End loop if we have reached a newline.  */
      if (*p == '\n')
        break;
      p++
    }
#+end_src

当有嵌套循环时，break语句从包含它的最内层循环退出。

#+begin_src c
  struct list_if_tuples
  {
    struct list_if_tuples next;
    int length;
    data *contents;
  };

  void
  process_all_elements (struct list_if_tuples *list)
  {
    while (list)
      {
        /* Process all the elements in this node’s vector,
           stopping when we reach one that is null.  */
        for (i = 0; i < list->length; i++
          {
            /* Null element terminates this node’s vector.  */
            if (list->contents[i] == NULL)
              /* Exit the for loop.  */
              break;
            /* Operate on the next element.  */
            process_element (list->contents[i]);
          }

        list = list->next;
      }
  }
#+end_src 

在C语言中直接退出最外层循环的方式是使用 *goto* 语句 (详见goto语句)


** for 语句

for语句使用三个写在括号内的表达式来定义循环如何进行。第一个表达式为循环启动做准备。第二个表达式用来在每次迭代前测试是否继续循环。
第三个表达式是在一个迭代结束时，为下一个迭代进行准备。总的来说，它看起来像这样：

#+begin_src c
  for (start; continue-test; advance)
    body
#+end_src

*for* 语句做的第一件事是计算 *start* 。接下来它做的事情是计算表达式 *continue-test* ，如果这个表达式是假的(0)， *for* 语句立即结束，
所以 *body* 只被执行了零次。

然而，如果 *continue-test* 为真(非0)， *for* 语句会执行 *body* ，然后计算 *advance* 。然后，它又循环到 *not-quite-top* (循环开始处)，
再次测试 *continue-test* 。但并不会再次计算start。


** for 语句的例子

下面是迭代式 *Fibonacci* 函数中的for语句：

#+begin_src c
  int i;
  for (i = 1; i < n; ++i)
    /* If n is 1 or less, the loop runs zero times,  */
    /* since i < n is false the first time.  */
    {
      /* Now last is fib (i)
         and prev is fib (i - 1).  */
      /* Compute fib (i + 1).  */
      int next = prev + last;
      /* Shift the values down.  */
      prev = last;
      last = next;
      /* Now last is fib (i + 1)
         and prev is fib (i).
         But that won’t stay true for long,
         because we are about to increment i.  */
    }
#+end_src


在这个例子中， *start* 是 *i = 1* ，意思是把 *i* 设为1。 *continue-test* 是 *i < n* ，意思是只要 *i* 小于 *n* ，就一直重复循环。
 *advance* 是 *i++* ，意思是把 *i* 增加1。函数体是一个块，包含一个声明和两个语句。

** for 表达式的省略

一个完整的 *for* 语句包含所有这些部分：

#+begin_src c
  for (start; continue-test; advance)
    body
#+end_src

但你可以省略括号内的三个表达式中的任何一个。小括号和两个分号在语法上是必须的，但它们之间的表达式可以缺失。
缺少表达式意味着这个循环没有使用for语句的那个特定功能。

你可以不使用start，而是在for语句之前做循环准备：效果是一样的。所以我们可以这样写前面例子的开头：

#+begin_src c
  int i = 0;
  for (; i < n; ++i)
#+end_src

或者这样：

#+begin_src c
  int i;
  for (i = 0; i < n; ++i)
#+end_src 

省略continue-test表示循环将一直运行（或直到其他某些原因导致其退出）。循环内的语句可以测试终止条件，并使用“break;”语句退出。
这种做法更加灵活，因为您可以在循环的任何位置放置这些测试条件，而不仅仅是在循环的开头。

将表达式放在 /advance/ 的地方与将其写在循环体的最后是等价的。唯一的区别是对于continue语句（详见continue语句）。因此，我们也可以这样编写：

#+begin_src c
  for (i = 0; i < n;)
    {
      …
      ++i;
    }
#+end_src

或者这样：

#+begin_src c
  for (i = 0; i < n; ++i)
    {
      …
    }
#+end_src 

选择何种方式的主要意义是那种对于程序员来说更可读。然而，在语法上也有区别： advance是一个表达式，不是一个语句。它不能包括循环、块、声明等。

** for-索引声明

你可以在for-loop的开始部分直接声明循环索引变量，像这样：

#+begin_src c
  for (int i = 0; i < n; ++i)
    {
      …
    }
#+end_src

上面的 /start/ 只有一个声明；你可以声明一个或多个变量，请使用逗号分隔它们，并且确保它们都是同一种基本类型( 在这个例子中是 *int* )：

#+begin_src c
  for (int i = 0, j = 1, *p = NULL; i < n; ++i, ++j, ++p)
    {
      …
    }
#+end_src

这些变量的作用域是 *for* 语句的范围。关于基本类型的解释详见基本类型整洁。

在 *for* 语句中声明的变量应该有初始化器。省略初始化会给变量带来不可预知的初始值，所以这段代码是错误的。

#+begin_src c
  for (int i; i < n; ++i)
    {
      …
    }
#+end_src

** continue 语句

*continue* 语句看起来像 *'continue;'* ，其作用是立即跳到最内层循环结构的末端。如果它是一个 *for-loop* ，
接下来发生的事情就是执行循环的 /advance/ 表达式。

例如，这个循环增加p直到下一个空字符或换行，并且（以某种未显示的方式）对行中的所有字符进行操作，除了空格。它对空格的操作是跳过它们。

#+begin_src c
  for (;*p; ++p)
    {
      /* End loop if we have reached a newline.  */
      if (*p == '\n')
        break;
      /* Pay no attention to spaces.  */
      if (*p == ' ')
        continue;
      /* Operate on the next character.  */
      …
    }
#+end_src

执行'continue;'会跳过循环主体，但不会跳过 /advance/ 表达式p++。

我们也可以这样写：

#+begin_src c
  for (;*p; ++p)
    {
      /* Exit if we have reached a newline.  */
      if (*p == '\n')
        break;
      /* Pay no attention to spaces.  */
      if (*p != ' ')
        {
          /* Operate on the next character.  */
          …
        }
    }
#+end_src

使用 *continue* 的好处是可以减少嵌套的深度。

对比 *continue* 与 *break* 。详见break 语句章节

** switch 语句

*switch* 语句根据一个表达式的值选择要运行的代码。表达式在关键字 *switch* 之后的小括号中。之后所有可能被选择执行的代码都在后面的大括号中，例如：

#+begin_src c
  switch (selector)
    {
      cases…
    }
#+end_src

case 看起来就像：

#+begin_src c
  case value:
    statements
    break;
#+end_src

这样写的意思是"如果选择器的值刚好与 /value/ 相等那么就执行这里的代码"，或者这样(GNU C 的扩展特性)：

#+begin_src c
  case rangestart ... rangeend:
    statements
    break;
#+end_src

这样写的意思是"如果选择器的值刚好在 /rangestart/ 和 /rangeend/ 之间那么就执行这里的代码(包含起始值)" 详见Case范围章节。

*case* 标签中的值必须还原为整数常数。它们可以使用算术和枚举常量，但是它们不能引用内存中的数据，因为它们必须在编译时计算出来。
如果两个 *case* 标签指定了相同的值，或范围重叠，或一个是范围，另一个是该范围内的一个值，这都是错误的。

你也可以定义一个默认 *case* 来处理所有 *case* 以外的其它值。例如：

#+begin_src c
  default:
    statements
    break;
#+end_src

如果switch语句没有default: label，那么当值与任何 *case* 都不匹配时，它不做任何事情。

*switch* 语句中的大括号对是一个块，你可以像在其他块中一样在该作用域内声明变量(详见块章节)。
然而，这些声明中的初始化器不一定会在每次运行switch语句时被执行，所以最好避免在这里进行初始化。

在 *switch* 中的 *break* 会让程序直接从 *switch* 语句中退出。详见break语句章节。

如果在一个 *case* 的代码末尾没有 *break;* ，则继续执行到下一个 *case* 的代码。这种情况更多的是由于程序员的失误导致而不是有意为之，
但由于这个特性可以在实际代码中被使用，我们不能消除它。

*警告* ：当一个 *case* 打算落入下一个 *case* 时，要写一个类似 "落入"的注释，说明这是有意为之的。
这样，其他程序员就不会认为这是一个错误而错误地 "修复"它。

连续的case语句在严谨的角度下可以被视为穿透(falling through)的一种情况，但我们不会将它们视为穿透的情况，因为它们不会让任何人感到困惑。

** switch的例子

下面是一个使用switch语句来区分字符的例子：

#+begin_src c
  struct vp { int vowels, punct; };

  struct vp
  count_vowels_and_punct (char *string)
  {
    int c;
    int vowels = 0;
    int punct = 0;
    /* Don’t change the parameter itself.  */
    /* That helps in debugging.  */
    char *p = string;
    struct vp value;

    while (c = *p++)
      switch (c)
        {
          case 'y':
          case 'Y':
            /* We assume y_is_consonant will check surrounding
                  letters to determine whether this y is a vowel.  */
            if (y_is_consonant (p - 1))
              break;

            /* Falls through */

          case 'a':
          case 'e':
          case 'i':
          case 'o':
          case 'u':
          case 'A':
          case 'E':
          case 'I':
          case 'O':
          case 'U':
            vowels++;
            break;

          case '.':
          case ',':
          case ':':
          case ';':
          case '?':
          case '!':
          case '\"':
          case '\'':
            punct++;
            break;
        }

    value.vowels = vowels;
    value.punct = punct;

    return value;
  }
#+end_src

** 达夫设备

*switch* 语句中的 *case* 可以在其他控制结构内。例如，我们可以使用一种被称为达夫装置的技术来优化这个
拷贝 /from/ 中的字符串到 /to/ 的内存中的简单函数:

#+begin_src c
  void
  copy (char *to, char *from, int count)
  {
    while (count > 0)
      ,*to++ = *from++, count--;
  }
#+end_src

达夫设备的方法包括展开循环，使其每次都复制几个字符，并使用 *switch* 语句在适当的位置进入循环体：

#+begin_src c
  void
  copy (char *to, char *from, int count)
  {
    if (count <= 0)
      return;
    int n = (count + 7) / 8;
    switch (count % 8)
      {
        do {
          case 0: *to++ = *from++;
          case 7: *to++ = *from++;
          case 6: *to++ = *from++;
          case 5: *to++ = *from++;
          case 4: *to++ = *from++;
          case 3: *to++ = *from++;
          case 2: *to++ = *from++;
          case 1: *to++ = *from++;
          } while (--n > 0);
      }
  }
#+end_src

** Case 范围

你可以给一个 *case* 标签指定一个连续的数值范围，例如：

#+begin_src c
  case low ... high:
#+end_src

这与适当数量的单个 *case* 标签具有相同的效果，从低到高，每个整数值都有一个标签，包括起始值。

这个功能对 *case* 中使用ASCII编码范围内的值非常有用：

#+begin_src c
  case 'A' ... 'Z':
#+end_src

*小心* ： 使用整数时，在...周围写上空格，以防止它被错误解析。像这样：

#+begin_src c
  case 1 ... 5:
#+end_src

而不是这样：

#+begin_src c
  case 1...5:
#+end_src

** Null 语句

/null/ 语句就是一个分号，他什么也不做。

空语句是一个占位符，用于在语法上需要一个语句，但没有什么要做的情况下使用。例如，有时for-loop的所有工作都是在 *for-header* 本身完成的，
没有给 *body* 留下任何工作。下面是一个搜索数组中第一个换行的例子：

#+begin_src c
  for (p = array; *p != '\n'; p++)
    ;
#+end_src

* goto 语句与 Labels

*goto* 语句看起来像这样：

#+begin_src c
  goto label;
#+end_src

它的作用是让程序从当前位置即跳转到另外一个位置--另外一个位置由标签(/label/)来定义。

一个普通的标签定义看起来像这样：

#+begin_src c
  label:
#+end_src

而且它可以出现在任何语句之前。你不能用 *default* 作为标签，因为它对 *switch* 语句有特殊意义。

一个普通的标签不需要单独的声明，定义它就足够了。

下面是一个使用goto来实现相当于do-while的循环的例子：

#+begin_src c
  {
   loop_restart:
    body
    if (condition)
      goto loop_restart;
  }
#+end_src

标签的名字空间与变量和函数的名字空间是分开的。因此，变量与标签在同一个作用域内使用同一个名字时不会产生错误的：

#+begin_src c
  {
    int foo;    // Variable foo.
   foo:         // Label foo.
    body
    if (foo > 0)  // Variable foo.
      goto foo;   // Label foo.
  }
#+end_src

块的作用域不会对普通标签产生影响；每个标签名称的作用域都会贯穿整个函数。使用 *goto* 跳入一个块看起来很奇快，但确实可以这样做，例如：

#+begin_src c
  if (x < 0)
    goto negative;
  if (y < 0)
    {
     negative:
      printf ("Negative\n");
      return;
    }
#+end_src

如果 *goto* 跳转到一个变量的作用域内并且在它的初始化语句之后那么变量不会被初始化。例如如果 *x* 是负数：

#+begin_src c
  if (x < 0)
    goto negative;
  if (y < 0)
    {
      int i = 5;
     negative:
      printf ("Negative, and i is %d\n", i);
      return;
    }
#+end_src

上面的代码将会输出随机数值，因为 *int i = 5* 没有被执行。

如果该块声明了一个可变长度的自动数组，跳入它就会产生一个编译错误。然而，跳出变长数组的范围是允许的，并且跳出之后会删除其存储空间。

标签不能直接出现在声明之前，所以代码不能直接跳转到声明之前的标签。例如下面的代码不不被允许的：

#+begin_src c
  {
    goto foo;
  foo:
    ;
    int x = 5;
    bar(&x);
  }
#+end_src

变通的办法是在标签之后增加一条语句，甚至是空语句也可以。例如：

#+begin_src c
  {
    goto foo;
  foo:
    ;
    int x = 5;
    bar(&x);
  }
#+end_src

同样的，标签不能出现在一个块的末尾。变通的办法是相同的：在标签之后增加一个分号。

这些对于标签的不必要的限制是没有意义的，原则上应该取消；但是它们只造成了很少的不便因为使用标签和goto并不是很好的编程风格，所以它们
很少出现在代码中。

以上的例子都是人为可以书写的；不适用 *goto* 的方法看起来更加自然，例如打印 "Negative "的例子的简洁写法是这样的：

#+begin_src c
  if (x < 0 || y < 0)
    {
      printf ("Negative\n");
      return;
    }
#+end_src

很难构建一个简单的例子来说明使用 *goto* 是最佳编程风格。它只会在复杂程序中可以起到良好作用，因此不适合用来在这里解释 *goto* 的作用。

使用goto的唯一好时机是它比任何其他替代方案都更简单的时候。很少需要向后跳转，因为通常其他循环和控制结构可以提供更简单的代码。
使用goto向前跳转更常见，例如当一个函数需要在错误情况下进行一些处理，而错误可能发生在函数的不同位置时。
