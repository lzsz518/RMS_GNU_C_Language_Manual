#+title: 函数定义

我们已经在很多例子中呈现了函数定义，如果你已经阅读到了这里那么你已经基本理解了函数的概念。
尽管如此，使用一整章的篇幅来汇集有关函数的信息仍然使必要的。

* 函数定义

我们已经在很多例子中呈现了函数定义。函数定义的规则总体看开如同下面的例子：

#+begin_src c
    returntype
    functionname (parm_declarations…)
    {
      body
    }
#+end_src

大括号之前的部分被称为函数头。

如果函数没有返回值则使用 /void/ 作为 /returntype/ 。

** 函数参数变量


函数参数变量是在函数内部使用的局部变量（请参阅局部变量），用于存储在调用函数时作为参数传递的值。通常我们简称为“函数参数”或者“参数”，不特别提到它是一个变量的事实。

我们在函数定义的开头，在参数列表中声明这些变量。例如，

#+begin_src c
    fib (int n)
#+end_src

以上函数的参数列表中只有一个参数类型为int的参数--n。

函数参数声明与普通变量声明在几个方面有所不同：

+ 在函数定义的头部，逗号分隔参数声明，每个参数都需要完整的声明，包括类型。例如，如果一个函数 foo 有两个 int 参数，可以这样写：

  #+begin_src c
    foo (int a, int b)
  #+end_src

  你不能在这两个声明之间共享相同的 int 声明：

  #+begin_src c
    foo (int a, b) /* Invalid! */
  #+end_src

+ 函数参数变量在函数调用时被初始化为传递的值，因此它的声明不能指定初始值。

+ 在函数参数声明中写入数组类型会使其声明为指针。指定的数组大小没有任何影响，通常我们省略大小。因此，

  #+begin_src c
    foo (int a[5])
    foo (int a[])
    foo (int *a )
  #+end_src

  是等价的。

+ 参数变量的作用域是整个函数体，尽管它们写在函数头部，而函数头部实际上是在函数体的外部。

  如果一个函数没有参数，那么在其定义中，参数列表为空是最自然的方式。但是，在C语言中，由于历史原因，这样做有着特殊的含义：
  “函数调用时不检查其是否拥有正确的参数个数”。因此，

  #+begin_src c
    int
    foo ()
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  在将 x 作为参数传递给 foo 时，不会报告编译错误。相比之下，

  #+begin_src c
    int
    foo (void)
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  将会报告一个错误，因为 foo 不应该接收任何参数。

** 前置函数声明
在源代码中，函数定义的顺序并不重要，除了每个函数在被使用之前需要被定义或声明之外。

函数的定义同时也为其所在作用域的其余部分声明了该函数的名称。但是如果你想在函数定义之前调用该函数怎么办？为了允许这样做，可以在第一次调用之前编写一个兼容的同名函数声明。这种预示后续定义的声明被称为前向声明（forward declaration）。函数声明可以在顶层或块内，并且在其所在作用域的末尾之前都适用。

** 静态函数
在函数定义中使用关键字 *static* 可以将函数名的可见性限制在当前编译模块中。（这与变量声明中的 static 的作用相同；请参阅文件范围变量。）例如，如果一个编译模块包含以下代码：

#+begin_src c
    static int
    foo (void)
    {
    …
    }
#+end_src

那么该编译模块的代码可以在函数定义之后的任何位置调用 foo，但其他编译模块则无法引用它。

为了在函数定义之前调用 foo，它需要一个前置声明，并且应该使用static，因为函数定义中使用了static。
对于这个函数，前向声明的形式如下：

#+begin_src c
    static int foo (void);
#+end_src

通常明智的做法是在不会从同一编译模块外部调用的函数定义上使用
static。这样可以确保调用不会在其他模块中添加。如果程序员决定更改函数的调用约定，或者理解其使用的所有后果，
他们只需检查同一编译模块中的调用即可。

** 数组参数
在C中，数组不是原生对象：它们无法直接复制。因此，它们不能像其他值一样作为参数传递。请参考C数组的限制。相反，数组参数以一种特殊的方式
工作。

*** 数组参数等于指针

在C中，将函数参数变量声明为数组实际上给它赋予了指针类型。C之所以这样做，如果在函数调用中用作参数使用数组类型的表达式会被自动转换为
指针（指向数组的第一个元素）。如果您将相应的参数声明为“数组”，它将正确接收实际传递给函数的指针值。

这与C语言在访问数组元素时不检查数组边界有关（请参阅访问数组元素）。

例如在下面的函数中：

#+begin_src c
    void
    clobber4 (int array[20])
    {
      array[4] = 0;
    }
#+end_src

参数数组的实际类型是int *；指定的长度20对程序没有影响。您可以省略长度并写成以下形式：

#+begin_src c
    void
    clobber4 (int array[])
    {
    array[4] = 0;
    }
#+end_src

或者可以明确地将参数声明为指针形式：

#+begin_src c
    void
    clobber4 (int *array)
    {
    array[4] = 0;
    }
#+end_src

以上函数定义是等价的。

*** 解析数组参数

函数调用时指针的值被传递给函数，就像C语言中的所有参数值一样。然而，结果是矛盾的，因为数组本身是按引用传递的：
它的内容被视为共享内存——在调用者和被调用函数之间共享。当clobber4给数组的第4个元素赋值时，效果就是修改了调用中指定的数组的第4个元素。

#+begin_src c
#include <stddef.h>  /* Defines NULL. */
#include <stdlib.h>  /* Declares malloc, */
                     /* Defines EXIT_SUCCESS. */

int
main (void)
{
  int data[] = {1, 2, 3, 4, 5, 6};
  int i;

  /* Show the initial value of element 4. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  clobber4 (data);

  /* Show that element 4 has been changed. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  return EXIT_SUCCESS;
}
#+end_src

上面的程序将会显示'0'因为调用clobber4之后data[4]的值被改写为0。

数组data有6个元素，但将其传递给参数类型写为int[20]的函数不会报错，因为它实际上代表的是int*。真正的参数指针并没有携带指向的数组长
度的指示。它也不需要指向数组的开头。例如，

#+begin_src c
clobber4 (data+1);
#+end_src

传递的是一个从data的第1个元素开始的“数组”，其效果是将data[5]清零，而不是data[4]。

如果所有对该函数的调用都将提供一个特定大小的数组，您可以将数组的大小指定为静态大小：

#+begin_src c
void
clobber4 (int array[static 20])
…
#+end_src

将对编译器作出始终以一个包含20个元素的数组作为函数调用时的参数的承诺，这有助于编译器可以优化代码。如果代码违反了这个承诺，并且以一个较短的数组调用该函数，可能会发生不可预测的情况。

*** 在数组参数上使用类型限定符

您可以对数组参数中使用类型限定符const、restrict和volatile，例如：

#+begin_src c
void
clobber4 (volatile int array[20])
…
#+end_src

表示array等同于一个指向volatile int的指针。或者：

#+begin_src c
void
clobber4 (int array[const 20])
…
#+end_src


将数组参数等同于一个指向int的常量指针。如果我们希望clobber4函数成功执行，将以下参数声明是没有意义的：

#+begin_src c
void
clobber4 (const int array[20])
…
#+end_src

这样的写法会告诉编译器参数应该指向一个包含常量int值的数组，那么我们将无法在函数中对array进行赋值。

在具有多个数组参数的函数中，您可以使用restrict关键字告诉编译器每个传入的数组参数都是不同的：

#+begin_src c
void
foo (int array1[restrict 10], int array2[restrict 10])
…
#+end_src

使用restrict关键字向编译器承诺函数调用者不会将同一个数组传递给多个restrict数组参数。了解这一点使得编译器能够进行更好的代码优化。这与使用restrict指针具有相同的效果（参见restrict指针），但在阅读代码时明确表示期望一个特定大小的数组。

** 接受结构体参数的函数

在GNUC中，结构体是原生对象，因此可以以自然的方式将它们用作函数参数和参数。下面是一个名为swapfoo的函数，它接受一个具有两个字段的结构体foo作为参数，并返回一个具有相同类型但字段交换的结构体。

#+begin_src c
struct foo { int a, b; };

struct foo x;

struct foo
swapfoo (struct foo inval)
{
  struct foo outval;
  outval.a = inval.b;
  outval.b = inval.a;
  return outval;
}
#+end_src

这种更简单的swapfoo定义避免了使用一个局部变量来保存即将返回的结果，而是使用结构体构造函数（参见结构体构造函数）来实现，如下所示：

#+begin_src c
struct foo
swapfoo (struct foo inval)
{
  return (struct foo) { inval.b, inval.a };
}
#+end_src

在函数的参数列表中定义结构体类型是有效的，就像下面的例子一样：

#+begin_src c
int
frob_bar (struct bar { int a, b; } inval)
{
  body
}
#+end_src

函数体body可以访问inval的字段，因为整个函数体都定义了结构体类型struct bar。然而，除非通过一些不正规的手段，否则无法创建一个struct  bar参数来传递给frob_bar函数。因此，在实际中，在参数列表中定义结构体类型是没有用的。
