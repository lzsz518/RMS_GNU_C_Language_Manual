#+title: 变量

在C语言程序中只有通过声明才可以让程序知道变量的存在。只有在声明之后，才能使用该变量。在同一作用域内多次声明变量名是错误的；
但有一个例外，即在变量的暂时定义(定义变量时不初始化)时使用extern关键字可以与同一个变量的另一个声明共存。

变量可以在块或文件的任何位置进行声明。（C语言的早期版本要求在块内的所有变量声明都在任何语句之前发生。）


在函数或块内声明的变量是局部变量。这意味着该变量的名称仅在该函数或块的结束之前可用，并且内存空间只在控制流程位于该函数或块内时分配。

在文件的顶层声明的变量称为文件范围变量。它们被分配固定且独立的内存位置，因此在它们的值将在程序的整个执行工程中可用。

* 声明变量

变量声明看起来就像：

#+begin_src c
  keywords basetype decorated-variable [= init];
#+end_src

关键字指定了如何处理变量名的作用域和存储分配。大多数声明没有关键字，因为默认设置对它们来说是正确的。

C允许这些关键字出现在基本类型之前、之后，甚至中间，比如unsigned static int，但不要这样做，
这会让其他程序员感到惊讶。请始终将关键字写在最前面。

基本类型可以是C预定义的任何类型，或者是使用typedef定义的类型关键字。它还可以是结构体标签（struct tag）、
联合体标签（union tag）或枚举标签（enum tag）。此外，它还可以包含类型限定符，如const和volatile（参见类型限定符）。

在普通情况下，声明变量时只使用基本类型修饰变量名，例如：

#+begin_src c
  int foo;
#+end_src

使用int作为基本类型，foo作为修饰过的变量。这将声明类型为int的变量foo。

#+begin_src c
  struct tree_node foo;
#+end_src

声明类型为struct tree_node的变量foo。

** 声明数组与指针

要声明数组变量，使用variable[length]来修饰变量名：

#+begin_src c
  int foo[5];
#+end_src

要声明指针变量，使用*variable来修饰变量名：

#+begin_src c
  struct list_elt *foo
#+end_src

这些结构可以嵌套，例如：

#+begin_src c
  int foo[3][5];
#+end_src

声明foo为有用三个数组每个数组有5个整型元素的数组：

#+begin_src c
  struct list_elt *foo[5];
#+end_src

声明foo为拥有5个结构体类型元素的指针数组，和

#+begin_src c
  struct list_elt **foo;
#+end_src

声明foo为指向结构体的指针的指针。

#+begin_src c
  int **(*foo[30])(int, double);
#+end_src

声明foo为一个包含30个指向函数的指针的数组（参见函数指针），每个函数都必须接受两个参数（一个int和一个double），并返回类型为int**。

#+begin_src c
  void
  bar (int size)
  {
    int foo[size];
    …
      }
#+end_src

在函数bar被调用时，声明foo为一个大小在运行时指定的整数数组。

** 合并变量声明

当多个声明具有相同的关键字和基本类型时，可以使用逗号将它们组合在一起。因此，

#+begin_src c
  keywords basetype
    decorated-variable-1 [= init1],
    decorated-variable-2 [= init2];
#+end_src

相当于

#+begin_src c
  keywords basetype
     decorated-variable-1 [= init1];
  keywords basetype
     decorated-variable-2 [= init2];
#+end_src

一些简单的例子：

#+begin_src c
  int a, b;
  int a = 1, b = 2;
  int a, *p, array[5];
  int a = 0, *p = &a, array[5] = {1, 2};
#+end_src

在最后两个例子中，a是一个int，p是一个指向int的指针，array是一个包含5个int的数组。
由于数组的初始化器只指定了两个元素，其他三个元素将被初始化为零。

* 初始化

除了使用extern关键字声明变量之外，还应指定其初始值。对于数值和指针类型的变量，初始化器是一个具有值的表达式。
如果需要，它将转换为变量的类型，就像在赋值语句中一样。

你也可以使用一个具有相同类型的表达式的值种方式初始化本地的结构体类型（参见结构体）或联合体类型（参见联合体）变量。
但是你不能以这种方式初始化数组（参见数组），因为在C中数组不是一级对象（参见C数组的限制），并且没有数组赋值操作。

你可以逐个成员地初始化数组和结构体，使用一个元素或组件的列表。你可以使用联合体的任意一个成员来初始化联合体。

 * 数组的逐个成员初始化器由以 '{...}' 包围的元素值组成。如果初始化器中的值没有覆盖数组中的所有元素，剩余的元素将被初始化为零。
   在声明数组时，你可以省略数组的大小，并让初始化器指定大小：

#+begin_src c
  int array[] = { 3, 9, 12 };
#+end_src

 * 对于结构体，逐个成员的初始化器由以 '{...}' 包围的字段值组成。按照结构体中字段的声明顺序编写字段值。
   如果初始化器中的值没有覆盖结构体中的所有字段，剩余的字段将被初始化为零

 * 联合体类型变量的初始化器形式为 { value }，其中 value 初始化联合体定义中的第一个成员。

对于数组的数组、包含数组的结构体、结构体数组等，这些结构都可以嵌套。例如，

#+begin_src c
  struct point { double x, y; };

  struct point series[]
    = { {0, 0}, {1.5, 2.8}, {99, 100.0004} };
#+end_src

如果内部的一对花括号中包含了正确数量的元素来初始化子值，你可以省略这对花括号，这样就不需要用零填充任何元素或字段。
但是不要经常这样做，因为它容易让人混淆。

可以使用字符串常量初始化char数组。请记住，字符串常量在末尾包含一个隐式的空字符（参见字符串常量）。
使用字符串常量作为初始化器意味着将其内容作为数组元素的初始值。例如：

#+begin_src c
  char text[6] = "text!";     /* Includes the null. */
  char text[5] = "text!";     /* Excludes the null. */
  char text[] = "text!";      /* Gets length 6. */
  char text[]
    = { 't', 'e', 'x', 't', '!', 0 };  /* same as above. */
  char text[] = { "text!" };  /* Braces are optional. */
#+end_src 

这种类型的初始化器可以嵌套在花括号内，以初始化包含char数组的结构体或数组。

同样地，你可以使用宽字符串常量来初始化wchar_t数组。

* 指定初始化器

在复杂的结构体或长数组中，指定初始化器可以很有用，可以指示我们正在初始化哪个字段或元素。

要在初始化过程中指定特定的数组元素，可以在方括号中包含数组索引，并为每个元素使用赋值运算符：

#+begin_src c
  int foo[10] = { [3] = 42, [7] = 58 };
#+end_src

以下声明与上面的效果相同：

#+begin_src c
  int foo[10] = { 0, 0, 0, 42, 0, 0, 0, 58, 0, 0 };
#+end_src

在数组初始化中，可以将非指定元素值与指定的索引一起包含；它们按照数组初始化的预期顺序进行排序，这样就能确保正确的对应关系。因此，

#+begin_src c
  int foo[10] = { [3] = 42, 43, 44, [7] = 58 };
#+end_src

与下面的声明效果相同：

#+begin_src c
  int foo[10] = { 0, 0, 0, 42, 43, 44, 0, 58, 0, 0 };
#+end_src

请注意，你只能使用常量表达式作为数组索引值，而不能使用变量。

如果你需要将顺序数组的子序列初始化为相同的值，你可以指定一个范围：

#+begin_src c
  int foo[100] = { [0 ... 19] = 42, [20 ... 99] = 43 };
#+end_src

使用范围初始化是GNU C自己的扩展。

当子序列范围重叠时，每个元素都由适用于它的最后一个指定值进行初始化。因此，这种初始化与之前的初始化是等价的。

#+begin_src c
  int foo[100] = { [0 ... 99] = 43, [0 ... 19] = 42 };
#+end_src

第二次赋值覆盖了第一次赋值中从0到第19个元素的值。

对于数组使用范围初始化时仅对赋值表达式的值进行一次计算，因此下面的代码：

#+begin_src c
  int random_values[100]
    = { [0 ... 99] = get_random_number() };
#+end_src

会将数组random_values的所有100个元素都初始化为相同的值，这很可能不是期望的结果。

同样地，你可以通过指定以点号开头的字段名来初始化结构体变量的特定字段：

#+begin_src c
  struct point { int x; int y; };

  struct point foo = { .y = 42; };
#+end_src

这样的语法也适用于联合体：

#+begin_src c
  union int_double { int i; double d; };

  union int_double foo = { .d = 34 };
#+end_src

这将整数值34转换为double类型，并将其存储在联合变量foo中。

你可以在同一初始化过程中指定数组元素和结构体元素；例如，这是一个点结构体数组的示例：

#+begin_src c
  struct point point_array[10] = { [4].y = 32, [6].y = 39 };
#+end_src

