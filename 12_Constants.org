#+title: 12 常数

常数是显式呈现恒定值的表达式。C语言允许的常量类型有数值，字符和字符串。前面已经使用过数值和字符串常量。

** 整型常数

整型常数是一个指定的数值并且通过字符后缀指定常量为哪种类型的整数。

最简单的整型常数是十进制数字，例如 5，77，403。十进制整型常数不能以字符'0'开始因为这让它变成八进制数。

你可以给整型常数前面加上负号让它变成一个负数。从语法上讲这将使其成为一个算术表达式而不是常量，但是它
的行为和真正的常数一样。

常数也能以八进制，十六进和二进制形式表示。八进制常量以字符'0'作为前缀，之后是任意数量的八进制数('0'--'7'):

#+begin_src c
  0      // zero
  077    // 63
  0403   // 259
#+end_src

如果非要咬文嚼字，常数 *0* 是一个八进制常数，但是也可以认为它是一个十进制常数，尽管不论那种进制它的值都是相同的。

十六进制常量以字符'0x'(x 大小写均可)作为前缀，之后是任意十六进制数('0'--'9','a'--'f'大小写均可)：

#+begin_src c
  0xff   // 255
  0XA0   // 160
  0xffFF // 65535
#+end_src

二进制常数以字符'0b'(大小写均可)，之后是任意二进制数('0'--'1')：

#+begin_src c
  0b101   // 5
#+end_src

二进制常数仅仅被GNU C支持，它并不被标准C支持。

有些时候整型常数后面需要一个空格以防止与后续标记产生歧义。详情请见非法数值。

** 整型常数类型

一般情况下如果整型常数的大小适合与 *int* 型那么这就是它的类型，但是对于如何决定类型仍然存在完整的规则。
一个整型常数的类型是一下列表中第一个可以正确存储该值的类型：

 1. int
 1. unsigned int
 1. long int
 1. unsigned long int
 1. long long int
 1. unsigned long long int

对以上列表还有下面的例外规则：

 * 如果常数后缀为'l'或'L'，忽略列表前两项
 * 如果常数后缀为'll'或'LL'，忽略列表前四项
 * 如果常数后缀为'u'或'U'，忽略所有有符号项
 * 如果常数是十进制的，忽略无符号项

例如：

#+begin_src c
  3000000000u      // three billion as unsigned int.
  0LL              // zero as a long long int.
  0403l            // 259 as a long int.
#+end_src 

整型常数中的后缀很少使用。当类型的精确性很重要时使用显示类型转换是明智的选择。详情请见显示类型准换与整数类型章节。


** 浮点常数

浮点数常量必须有一个小数点或一个十的指数又或两者兼备；它们是辨别整型常数还是浮点常数的标志。

'e'或'E'加上随后的数字表示指数。指数总是使用十进制数字，它前面还可以加正负号。指数 /n/ 的意义是将常数乘以10的
n次方。

因此，'1500.0'，'15e2'，'15e+2'，'1.5e+3'，'.15e4'，与 '15000e-1' 的值都等于1500。

使用小数点的例子：

#+begin_src c
  1.0
  1000.
  3.14159
  .05
  .0005
#+end_src

对于以上数值这里是一些等价表示法：

#+begin_src c
  1e0, 1.0000e0
  100e1, 100e+1, 100E+1, 1e3, 10000e-1
  3.14159e0
  5e-2, .0005e+2, 5E-2, .0005E2
    .05e-2
#+end_src

通常情况下浮点常数的类型是 *double* 。但是你可以通过后缀'f'或'F'指定它们为 *float* ：

#+begin_src c
  3.14159f
  3.14159e0f
  1000.f
  100E1F
  .0005f
  .05e-2f
#+end_src

同样的，后缀'l'或'L'强制指定类型为 *long double* 。

你也可以在十六进制浮点数中使用指数，但是因为'e'属于十六进制数的基数所以需要使用'p'或'P'(意为'power')来代替它。

十六进制常数中的指数可以是有符号的十进制整数，指数在这里的底数是2而不是10或16。

例如：

#+begin_src c
0xAp2        // 40 in decimal
0xAp-1       // 5 in decimal
0x2.0Bp4     // 16.75 decimal
0xE.2p3      // 121 decimal
0x123.ABCp0  // 291.6708984375 in decimal
0x123.ABCp4  // 4666.734375 in decimal
0x100p-8     // 1
0x10p-4      // 1
0x1p+4       // 16
0x1p+8       // 256
#+end_src

详情请见浮点数数据类型章节

** 虚数常数

复数由实部和虚部组成。(其中一个或两个部分都可以为零)。本节说明如何用虚数值书写复数常数。
通过将这些添加到普通的实数值常数，我们可以创建具有复数值的常量。

书写虚数常量的简单方法是给整数或浮点常量添加后缀'i'或'I'，或'j'或'J'。 例如，2.5fi 的类型为 _Complex float，
而 3i 的类型为 _Complex int。 四个后缀字母都是等价的。

另一种数写虚常数的方法是将实常数乘以 _Complex_I，它表示虚数 i。 标准 C 不支持后缀为'i'或'j'，因此需要这种笨拙的方式。

要书写具有非零实部和非零虚部的复数常数，请分别书写并添加它们，如下所示：

#+begin_src c
  4.0 + 3.0i
#+end_src

这将赋予 4+3i *_Complex double* 。

如同求和时可以使用0个或多个实数常数，同样的也可以使用0个或多个虚数常数：

#+begin_src c
  _Complex double foo, bar, quux;
  foo = 2.0i + 4.0 + 3.0i; /* Imaginary part is 5.0. */
  bar = 4.0 + 12.0; /* Imaginary part is 0.0. */
  quux = 3.0i + 15.0i; /* Real part is 0.0. */
#+end_src

详情请见复数数据类型。

** 非法数值

在预处理指令中，一些不是真正有效的数字常数的类似数字的结构被视为数字。 如果这些结构出现在预处理之外，
它们就是错误的。 请参阅预处理标记。

有时我们需要插入空格来分隔标记，这样它们就不会组合成一个类似数字的结构。 例如，0xE+12 是一个预处理数字，
它不是一个有效的数字常量，因此它是一个语法错误。 如果我们想要的是 0xE + 12 这三个标记，我们必须使用这些空格作为分隔符。

** 字符常数

单引号之内的字符被成为字符常数，例如'c'。在这个简单的例子中 /c/ 是最终被显示的单一ASCII字符。字符常数的类型是 *int* ,
它的值是对应的ASCII码。例如，呈现字符'a'的字符常数的值是97。

要将'''(单引号)作为字符常量需要使用反斜杠('\')来引用它，写出来就是：'\''。这个以反斜杠开始的序列被称为转义序列，
反斜杠在这里作为转移字符是使用。

要将'\'(反斜杠)作为字符常量需要使用他自己引用它。写出来就是：'\\'。

以下是字符常数中的所有转义序列。 显示的数值是相应的 ASCII 字符代码，为十进制数。

#+begin_src c
  '\a' ⇒ 7       /* alarm, CTRL-g */
  '\b' ⇒ 8       /* backspace, BS, CTRL-h */
  '\t' ⇒ 9       /* tab, TAB, CTRL-i */
  '\n' ⇒ 10      /* newline, CTRL-j */
  '\v' ⇒ 11      /* vertical tab, CTRL-k */
  '\f' ⇒ 12      /* formfeed, CTRL-l */
  '\r' ⇒ 13      /* carriage return, RET, CTRL-m */
  '\e' ⇒ 27      /* escape character, ESC, CTRL-[ */
  '\\' ⇒ 92      /* backslash character, \ */
  '\'' ⇒ 39      /* singlequote character, ' */
  '\"' ⇒ 34      /* doublequote character, " */
  '\?' ⇒ 63      /* question mark, ? */
#+end_src

'\e' 是GNU C的扩展，要兼容标准C请使用 '\33'。

也可以使用八进制和十六进制的字符代码例如：'\otcalcode'或'\xhexcode'。十进制并不是唯一选择，八进制并不需要以'0'前缀开始。

字符常数是 *int* 类型。然而字符的值却被初始化成 *char* 类型，然后转换成 *int* 。如果字符值大于127(八进制数0177)，那么
对于 *char* 类型为8比特有符号数的平台转换的结果在 *int* 中有可能是负数。
