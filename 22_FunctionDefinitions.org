#+title: 函数定义

我们已经在很多例子中呈现了函数定义，如果你已经阅读到了这里那么你已经基本理解了函数的概念。
尽管如此，使用一整章的篇幅来汇集有关函数的信息仍然使必要的。

* 函数定义

我们已经在很多例子中呈现了函数定义。函数定义的规则总体看开如同下面的例子：

#+begin_src c
    returntype
    functionname (parm_declarations…)
    {
      body
    }
#+end_src

大括号之前的部分被称为函数头。

如果函数没有返回值则使用 /void/ 作为 /returntype/ 。

** 函数参数变量


函数参数变量是在函数内部使用的局部变量（请参阅局部变量），用于存储在调用函数时作为参数传递的值。通常我们简称为“函数参数”或者“参数”，不特别提到它是一个变量的事实。

我们在函数定义的开头，在参数列表中声明这些变量。例如，

#+begin_src c
    fib (int n)
#+end_src

以上函数的参数列表中只有一个参数类型为int的参数--n。

函数参数声明与普通变量声明在几个方面有所不同：

+ 在函数定义的头部，逗号分隔参数声明，每个参数都需要完整的声明，包括类型。例如，如果一个函数 foo 有两个 int 参数，可以这样写：

  #+begin_src c
    foo (int a, int b)
  #+end_src

  你不能在这两个声明之间共享相同的 int 声明：

  #+begin_src c
    foo (int a, b) /* Invalid! */
  #+end_src

+ 函数参数变量在函数调用时被初始化为传递的值，因此它的声明不能指定初始值。

+ 在函数参数声明中写入数组类型会使其声明为指针。指定的数组大小没有任何影响，通常我们省略大小。因此，

  #+begin_src c
    foo (int a[5])
    foo (int a[])
    foo (int *a )
  #+end_src

  是等价的。

+ 参数变量的作用域是整个函数体，尽管它们写在函数头部，而函数头部实际上是在函数体的外部。

  如果一个函数没有参数，那么在其定义中，参数列表为空是最自然的方式。但是，在C语言中，由于历史原因，这样做有着特殊的含义：
  “函数调用时不检查其是否拥有正确的参数个数”。因此，

  #+begin_src c
    int
    foo ()
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  在将 x 作为参数传递给 foo 时，不会报告编译错误。相比之下，

  #+begin_src c
    int
    foo (void)
    {
      return 5;
    }

    int
    bar (int x)
    {
      return foo (x);
    }
  #+end_src

  将会报告一个错误，因为 foo 不应该接收任何参数。

** 前置函数声明
在源代码中，函数定义的顺序并不重要，除了每个函数在被使用之前需要被定义或声明之外。

函数的定义同时也为其所在作用域的其余部分声明了该函数的名称。但是如果你想在函数定义之前调用该函数怎么办？为了允许这样做，可以在第一次调用之前编写一个兼容的同名函数声明。这种预示后续定义的声明被称为前向声明（forward declaration）。函数声明可以在顶层或块内，并且在其所在作用域的末尾之前都适用。

** 静态函数
在函数定义中使用关键字 *static* 可以将函数名的可见性限制在当前编译模块中。（这与变量声明中的 static 的作用相同；请参阅文件范围变量。）例如，如果一个编译模块包含以下代码：

#+begin_src c
    static int
    foo (void)
    {
    …
    }
#+end_src

那么该编译模块的代码可以在函数定义之后的任何位置调用 foo，但其他编译模块则无法引用它。

为了在函数定义之前调用 foo，它需要一个前置声明，并且应该使用static，因为函数定义中使用了static。
对于这个函数，前向声明的形式如下：

#+begin_src c
    static int foo (void);
#+end_src

通常明智的做法是在不会从同一编译模块外部调用的函数定义上使用
static。这样可以确保调用不会在其他模块中添加。如果程序员决定更改函数的调用约定，或者理解其使用的所有后果，
他们只需检查同一编译模块中的调用即可。

** 数组参数
在C中，数组不是原生对象：它们无法直接复制。因此，它们不能像其他值一样作为参数传递。请参考C数组的限制。相反，数组参数以一种特殊的方式
工作。

*** 数组参数等于指针

在C中，将函数参数变量声明为数组实际上给它赋予了指针类型。C之所以这样做，如果在函数调用中用作参数使用数组类型的表达式会被自动转换为
指针（指向数组的第一个元素）。如果您将相应的参数声明为“数组”，它将正确接收实际传递给函数的指针值。

这与C语言在访问数组元素时不检查数组边界有关（请参阅访问数组元素）。

例如在下面的函数中：

#+begin_src c
    void
    clobber4 (int array[20])
    {
      array[4] = 0;
    }
#+end_src

参数数组的实际类型是int *；指定的长度20对程序没有影响。您可以省略长度并写成以下形式：

#+begin_src c
    void
    clobber4 (int array[])
    {
    array[4] = 0;
    }
#+end_src

或者可以明确地将参数声明为指针形式：

#+begin_src c
    void
    clobber4 (int *array)
    {
    array[4] = 0;
    }
#+end_src

以上函数定义是等价的。

*** 解析数组参数

函数调用时指针的值被传递给函数，就像C语言中的所有参数值一样。然而，结果是矛盾的，因为数组本身是按引用传递的：
它的内容被视为共享内存——在调用者和被调用函数之间共享。当clobber4给数组的第4个元素赋值时，效果就是修改了调用中指定的数组的第4个元素。

#+begin_src c
#include <stddef.h>  /* Defines NULL. */
#include <stdlib.h>  /* Declares malloc, */
                     /* Defines EXIT_SUCCESS. */

int
main (void)
{
  int data[] = {1, 2, 3, 4, 5, 6};
  int i;

  /* Show the initial value of element 4. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  clobber4 (data);

  /* Show that element 4 has been changed. */
  for (i = 0; i < 6; i++)
    printf ("data[%d] = %d\n", i, data[i]);

  printf ("\n");

  return EXIT_SUCCESS;
}
#+end_src

上面的程序将会显示'0'因为调用clobber4之后data[4]的值被改写为0。

数组data有6个元素，但将其传递给参数类型写为int[20]的函数不会报错，因为它实际上代表的是int*。真正的参数指针并没有携带指向的数组长
度的指示。它也不需要指向数组的开头。例如，

#+begin_src c
clobber4 (data+1);
#+end_src

传递的是一个从data的第1个元素开始的“数组”，其效果是将data[5]清零，而不是data[4]。

如果所有对该函数的调用都将提供一个特定大小的数组，您可以将数组的大小指定为静态大小：

#+begin_src c
void
clobber4 (int array[static 20])
…
#+end_src

将对编译器作出始终以一个包含20个元素的数组作为函数调用时的参数的承诺，这有助于编译器可以优化代码。如果代码违反了这个承诺，并且以一个较短的数组调用该函数，可能会发生不可预测的情况。

*** 在数组参数上使用类型限定符

您可以对数组参数中使用类型限定符const、restrict和volatile，例如：

#+begin_src c
void
clobber4 (volatile int array[20])
…
#+end_src

表示array等同于一个指向volatile int的指针。或者：

#+begin_src c
void
clobber4 (int array[const 20])
…
#+end_src


将数组参数等同于一个指向int的常量指针。如果我们希望clobber4函数成功执行，将以下参数声明是没有意义的：

#+begin_src c
void
clobber4 (const int array[20])
…
#+end_src

这样的写法会告诉编译器参数应该指向一个包含常量int值的数组，那么我们将无法在函数中对array进行赋值。

在具有多个数组参数的函数中，您可以使用restrict关键字告诉编译器每个传入的数组参数都是不同的：

#+begin_src c
void
foo (int array1[restrict 10], int array2[restrict 10])
…
#+end_src

使用restrict关键字向编译器承诺函数调用者不会将同一个数组传递给多个restrict数组参数。了解这一点使得编译器能够进行更好的代码优化。这与使用restrict指针具有相同的效果（参见restrict指针），但在阅读代码时明确表示期望一个特定大小的数组。

** 接受结构体参数的函数

在GNUC中，结构体是原生对象，因此可以以自然的方式将它们用作函数参数和参数。下面是一个名为swapfoo的函数，它接受一个具有两个字段的结构体foo作为参数，并返回一个具有相同类型但字段交换的结构体。

#+begin_src c
struct foo { int a, b; };

struct foo x;

struct foo
swapfoo (struct foo inval)
{
  struct foo outval;
  outval.a = inval.b;
  outval.b = inval.a;
  return outval;
}
#+end_src

这种更简单的swapfoo定义避免了使用一个局部变量来保存即将返回的结果，而是使用结构体构造函数（参见结构体构造函数）来实现，如下所示：

#+begin_src c
struct foo
swapfoo (struct foo inval)
{
  return (struct foo) { inval.b, inval.a };
}
#+end_src

在函数的参数列表中定义结构体类型是有效的，就像下面的例子一样：

#+begin_src c
int
frob_bar (struct bar { int a, b; } inval)
{
  body
}
#+end_src

函数体body可以访问inval的字段，因为整个函数体都定义了结构体类型struct bar。然而，除非通过一些不正规的手段，否则无法创建一个struct  bar参数来传递给frob_bar函数。因此，在实际中，在参数列表中定义结构体类型是没有用的。

* 函数声明

要调用一个函数或者将其名称作为指针必须在其之前对函数名进行 /声明/ 。函数的定义同时也为其所在作用域的其余部分声明了该函数的名称，但是如果你想在函数定义之前调用该函或者从其他编译模块调用它那么必须先进行单独的函数声明。

函数声明看起来像函数定义的开始。它以返回值类型（如果没有，则为void）和函数名开头，后面跟着括号中的参数声明（尽管有时可以省略这些参数声明）。但相似之处就到此为止了：声明部分不包含函数体，而是使用分号结束。

指定参数类型的声明称为函数原型（function prototype）。您可以包含参数名称，也可以省略它们。如果在声明中包含参数名称，它们不会起到任何作用，但可以作为文档说明。

这种形式的原型指定了固定的参数类型：

#+begin_src c
rettype function (argtypes…);
#+end_src

这种形式表示函数不接受任何参数：

#+begin_src c
rettype function (void);
#+end_src

这种形式为某些参数声明了类型，并允许使用未指定类型的额外参数：

#+begin_src c
rettype function (argtypes…, ...);
#+end_src

对于长度可变的数组参数，您可以在数组通常应该放置“长度”的位置上使用 '*' 来编写它的声明；例如，以下声明是等价的。

#+begin_src c
double maximum (int n, int m, double a[n][m]);
double maximum (int n, int m, double a[*][*]);
double maximum (int n, int m, double a[ ][*]);
double maximum (int n, int m, double a[ ][m]);
#+end_src

旧式的声明形式，不是一个原型，它不指定参数的类型或数量：

*警告：* 传递给没有原型声明的函数的参数将使用默认参数提升进行转换（参见参数提升）。同样，对于类型未指定的额外参数也是如此

函数声明通常写在源文件的顶层，但您也可以将它们放在代码块内部。这样，函数名在包含范围的其余部分都是可见的。例如：

#+begin_src c
void
foo (char *file_name)
{
  void save_file (char *);
  save_file (file_name);
}
#+end_src

如果代码的其他部分尝试调用save_file函数，那么这个声明在那里将不会生效。因此，该函数将获得隐式声明，形式为extern int save_file ();。这与此处的显式声明冲突，导致差异产生警告。

传统上，C的语法允许在函数声明中省略数据类型，如果该声明指定了存储类或限定符。此时，类型默认为int。例如：

#+begin_src c
static foo (double x);
#+end_src

默认将返回类型设定为int。这是不好的实践；如果您看到这种情况，请进行修正。

调用一个未声明的函数将在最内层的包含范围中创建一个隐式声明，相当于以下声明形式：

#+begin_src c
extern int function ();
#+end_src

这个声明表示该函数返回int类型，但未指定其参数类型。如果这不准确地描述了函数本身，那么程序需要一个带有参数类型的显式声明才能正确地调用它。

隐式声明已经被弃用，因此创建隐式声明的函数调用会引发警告。

* 函数调用

在程序启动时，会自动调用名为main的函数（请参阅主函数）。除此之外，函数除非被调用，否则不会执行任何操作。
函数被调用发生在指定该函数的函数调用表达式执行期间。

函数调用表达式看起来就像：

#+begin_src
function (arguments…)
#+end_src

大多数情况下，/function/ 是一个函数名。然而，它也可以是具有函数指针值的表达式；
这样，程序可以在运行时确定要调用哪个函数。

/arguments/ 是由逗号分隔的一系列表达式。每个表达式指定一个要传递给函数的参数。

函数调用中的参数列表看起来就像使用逗号运算符（请参阅逗号运算符）一样，但当他们出现在括号之中便具有了不同的含义。

这是一个函数调用的示例，摘自一个接近本书开头的例子（请参阅完整程序）。

#+begin_src c
printf ("Fibonacci series item %d is %d\n",
        19, fib (19));
#+end_src

对于printf函数，给定的三个参数是一个常量字符串、整数19以及fib(19)返回的整数。

* 函数调用语义

函数调用的含义是计算指定的参数表达式，根据函数的声明将它们的值进行转换，然后运行函数，并将转换后的值的副本传递给函数。（这种参数传递的方法被称为按值调用。）当函数执行完成时，它返回的值将成为函数调用表达式的值。


按值调用意味着对函数参数变量的赋值对调用者没有直接影响。例如，

#+begin_src c
#include <stdlib.h>  /* Defines EXIT_SUCCESS. */
#include <stdio.h>   /* Declares printf. */

void
subroutine (int x)
{
  x = 5;
}

void
main (void)
{
  int y = 20;
  subroutine (y);
  printf ("y is %d\n", y);
  return EXIT_SUCCESS;
}
#+end_src

打印的结果是 "y is 20"。调用子程序会将 x 初始化为 y 的值，但这不会建立两个变量之间的任何其他关系。因此，在子程序内部对 x 的赋值只会改变该变量 x。

如果函数的声明指定了参数的类型，函数调用将尽可能将参数表达式转换为该类型。如果转换不可能，则会产生错误。

如果函数的声明没有指定该参数的类型，那么将应用默认的参数提升规则。参见参数提升（Argument Promotions）。

* 函数指针

函数名指的是一个固定的函数。有时候，在运行时再确定该调用哪个函数非常有用；为了实现这一点，可以使用指向所选函数的函数指针值（请参阅指针）。  

可以使用函数指针这种数据类型声明其他数据，包括数组元素、结构体字段和联合体的成员。它们还可以用于函数参数和返回值。
这些类型有一个特点，就是它们永远不会自动转换为void *，反之亦然。然而，您可以通过强制类型转换来进行这种转换。

** 声明函数指针

函数指针变量（或结构字段）的声明几乎与函数声明相似，只是在变量名之前多了一个额外的"*"。正确的嵌套需要在它们周围加上一对括号。
例如，int (a) (); 的意思是："声明a为一个指针，使得a是一个返回int的函数。"

对比以下三个声明：

#+begin_src c
/* 声明一个返回 char * 的函数.  */
char *a (char *);
/* 声明一个指向返回 char 的函数的函数指针.  */
char (*a) (char *);
/* 声明一个指向返回 char * 的函数的函数指针.  */
char *(*a) (char *);
#+end_src

函数指针所指向的函数的参数类型与函数声明中的参数类型相同。您可以编写一个原型，指定所有的参数类型：

#+begin_src c
rettype (*function) (arguments…);
#+end_src


或者可以编写一个指定了一部分参数类型并将其余部分保留为未指定的原型：

#+begin_src c
rettype (*function) (arguments…, ...);
#+end_src

或者声明为无参数形式：

#+begin_src c
rettype (*function) (void);
#+end_src

您还可以编写一个非原型声明，其中不指定参数类型：

#+begin_src c
rettype (*function) ();
#+end_src

例如，这是一个变量声明，它应该指向某个对两个双精度浮点数执行算术操作的函数：

#+begin_src c
double (*binary_op) (double, double);
#+end_src

结构体字段、联合体成员和数组元素可以是函数指针，参数变量也可以是函数指针。函数指针声明结构还可以与其他允许在声明中使用的运算符结合使用。例如，

声明foo为一个指向返回类型为int **的函数的指针，并且：
#+begin_src c
int **(*foo)();
#+end_src

声明foo为一个包含30个指向返回类型为int **的函数指针的数组，可以这样写：

#+begin_src c
int **(*foo[30])();
#+end_src

声明foo为一个指向指向返回类型为int **的函数的指针的指针，可以这样写

#+begin_src c
int **(**foo)();
#+end_src

** 函数指针赋值

假设我们已经像上一节中声明了变量binary_op，给它赋值需要一个合适的函数。因此，让我们定义一个适合让该变量指向的函数。下面是一个例子：

#+begin_src c
double
double_add (double a, double b)
{
  return a+b;
}
#+end_src

现在我们可以给它赋一个值：

#+begin_src c
binary_op = double_add;
#+end_src

函数指针的目标类型必须与函数的类型向上兼容（请参阅兼容类型）。

在double_add前面不需要加上'&'。使用函数名（例如double_add）作为表达式会自动将其转换为函数的地址，
并具有适当的函数指针类型。然而，如果您认为使用'&'更清晰，也可以使用它：

#+begin_src c
binary_op = &double_add;
#+end_src

** 通过数指针调用函数

要调用由函数指针指定的函数，只需在函数调用中写入函数指针的值。例如，以下是对binary_op指向的函数进行调用的示例：

#+begin_src c
binary_op (x, 5)
#+end_src

由于binary_op的数据类型明确指定了参数的类型为double，因此调用会将x和5转换为double类型。

函数调用在概念上对指针binary_op进行解引用，以获取它所指向的函数，并调用该函数。如果您愿意，可以通过写入*运算符来明确表示解引用操作：

#+begin_src c
(*binary_op) (x, 5)
#+end_src


'*'提醒代码阅读者binary_op是一个函数指针，而不是特定函数的名称。

* main 函数

每个完整的可执行程序至少需要一个函数，称为 *main* 函数，这是程序执行的起点。虽然你不必显式声明main函数，
但GNU C允许你这样做。根据惯例，main函数应该定义为遵循以下调用约定之一：

#+begin_src c
int main (void) {…}
int main (int argc, char *argv[]) {…}
int main (int argc, char *argv[], char *envp[]) {…}
#+end_src

在参数列表中使用void表示main函数不使用参数。你可以使用char **argv而不是char *argv[]，对于envp也是一样，
因为这两种写法是等价的。

你可以从C代码中调用main函数，就像调用其他函数一样，尽管这种做法很不常见。
当你这样做时，你必须编写调用语句来传递与main函数定义中的参数匹配的参数。

实际上，当程序启动时，main函数并不是第一个执行的代码。事实上，第一个执行的代码是来自文件crt0.o的系统代码。
在Unix系统中，这是手写的汇编代码，但在GNU系统中，我们用C代码替代了它。它的任务是找到main函数的参数并调用它。

** main 函数的返回值

当main函数返回时，进程终止。main函数返回的任何值都成为退出状态，并报告给父进程。
尽管在名义上返回值的类型是int，但实际上退出状态被截断为8位；如果main函数返回值为256，退出状态为0。


通常，程序只返回两个值中的一个：0表示成功，1表示失败。为了最大的可移植性，可以使用在stdlib.h中定义的宏值
*EXIT_SUCCESS* 和 *EXIT_FAILURE* 。以下是一个示例：

#+begin_src c
#include <stdlib.h>  /* Defines EXIT_SUCCESS */
                     /* and EXIT_FAILURE. */

int
main (void)
{
  …
  if (foo)
    return EXIT_SUCCESS;
  else
    return EXIT_FAILURE;
}
#+end_src

某些类型的程序为不同的返回值约定固定的含义；例如，包括cmp和diff在内的比较程序返回1表示不匹配，返回2表示无法执行比较。

** 访问命令行参数

如果程序通过命令行参数被调用，它可以通过main函数的参数argc和argv来访问这些参数。
（你可以为这些参数取任意名称，但通常使用argc和argv这两个名称。）

参数argv是一个包含所有命令行参数的字符串数组，其中第一个字符串是调用命令的名称。参数argc是一个整数，
表示argv包含的字符串数量。下面是一个示例，演示如何访问命令行参数，获取程序的名称，并检查标准的--version和--help选项：

#+begin_src c
#include <string.h> /* Declare strcmp. */

int
main (int argc, char *argv[])
{
  char *program_name = argv[0];

  for (int i = 1; i < argc; i++)
    {
      if (!strcmp (argv[i], "--version"))
        {
          /* Print version information and exit. */
          …
        }
      else if (!strcmp (argv[i], "--help"))
        {
          /* Print help information and exit. */
          …
        }
    }
  …
}
#+end_src

** 访问环境变量

你可以选择在main函数中包含第三个参数，即另一个字符串数组，用于获取程序可用的环境变量。
与argv不同，这里没有额外的参数来表示环境变量的数量；相反，环境变量数组以空指针结尾。

#+begin_src c
#include <stdio.h>   /* Declares printf. */

int
main (int argc, char *argv[], char *envp[])
{
  /* Print out all environment variables. */
  int i = 0;
  while (envp[i])
    {
      printf ("%s\n", envp[i]);
      i++;
    }
}
#+end_src

另一种检索环境变量的方法是使用在stdlib.h中定义的库函数getenv。使用getenv不需要定义main函数来接受envp指针。
例如，下面是一个获取并打印用户的主目录（如果定义的话）的程序示例：

#+begin_src c
#include <stdlib.h>  /* Declares getenv. */
#include <stdio.h>   /* Declares printf. */

int
main (void)
{
  char *home_directory = getenv ("HOME");
  if (home_directory)
    printf ("My home directory is: %s\n", home_directory);
  else
    printf ("My home directory is not defined!\n");
}
#+end_src

* 高级函数特性

本节介绍了GNU C函数定义的一些高级或晦涩的特性。如果你刚开始学习C语言，可以跳过本章的其余部分。

** 可变长度数组参数

一个数组参数可以具有可变长度：只需使用一个非常数的大小声明数组类型。在嵌套函数中，
长度可以引用包含范围内定义的变量。在任何函数中，它可以引用先前的参数，如下所示：

#+begin_src c
struct entry
tester (int len, char data[len][len])
{
  …
}
#+end_src


另外，在函数声明中（但不是函数定义中），你可以使用[*]来表示数组参数的长度可变，这样这两个声明的含义是相同的：

#+begin_src c
struct entry
tester (int len, char data[len][len]);

struct entry
tester (int len, char data[*][*]);
#+end_src

在GNU C中，这两种形式的输入是等价的，但强调数组参数是可变长度的可能对于学习代码的人会有帮助。

你还可以省略长度参数，并在函数定义中使用其他的在作用域内的变量作为长度：

#+begin_src c
struct entry
tester (char data[*][*]);
…
int dataLength = 20;
…
struct entry
tester (char data[dataLength][dataLength])
{
  …
}
#+end_src

在GNU C中，如果你想先传递数组，然后再传递长度，你可以使用 /参数的前向声明/ ，如下所示：

#+begin_src c
struct entry
tester (int len; char data[len][len], int len)
{
  …
}
#+end_src


在分号之前的'int len'是参数的前向声明；它的目的是在解析数据声明时使名称len可知。


你可以在参数列表中编写任意数量的参数前向声明。它们可以用逗号或分号分隔，但最后一个必须以分号结尾，
后面是"真正的"参数声明。每个前向声明必须与随后的"真正"声明在参数名称和数据类型上匹配

** 变长参数列表

一个接受可变数量参数的函数被称为可变参数函数。在C语言中，可变参数函数必须指定至少一个具有显式声明数据类型的固定参数。
随后可以跟随额外的参数，这些参数的数量和数据类型都可以变化。


在函数头部，以正常的方式声明固定参数，然后写上逗号和省略号："，..."。以下是一个可变参数函数头部的示例：

#+begin_src c
int add_multiple_values (int number, ...)
#+end_src

函数体可以通过参数名称引用固定参数，但是额外的参数没有名称。在函数体内访问这些参数需要使用一些标准的宏。
这些宏在库头文件stdarg.h中定义，因此代码必须包含该文件（使用#include指令）。

在函数体中，编写以下代码来访问和处理可变参数：

#+begin_src c
va_list ap;
va_start (ap, last_fixed_parameter);
#+end_src

这段代码声明了变量ap（你可以使用任何名称），然后设置它指向第一个额外参数之前。

接下来，要获取下一个连续的额外参数，可以编写以下代码：

#+begin_src c
va_arg (ap, type)
#+end_src

在获取所有额外参数（或需要使用的参数数量）之后，可以编写以下代码：

#+begin_src c
va_end(ap, tyep)
#+end_src


这是一个可变参数函数的示例定义，它可以添加任意数量的整数参数。第一个（固定的）参数表示后面还有多少个参数。

#+begin_src c
#include <stdarg.h> /* Defines va… macros. */
…

int
add_multiple_values (int argcount, ...)
{
  int counter, total = 0;

  /* Declare a variable of type va_list. */
  va_list argptr;

  /* Initialize that variable.. */
  va_start (argptr, argcount);

  for (counter = 0; counter < argcount; counter++)
    {
      /* Get the next additional argument. */
      total += va_arg (argptr, int);
    }

  /* End use of the argptr variable. */
  va_end (argptr);

  return total;
}
#+end_src


在GNU C中，va_end是多余的，但其他一些编译器可能会使va_start分配内存，因此调用va_end是必要的，以避免内存泄漏。
在再次使用相同变量进行va_start之前，先调用va_end。

由于可能存在内存分配，使用赋值将一个va_list变量复制到另一个变量是有风险的（原则上）。相反，应使用va_copy函数，
它会复制内容，并在要复制到的变量中分配单独的内存。va_copy的调用形式为va_copy(to, from)，
其中to和from都应该是va_list类型的变量。原则上，在每个变量的作用域结束之前都应该对其调用va_end。


由于在函数的定义中没有指定额外参数的类型，因此在函数调用中将应用默认的参数提升（参见参数提升）。
函数定义必须考虑到这一点；因此，如果一个参数被传递为short类型，函数应该将其作为int类型接收。
如果一个参数被传递为float类型，函数应该将其作为double类型接收。

#+begin_src c
sum = add_multiple_values (3, 12, 34, 190);
/* Value is 12+34+190. */
#+end_src

在GNU C中，实际上没有必要使用va_end函数。事实上，它不起任何作用。它用于与其他编译器的兼容性，但在GNU C中并不需要使用它。

确实，在除了上面描述的方式之外，访问声明为va_list的变量是错误的。va_list的具体实现细节是与平台相关的，可能会因平台而异。

** 嵌套函数

嵌套函数是在另一个函数内部定义的函数。嵌套函数的名称仅在定义它的块范围内有效。例如，下面我们定义了一个名为square的嵌套函数，
并调用它两次：

#+begin_src c
foo (double a, double b)
{
  double square (double z) { return z * z; }

  return square (a) + square (b);
}
#+end_src

嵌套函数可以访问包含它的函数从开始到其定义的地方之前的所有变量。这被称为词法作用域。
例如，下面是一个使用继承变量offset的嵌套函数的示例：

#+begin_src c
bar (int *array, int offset, int size)
{
  int access (int *array, int index)
    { return array[index + offset]; }
  int i;
  …
  for (i = 0; i < size; i++)
    … access (array, i) …
}
#+end_src

嵌套函数定义可以出现在任何自动变量声明允许的地方；也就是说，在任何块中，可以与其他声明和语句交错出现。

嵌套函数的名称只在父块内可见；名称的作用域从其定义开始，持续到包含块的结束。如果嵌套函数的名称与父函数的名称相同，
在嵌套函数的名称作用域内将无法引用父函数。


在嵌套函数定义上使用extern或static是错误的。

确实，可以通过存储嵌套函数的地址或将地址传递给另一个函数来在其名称作用域之外调用嵌套函数。你可以安全地这样做，但必须小心：

#+begin_src c
hack (int *array, int size, int addition)
{
  void store (int index, int value)
    { array[index] = value + addition; }

  intermediate (store, size);
}
#+end_src

在这个例子中，函数intermediate接收store的地址作为参数。如果intermediate调用store，则给定给store的参数将用于存储到数组中。
store还访问了hack的局部变量addition。


在调用intermediate期间，store函数是安全的，因为hack的栈帧（包括其参数和局部变量）在调用intermediate期间仍然存在。

在包含函数退出后通过其地址调用嵌套函数是有风险的。如果在一个包含的作用域级别退出后调用嵌套函数，
并且嵌套函数引用了一些不再在作用域内的变量，它将引用包含了垃圾或其他数据的内存。冒这种风险是不明智的。

GNU C编译器实现了使用一种称为"trampolines"的技术来获取嵌套函数的地址。这种技术在《Lexical Closures for C++》
（Thomas M. Breuel，USENIX C++ Conference Proceedings，1988年10月17日至21日）一文中进行了描述。

嵌套函数可以跳转到从包含函数继承的标签，前提是该标签在包含函数中显式声明过（参见局部标签）。
这样的跳转会立即返回到包含函数，退出执行进行了goto的嵌套函数以及任何中间的函数调用。以下是一个示例：

#+begin_src c
bar (int *array, int offset, int size)
{
  /* Explicitly declare the label failure. */
  __label__ failure;
  int access (int *array, int index)
    {
      if (index > size)
        /* Exit this function,
           and return to bar. */
        goto failure;
      return array[index + offset];
    }

  int i;
  …
  for (i = 0; i < size; i++)
    … access (array, i) …
  …
  return 0;

 /* Control comes here from access
    if it does the goto.  */
 failure:
  return -1;
}
#+end_src

要在定义之前声明嵌套函数，可以使用auto关键字（对于函数声明而言，它本身没有实际意义；请参阅auto和register）。例如：

#+begin_src c
bar (int *array, int offset, int size)
{
  auto int access (int *, int);
  …
  … access (array, i) …
  …
  int access (int *array, int index)
    {
      …
    }
  …
}
#+end_src

** 内联函数


要声明一个内联函数，可以在其定义中使用inline关键字。下面是一个简单的内联函数示例，
它接受一个指向整数的指针并递增存储在该地址处的整数：

#+begin_src c
struct list
{
  struct list *first, *second;
};

inline struct list *
list_first (struct list *p)
{
  return p->first;  
}

inline struct list *
list_second (struct list *p)
{
  return p->second;  
}
#+end_src

编译器通过将调用内联函数的地方替换为内联函数的函数体的方式达到优化的目的，这种函数替换方式被成为内联。
这使得使用内联函数的代码运行更快，尤其是如果内联函数很小的话，性能提升会非常显著。

这是一个使用pair_second的函数示例：

#+begin_src c
int
pairlist_length (struct list *l)
{
  int length = 0;
  while (l)
    {
      length++;
      l = pair_second (l);
    }
  return length;
}
#+end_src


将pair_second的代码替换为pairlist_length的定义，得到以下代码：

#+begin_src c
int
pairlist_length (struct list *l)
{
  int length = 0;
  while (l)
    {
      length++;
      l = l->second;
    }
  return length;
}
#+end_src

由于pair_second的定义中没有使用extern或static关键字，该定义仅用于内联。它不会生成可以在运行时调用的代码。
如果并非所有对该函数的调用都被内联展开，那么在另一个模块中必须有相同函数名的定义供这些调用使用。

在内联函数定义中添加static关键字意味着函数定义仅限于该编译模块。此外，如果有任何未被内联展开的调用，
它会生成必要的运行时代码。如果所有调用都被内联展开，那么函数定义不会生成运行时代码，
但你可以通过选项-fkeep-inline-functions强制生成运行时代码。

在内联函数中同时指定extern关键字意味着该函数是外部函数，并生成运行时代码，可以从其他单独编译的模块中调用，
并且还可以进行内联展开。你可以在其他模块中将函数定义为内联函数而不使用extern，以便在这些模块中内联调用相同的函数。
这样可以在需要时进行内联展开，而在其他模块中保持函数的外部可见性。

有几个原因可能导致某些调用未被内联展开。首先，内联展开是一种优化技术，因此非优化的编译不会进行内联展开。
在非优化编译中，函数调用会被保留，而不会被替换为函数体的副本。

有些调用由于技术原因无法进行内联展开。此外，在函数定义中的某些用法可能会使其不适合进行内联替换。
这些用法包括：可变参数函数、使用alloca函数、使用计算goto（参见标签作为值）、以及使用非局部goto。
选项-Winline可以在将标记为内联的函数不适合进行内联展开时发出警告。警告将解释是什么原因使其不适合进行内联展开。

确实，仅仅因为一个调用可以被内联展开，并不意味着它应该被内联展开。GNU C编译器会权衡成本和收益，
决定是否内联展开特定的调用是否有优势。

你可以通过为函数指定always_inline属性，强制将所有可以内联展开的调用都进行内联展开，即使在非优化编译中也可以。示例如下：

#+begin_src c
/* Prototype.  */
inline void foo (const char) __attribute__((always_inline));
#+end_src

这是GNU C的扩展功能。请参阅"Attributes"（属性）部分。

在特定情况下，即使函数没有声明为内联，编译器也可能对函数调用进行内联展开，前提是编译器能够确定这是正确和可取的。
例如，当一个静态函数只被调用一次时，很可能会被内联展开。使用-flto（链接时优化）时，任何函数都可能被内联展开。
要绝对阻止特定函数的内联展开，可以在函数的定义中指定__attribute__((noinline))。

* 过时的函数特性

这些函数定义的特性仍然在旧的程序中使用，但是现在不应该以这种方式编写代码。如果你正在学习C，可以跳过本节。

** 过时的GNU C内联


在GCC 5版本之前，GNU C对于内联函数的规范定义了在函数定义中使用extern inline意味着内联展开调用，
但不生成可以在运行时调用的函数代码。相反，使用inline而没有指定extern则会生成运行时的函数代码。
实际上，ISO标准对于这两种情况定义与GNU C相反。我们在GCC 5版本中更改了GCC，以采用ISO规范的定义。

许多程序仍然使用具有先前GNU C含义的这些情况。你可以使用选项-fgnu89-inline来指定使用这些含义。
你也可以为单个函数指定这个含义，使用__attribute__((gnu_inline))。下面是一个示例：

#+begin_src c
inline __attribute__ ((gnu_inline))
int
inc (int *a)
{
  (*a)++;
}
#+end_src

** 老式的函数定义风格

传统上，C的语法允许在函数声明中省略数据类型，如果声明中指定了存储类别或限定符，则类型默认为int。例如：

#+begin_src c
static foo (double x);
#+end_src

将函数声明中的省略数据类型的写法用于指定返回类型为int是不推荐的做法。如果你遇到这种写法，应该进行修正。

一个老式（或“K&R”）的函数定义是指上世纪80年代编写函数定义的方式。它的格式如下所示：

#+begin_src c
rettype
function (parmnames)
  parm_declarations
{
  body
}
#+end_src

在parmnames中，只列出参数名称，用逗号分隔。然后，在parm_declarations中声明它们的数据类型；
这些声明的形式与变量声明完全相同。如果一个参数在parmnames中被列出，但没有声明，那么它会被隐式声明为int类型。

现在没有理由以这种方式编写函数定义，但在旧的GNU程序中仍然可以看到这种写法。

一个旧式的可变参数函数定义的样式如下所示：

#+begin_src c
#include <varargs.h>

int
add_multiple_values (va_alist)
    va_dcl
{
  int argcount;
  int counter, total = 0;

  /* Declare a variable of type va_list. */
  va_list argptr;

  /* Initialize that variable. */
  va_start (argptr);

  /* Get the first argument (fixed). */
  argcount = va_arg (int);

  for (counter = 0; counter < argcount; counter++)
    {
      /* Get the next additional argument. */
      total += va_arg (argptr, int);
    }

  /* End use of the argptr variable. */
  va_end (argptr);

  return total;
}
#+end_src

请注意，旧式的可变参数函数定义没有固定的参数变量；所有参数都必须使用va_arg来获取。
