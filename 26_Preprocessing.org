#+title: 预处理
#+OPTIONS: ^:{}

当GCC编译器对原文件进行编译时首先会进行文本替换与文件包含，这部分操作被称为预处理。

* 概述

GNU C在编译的第一阶段对C程序的每一行进行预处理。只有当一行包含预处理指令或使用宏时，
预处理器才对其进行处理，其他所有行都会在预处理之后保持不变。

以下是预处理所执行的一些任务。本章的其余部分将详细介绍这些内容。

 * 头文件的包含：头文件通常包含声明和宏定义，可以被替换到程序中。

 * 宏展开：您可以定义宏，宏是对任意C代码片段的缩写。预处理将宏替换为其定义。有些宏是自动预定义的。

 * 条件编译：您可以根据不同条件包含或排除程序的部分代码。

 * 行控制：如果您使用程序将源文件组合或重新排列成中间文件，然后再进行编译，您可以使用行控制来通知编译器每行源代码最初来自哪个文件。

 * 编译控制：#pragma和_Pragma可以调用一些特殊的编译器功能来处理特定的结构。

 * 诊断：您可以在编译时检测问题并输出错误或警告信息。

除了预定义宏的展开之外，所有这些操作仅在您使用预处理指令来请求它们时才会发生。

* 指令

预处理指令是程序中以‘#’开头的行。在‘#’之前和之后允许有空白字符。‘#’后面紧跟一个标识符，表示指令名称，
它指定要执行的操作。以下是一些示例：

#+begin_src c
#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
#+end_src

通常我们将指令写为#name，其中name是指令名称。例如，#define 表示定义宏的指令。

以‘#’开头的指令不能来自宏展开。另外，指令名称不会进行宏展开。因此，如果将foo定义为一个展开为define的宏，
那么#foo就不是一个有效的预处理指令。

C语言拥有固定数量的合法预处理指令，程序员不能自己定义新的预处理指令。

一些指令需要参数；这些参数位于指令行的其余部分，并且必须与指令名称用空白分隔开。
例如，#define 后面必须跟着宏的名称和宏的预期展开内容。

预处理指令不能跨越多行。但是，可以使用反斜杠换行符（backslash-newline）或者使用/*...*/风格的注释来延续行。
在指令被处理之前，这些反斜杠换行符或注释将被替换掉（替换为空白或删除），以便保持指令的连续性。

* 标记

预处理将C代码（去除其注释）划分为预处理标记，这些标记类似于C标记，但并不完全相同。以下是预处理标记的特点。

预处理标记的主要类别包括标识符、预处理数值、字符串常量、字符常量和标点符号；还有一些其他类型的预处理标记。

*标识符*

	标识符预处理标记在语法上类似于C中的标识符：它可以是由字母、数字或下划线组成的任意序列，
	还可以使用'\U'或'\u'表示非ASCII字符，但不能以数字开头。

	在预处理阶段，C语言的关键字没有特殊意义；在这个阶段，它们只是普通的标识符。
	因此，您可以定义一个宏，其名称是一个关键字。在预处理期间，唯一具有特殊意义的标识符是defined（请参阅defined）。

*预处理数值*

	预处理数值是指预处理阶段将其文本视为数字的内容，包括C语言的数值常量以及其他类似数值常量的字符序列。
	预处理并不尝试验证预处理数值是否在C语言中是有效的数字，实际上它不一定是一个合法的C语言数值。

	更准确地说，预处理数值以可选择以小数点开始，接着是必需的十进制数字，然后继续包含任意序列的字母、数字、下划线、
	小数点和指数部分。指数部分由两个字符组成，包括 'e+'、'e-'、'E+'、'E-'、'p+'、'p-'、'P+' 和 'P-'。
	（以 'p' 或 'P' 开头的指数部分是C99引入的，它们用于表示十六进制浮点常量。）

*标点*

	标点符号在语法上类似于运算符。以下是有效的标点符号：

#+begin_src c
	[  ]   (  )  {  }  .  ->
	++ --  &  *  +  -  ~  !
	/  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
	?  :   ;  ...
	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
	,  #   ##
	<: :>  <% %>  %:  %:%:
#+end_src

*字符串常量*

	在源代码中的字符串常量在预处理阶段被识别为一个单一的预处理标记。

*字符常量*

	在源代码中的字符常量在预处理阶段被识别为一个单一的预处理标记。

*头文件名*

	在#include指令内部，预处理器识别头文件名标记。它由'"name"'组成，
	其中name是除换行符和双引号之外的源代码字符序列，或者由'<name>'组成，
	其中name是除换行符和尖括号之外的源代码字符序列。

	在实际使用中，更方便的做法是将#include行视为不需要进行标记化的例外情况。

*其他*

	除此之外，在C源程序中任何其他有效的字符都会被视为独立的预处理标记。


一旦程序被划分为预处理标记，它们会保持独立直到预处理结束。
宏生成的两个连续标记会在必要时插入空格来保持它们的独立性。例如，

#+begin_src c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
#+end_src

唯一的例外是使用##预处理运算符，它将标记粘贴在一起（参见拼接）。

预处理将空字符（字符代码0）视为空格，但是对其生成警告，因为它可能对用户不可见（许多终端根本不显示它），
而且在文件中出现它很可能是一个错误。

* 头文件

头文件是一种C代码文件，通常包含C声明和宏定义（参见宏），用于在多个源代码文件之间共享。
您可以通过使用C预处理指令 #include 来请求在程序中使用头文件。

头文件有两个目的:

 * 操作系统使用头文件提供接口。您将操作系统提供的头文件包含在您的程序中，以提供您需要调用系统调用和库的定义和声明。

 * 特定程序的头文件包含特定程序源文件之间的接口声明。如果所有或大部分接口声明和宏定义在多个不同的源文件中都需要使用，那么为相关声明和宏定义创建一个头文件是一个不错的主意。

如果没有头文件那么就需要将相同内容在每个源文件中重新书写一遍，但是这样的重写不但浪费时间还容易出错。
有了头文件，相关的声明只出现在一个地方。如果它们需要被修改，您可以在一个地方进行修改，然后包含该头文件的程序在下次重新编译时会自动使用新版本。
头文件消除了查找和更改所有副本的工作量，同时也消除了未更改一个副本会导致程序内部不一致的风险。

在C语言中，通常的约定是给头文件命名以 .h 结尾。在头文件名称中，最好只使用字母、数字、破折号和下划线，并且最多只有一个点，这样可移植性最好。

** 包含头文件语法

您可以使用预处理指令 #include 来指定包含用户和系统头文件。它有两种变体：

#+begin_src c
#include <file>
#+end_src

	这个变体用于包含系统头文件。它在标准系统目录列表中搜索名为 "file" 的文件。您可以使用 -I 选项在此列表前添加目录
	（参见《使用GNU编译器集合》中的 "调用GCC"）。

#+begin_src c
#include "file"
#+end_src

	这个变体用于包含您自己程序的头文件。它首先在包含当前文件的目录中搜索名为 "file" 的文件，然后在引号目录中搜索，
	最后在用于 <file> 的相同目录中搜索。您可以使用 -iquote 选项在引号目录列表前添加目录。


在 #include 的参数中，无论是用引号括起来还是用尖括号括起来，它都像一个字符串常量一样运行，即不识别注释，并且不会展开宏名称。
因此，#include <x/*y> 表示包含一个名为 x/*y 的系统头文件。

一些系统将 ‘\’ 解释为文件名与路径的分隔符。所有系统以相同的方式解释 ‘/’。为了最大的可移植性，最好只使用 ‘/’。

在 #include 行的文件名后面放置除注释以外的任何内容都是错误的。

** 包含头文件操作

#include指令的工作原理是在继续处理当前文件之前扫描指定的头文件。预处理的结果包括已经生成的文本，
后跟预处理包含文件的结果，然后是继续处理#include指令之后的文本。
例如，如果有一个名为header.h的头文件，内容如下：

#+begin_src c
char *test (void);
#+end_src

假设main函数在名为program.c的源文并使用上面提到的头文件：

#+begin_src c
int x;
#include "header.h"

int
main (void)
{
  puts (test ());
}
#+end_src

结果等同于直接把头文件中的内容放置到program.c中

#+begin_src c
int x;
char *test (void);

int
main (void)
{
  puts (test ());
}
#+end_src


包含的文件不仅限于声明和宏定义；这些只是典型的用法。C程序的任何片段都可以从另一个文件中包含进来。
包含的文件甚至可以包含在包含文件中开始的语句的开头，或者在包含文件中结束的语句的结尾。
然而，被包含的文件必须由完整的标记组成。在被包含的文件中，如果注释或字符串文字在文件结束时没有关闭，
那么它们是无效的。为了错误恢复，编译器将在文件结束时终止它们的处理。

为了避免混淆，最好让头文件只包含完整的语法单元，例如函数声明或定义、类型声明等。

不管被包含的文件是否缺少最后的换行符，紧随#include指令的那一行始终被视为一个单独的行。在这里放置预处理指令也没有问题。

** 搜寻路径

GCC在寻找要包含的头文件时会查找多个不同的位置。在GNU系统和Unix系统上，系统头文件的默认目录包括：

#+begin_src 
libdir/gcc/target/version/include
/usr/local/include
libdir/gcc/target/version/include-fixed
libdir/target/include
/usr/include/target
/usr/include
#+end_src

在一些操作系统中，这个列表可能会有所不同。此外，对于C++，可能会添加其他目录用于头文件的查找。


在上述内容中，target是GCC配置为编译代码的系统的规范名称；通常情况下，
但并不总是与运行GCC的系统的规范名称相同。version是正在使用的GCC版本。

你可以通过命令行选项"-Idir"来增加这个列表。所有由"-I"指定的目录将按照从左到右的顺序在默认目录之前进行搜索。
唯一的例外是当"dir"已经是默认搜索目录之一时。在这种情况下，该选项会被忽略，系统目录的搜索顺序保持不变。

在将使用引号与尖括号所引用的路径合并之前，重复的路径将从他们各自的集合中移除。因此，如果一个路径分别出现在
使用引号和尖括号的引用集合之中，那么他可能在合并的路径集合中出现两次。

你可以通过使用"-nostdinc"选项来阻止GCC搜索任何默认目录。这在编译操作系统内核或其他不使用标准C库设施或标准C库本身
的程序时非常有用。当启用"-nostdinc"选项时，GCC之搜索-I指定的路径。

GCC首先在包含当前文件的目录中查找使用#include "file"指令请求的头文件，
然后在由"-iquote"选项指定的引号目录中查找，最后在它通常搜索系统头文件的位置查找。
例如，如果"/usr/include/sys/stat.h"文件中包含了#include "types.h"，
GCC将首先在"/usr/include/sys"目录中查找types.h，然后在引号目录中查找，最后在其通常的搜索路径中查找。

#line（参见Line Control）指令不会改变GCC对包含当前文件的目录的理解。

"-I-"是一种过时的、老式的方式来指定引号目录（quote directories）。要在名为"-"的目录中查找头文件，可以使用"-I./-"。
调整头文件搜索路径还有其他几种方法，请参阅《使用GNU编译器集合》中的《调用GCC》章节。

** 单次包含头文件


如果一个头文件被包含两次，编译器将会处理它的内容两次。这很可能导致错误，例如当编译器看到相同的结构体定义两次时会发生错误。

防止头文件重复包含的标准方法是使用条件编译将整个文件的真实内容包裹起来，就像这样：

#+begin_src c
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

the entire file

#endif /* !FILE_FOO_SEEN */
#+end_src

这个构造通常被称为包装器 #ifndef。当头文件再次被包含时，条件将为假，因为FILE_FOO_SEEN已经被定义。预处理器会跳过整个文件的内容，
因此在同一个模块中编译时将不会“再次看到”文件内容。

GCC在这种情况下甚至进一步优化了处理方式。它会记住哪些头文件有包装器 #ifndef。如果后续的#include指定了该头文件，
并且#ifndef中的宏仍然被定义，GCC将不再重新扫描整个文件。

你可以将注释放在头文件的包装器之外，这些注释不会干扰优化。

宏FILE_FOO_SEEN被称为控制宏或守卫宏。在用户头文件中，宏的名称不应以'=_='开头。
在系统头文件中，它应该以'=__='（或'=_='后跟一个大写字母）开头，以避免与用户程序发生冲突。在任何类型的头文件中，
宏的名称应包含文件的名称和一些额外的文本，以避免与其他头文件发生冲突。


** 计算式包含

有时候需要从几个不同的头文件中选择一个包含到程序中。这些头文件可能指定了在不同类型的操作系统上使用的配置参数，
例如，你可以通过一系列条件语句来实现这一点。

#+begin_src c
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
/* … */
#endif
#+end_src

那样很快就会变得乏味。GNU C提供了使用宏作为头文件名的功能。这被称为计算式包含（Computed Include）。
在#include的直接参数中，你只需放置一个宏名即可，而不是写上头文件名：

#+begin_src c
#define SYSTEM_H "system_1.h"
/* … */
#include SYSTEM_H
#+end_src


SYSTEM_H被展开后，system_1.h会被包含，就好像#include指令是用system_1.h这个名字写的。
SYSTEM_H可以通过你的Makefile使用-D选项进行定义。


在定义这样的宏时必须小心。#define保存的是标记（tokens），而不是文本。GCC无法知道宏将作为#include指令的参数使用，
因此它生成普通的标记，而不是头文件名。如果你使用双引号包含（double-quote includes），
这与字符串常量在语法上相似，那么这可能不会引起问题。然而，如果你使用尖括号包含（angle brackets），可能会遇到问题。

计算式包含的语法实际上比上述所述的更加通用。如果在#include指令后的第一个非空白字符不是'“'或'<'，
那么整行代码将会像普通代码一样进行宏展开。

如果计算式包含展开为一个单独的字符串常量，那么该字符串常量的内容将作为要包含的文件名。
预处理器不会重新检查字符串中是否有嵌套的引号，也不会处理字符串中的反斜杠转义符。
因此，计算式包含是在宏展开阶段进行处理的，不会再次解析字符串中的引号或反斜杠转义符。

#+begin_src c
#define HEADER "a\"b"
#include HEADER
#+end_src

查找名为a\"b的文件，计算式包含会根据双引号包含（double-quoted includes）的规则来搜索这个文件。

如果计算式包含展开的结果是一个以'<'标记开头且包含'>'标记的标记流（token stream），
那么位于'<'和第一个'>'之间的标记将被组合成要包含的文件名。在组合文件名时，任何标记之间的空格都会被缩减为一个空格；
然后在初始的'<'后面的空格会保留，但在结束的'>'之前的末尾空格将被忽略。
预处理器会根据尖括号包含（angle-bracket includes）的规则来搜索该文件。

在任何情况下，如果在文件名之后的行上存在任何标记，都会导致错误，并且该指令不会被处理。
如果展开的结果不符合预期的两种形式之一，也会引发错误。

这些规则是根据C标准定义的实现定义行为。为了最大限度地减少不同编译器对计算式包含的解释差异，
我们建议你只使用一个类似对象的宏，其展开结果是一个字符串常量。这样做也有助于程序读者更好地理解代码。

* 宏定义

宏（Macro）是一段被赋予名称的代码片段。无论何时使用该名称，它都会被宏的内容所替代。
宏分为两种类型，它们在使用时的外观主要有所不同。类似数据的宏在使用时类似于数据对象，
而类似函数的宏则类似于函数调用。

你可以将任何有效的标识符定义为宏，即使它是C语言的关键字也可以。在预处理阶段，GCC（GNU编译器集合）
对关键字一无所知。如果你希望隐藏像 const 这样的关键字，以使其不被旧的不理解它的编译器识别，
这会很有用。然而，预处理操作符 defined（参见 defined）永远不能被定义为宏，
而C++的命名操作符（参见在使用GNU编译器集合中的C++命名操作符）在编译C++代码时也不能作为宏使用。

** 类数据式宏

类数据宏（Object-like macro）是一个简单的标识符，它将被一个代码片段所替代。
之所以称之为类数据，是因为在大多数情况下，宏的使用类似于对使用它的代码中的数据对象的引用。
这些宏通常用于为数值常量赋予符号名称。

定义宏需要使用 #define 指令。#define 后面跟着宏的名称，然后是它应该代表的标记序列，
这个序列在不同的情况下也被称为宏的主体、展开或替换列表。例如，

#+begin_src c
#define BUFFER_SIZE 1024
#+end_src

定义了一个名为 BUFFER_SIZE 的宏，将其缩写为标记 1024。
如果在这个 #define 指令之后的某个地方出现一个形如下面的 C 语句

#+begin_src c
foo = (char *) malloc (BUFFER_SIZE);
#+end_src

那么预处理将会识别并将 BUFFER_SIZE 展开，因此编译过程将会看到以下标记：

#+begin_src c
foo = (char *) malloc (1024);
#+end_src

按照惯例，宏的名称使用大写字母书写。当能够一眼就看出哪些名称是宏时，程序更容易阅读。
以“__”开头的宏名称被保留供内部使用，并且其中许多是自动定义的，因此除非你确切知道自己在做什么，
否则不要定义此类宏名称。同样，以“_”和大写字母开头的宏名称也是如此。

宏的主体在 #define 行的末尾结束。如果需要的话，你可以使用反斜杠换行将定义延续到多行。
然而，当宏被展开时，所有内容将会放在一行上。例如，

#+begin_src c
#define NUMBERS 1, \
                2, \
                3
int x[] = { NUMBERS };
     → int x[] = { 1, 2, 3 };
#+end_src

这种情况最常见的显而易见的后果是错误消息中出现令人惊讶的行号。

在宏主体中可以放置任何内容，只要它分解为有效的预处理标记即可。括号不需要配对，
主体也不需要类似于有效的 C 代码。（如果不是有效的 C 代码，当你使用宏时可能会从 C 编译器得到错误消息。）

预处理会按顺序扫描程序。宏定义在出现后立即生效。因此，以下输入:

#+begin_src c
foo = X;
#define X 4
bar = X;
#+end_src

将会产生以下结果：

#+begin_src c
foo = x;
bar = 4;
#+end_src

当预处理展开一个宏名称时，宏的展开将替宏名称，然后会对展开后的内容进行更多的宏展开。例如，

#+begin_src c
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     → BUFSIZE
     → 1024
#+end_src

首先，TABLESIZE 被展开为 BUFSIZE，然后该宏被展开为最终结果，即 1024。

请注意，当定义 TABLESIZE 时并没有定义 BUFSIZE。对于 TABLESIZE 的 #define 指令完全使用你指定的展开内容，
即在此情况下为 BUFSIZE，并且不会检查其是否也包含宏名称。只有当你使用 TABLESIZE 时，
其展开结果才会被扫描以进行更多的宏替换。


如果在源文件的某个地方更改了 BUFSIZE 的定义，这将产生差异。
如上所示定义的 TABLESIZE 将始终使用当前有效的 BUFSIZE 定义进行展开：

#+begin_src c
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
#+end_src

现在展开后的 TABLESIZE 为37。

如果宏的展开内容包含自己的名称，无论是直接还是通过中间宏，当对展开内容进行更多的宏展开时，它不会再次被展开。
这样可以防止无限递归。有关详细信息，请参阅《自引用宏》（Self-Referential Macros）。

** 类函数宏

你还可以定义类似于函数调用的宏。这些被称为类函数宏。要定义一个类函数宏，
请在宏名称后面紧跟一对括号，使用#define 指令。例如，

#+begin_src c
#define lang_init()  c_init()
lang_init()
     → c_init()
#+end_src

类函数宏只有在其名称后面跟着一对括号时才会展开。如果只写名称而没有括号，它将保持不变。
当你有一个同名的函数和宏，而你有时希望使用函数时，这会很有用。在调用宏时，括号前面或括号之间的空格和换行将被忽略。

#+begin_src c
extern void foo(void);
#define foo() /* optimized inline version */
/* … */
  foo();
  funcptr = foo;
#+end_src

这里对foo()的调用会展开宏，但是函数指针funcptr会获得真实函数foo的地址。如果在这里展开宏，将会导致语法错误。

如果在宏定义中在宏名称和括号之间加上空格，那不会定义一个类似函数的宏，而是定义一个对象类似的宏，
其展开恰好以一对括号开头。这里是一个示例：

#+begin_src c
#define lang_init ()    c_init()
lang_init()
     → () c_init()()
#+end_src

这个展开中的前两对括号来自于宏。第三对括号是宏调用的原始括号。由于lang_init是一个类对象宏，它不会消耗那些括号。

任何名称一次只能有一个宏定义。因此，你不能同时将同一个名称定义为类对象宏和类函数宏。

** 宏参数

类函数宏可以像真正的函数一样带参数。要定义一个带参数的宏，你需要在宏定义的一对括号中插入参数，
使宏变得类似函数。这些参数必须是有效的 C 标识符，用逗号和可选的空格分隔。

要调用带有参数的宏，你需要在宏名称后面用括号括起来的实际参数列表，参数之间用逗号分隔。
宏的调用不必局限于单个逻辑行 - 它可以跨越源文件中的多行。你提供的参数数量必须与宏定义中的参数数量相匹配。
当宏被展开时，在宏体内每次使用一个参数时，都会被相应参数的标记所替代。（宏体不一定要使用所有参数。）

例如，这里有一个在许多 C 程序中定义的计算两个数值的最小值的宏，以及一些用法示例：

#+begin_src c
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
  x = min(a, b);      → x = ((a) < (b) ? (a) : (b));
  y = min(1, 2);      → y = ((1) < (2) ? (1) : (2));
  z = min(a+28, *p);  → z = ((a+28) < (*p) ? (a+28) : (*p));
#+end_src

在这个小例子中，你已经可以看到宏参数的一些危险之处。详细的解释可以查看“宏陷阱”部分。

每个参数中的前导和尾随空白都会被删除，参数中标记之间的所有空白会被缩减为单个空格。
每个参数中的括号必须保持平衡；括号内的逗号不会结束参数。但是，方括号或大括号不需要保持平衡，
并且它们不会阻止逗号分隔参数。因此，

#+begin_src c
macro (array[x = y, x + 1])
#+end_src

向宏传递了两个参数：array[x = y 和 x + 1]。如果你想将array[x = y, x + 1]作为参数提供，
可以写成array[(x = y, x + 1)]，这与等效的 C 代码是相同的。然而，将赋值放在数组下标内部是要避免的。

所有传递给宏的参数在被替换到宏体之前都会完全宏展开。在替换后，完整的文本会再次被扫描以展开宏，包括参数。
这个规则可能看起来很奇怪，但它经过精心设计，所以你不必担心任何函数调用是否实际上是宏调用。
不过，如果你过于聪明，可能会遇到问题。详细讨论请参阅“参数预扫描”。

例如， min (min (a, b), c) 首先被展开为：

#+begin_src c
min (((a) < (b) ? (a) : (b)), (c))
#+end_src

然后继续被展开为：

#+begin_src c
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
#+end_src

（换行只是为了使代码看起来清晰真实的代码中并不会产生换行。）

#+begin_src c
min(, b)        → ((   ) < (b) ? (   ) : (b))
min(a, )        → ((a  ) < ( ) ? (a  ) : ( ))
min(,)          → ((   ) < ( ) ? (   ) : ( ))
min((,),)       → (((,)) < ( ) ? ((,)) : ( ))

min()      error→ macro "min" requires 2 arguments, but only 1 given
min(,,)    error→ macro "min" passed 3 arguments, but takes just 2
#+end_src

空格不是预处理标记，因此如果一个宏foo接受一个参数，foo () 和 foo ( ) 都会提供一个空参数给它。

出现在字符串字常量内部的宏参数不会被它们对应的实际参数替换。

#+begin_src c
#define foo(x) x, "x"
foo(bar)        → bar, "x"
#+end_src

请参见下一小节，了解如何将宏参数插入字符串字面量中。

即使看起来可能合并成一个标记，紧随宏调用的标记和宏展开的最后一个标记也不会成为一个标记：

#+begin_src c
#define foo()  abc
foo()def        → abc def
#+end_src

** 字符串化

有时您可能希望将宏参数转换为字符串常量。在字符串常量内部，参数不会被替换，但您可以使用 # 预处理运算符来实现。
当一个宏参数以 # 开头使用时，预处理会将其替换为实际参数的字面文本，转换为字符串常量。
与普通的参数替换不同，这里的参数不会先进行宏展开。这被称为字符串化。

没有办法将参数与周围的文本结合起来并一起转化为字符串。但是您可以编写一系列的字符串常量和字符串化的参数。
在预处理将字符串化的参数替换为字符串常量后，连续的字符串常量将被连接成一个长的字符串常量（参见字符串常量）。

这里有一个使用字符串化和字符串常量连接的示例：

#+begin_src c
#define WARN_IF(EXP) \
  do { if (EXP) \
          fprintf (stderr, "Warning: " #EXP "\n"); } \
  while (0)

WARN_IF (x == 0);
     →
  do { if (x == 0)
          fprintf (stderr, "Warning: " "x == 0" "\n"); }
  while (0);
#+end_src

对于 EXP 的参数会被替换一次，原样地放入 if 语句中，并被字符串化后放入 fprintf 的参数中。
如果 x 是一个宏，它会在 if 语句中被展开，但不会在字符串中展开。


do 和 while (0) 的使用是一种权宜之计，使得可以编写 WARN_IF (arg);。WARN_IF 与函数的相似性使其成为一种自然的编写方式。
详见吞噬分号。


在 C 语言中的字符串化不仅仅涉及将双引号字符放在片段周围。它还会使用反斜杠转义符将引号放置到字符串常量周围，
以及字符串和字符常量内的所有反斜杠，以获得具有正确内容的有效 C 字符串常量。
因此，将 p = "foo\n"; 进行字符串化将得到 "p = "foo\n";"。
然而，在不在字符串或字符常量内部的反斜杠不会被复制：独立的 ‘\n’ 字符串化为 "\n"。

在被字符串化的文本中，所有前导和尾随的空白都会被忽略。在文本中间的任何一系列空白会在字符串化结果中转换为单个空格。
注释会在字符串化发生之前被替换为空白，因此它们永远不会出现在被字符串化的文本中。

无法将宏参数转换为字符常量。

要将宏参数的展开结果转化为字符串，您需要使用两层宏，就像这样：

#+begin_src c
#define xstr(S) str(S)
#define str(s) #s
#define foo 4
str (foo)
     → "foo"
xstr (foo)
     → xstr (4)
     → str (4)
     → "4"
#+end_src

当 s 在 str 中使用时会被字符串化，因此它不会先进行宏展开。但是 S 是传递给 xstr 的普通参数，
因此在 xstr 自身展开之前，它会被完全宏展开（参见参数预扫描）。因此，当 str 到达其参数文本时，
该文本已经进行了宏展开。

** 标识符连接

在展开宏时，通常会将两个标记合并为一个标记。这被称为标记粘贴或标记连接。## 预处理运算符执行标记粘贴操作。
当宏被展开时，每个##运算符两侧的两个标记被组合成一个单一的标记，然后替换宏展开中的##以及两个原始标记。
通常，两个标记都将是标识符，或者一个是标识符，另一个是预处理数字。粘贴在一起时，它们会形成一个较长的标识符。

并不是只有标识符可以被连接。还可以将两个数字（或一个数字和一个名称，如1.5和e3）连接成一个数字。
此外，通过标记粘贴，还可以形成多字符操作符，例如+=。

然而，如果两个标记在一起不能形成有效的标识符则他们之间不能进行连接。例如，无法将x与+连接在一起，无论顺序如何。
尝试这样做会产生警告，并保持这两个标记分开。它是否在标记之间放置空格是未定义的。
在复杂的宏中经常会发现不必要地使用##。如果收到此警告，很可能可以简单地删除##。

由##组合的标记都可以来自宏定义，如果是这样那么你可以在首次使用他们时把他们当作一个标记。
当其中一个或两个标记都来自宏参数标记连接将非常有用。如果紧挨在##旁边的任何一个标记是参数名之一，
它会在##执行之前被其实际参数替换。与字符串化一样，实际参数不会首先进行宏展开。
如果参数为空，则##不起作用。

请记住，预处理器在处理宏之前会先将注释转换为空格。因此，不能通过连接'/'和'*'来创建注释。
您可以在##和其操作数之间放置任意数量的空格，包括注释，并且可以在将要连接的参数中放置注释。

在宏定义体的开始和结尾处使用##是错误的。

多个##运算符按从左到右的顺序处理，因此'1 ## e ## -2'会粘贴成'1e-2'。
（如果采用从右到左的处理方式，首先会生成' e-2'，这是一个无效的标记。）当#和##一起使用时，
它们也都是从左到右处理的。

思考一下下面这个命令命名解释器程序。这个程序可能需要一个命令-函数对照表，或许可以是下面形式的结构体数组：

#+begin_src c
struct command
{
  char *name;
  void (*function) (void);
};

struct command commands[] =
{
  { "quit", quit_command },
  { "help", help_command },
  /* … */
};
#+end_src


不必在字符串常量和函数名称中都重复编写每个命令名称会更清晰。
可以使用一个以命令名称作为参数的宏来避免这种重复。
它可以使用字符串化创建字符串常量，并通过将参数与'_command'连接来创建函数名称。以下是实现方法：

#+begin_src c
#define COMMAND(NAME)  { #NAME, NAME ## _command }

struct command commands[] =
{
  COMMAND (quit),
  COMMAND (help),
  /* … */
};
#+end_src


** 可变数量参数宏

宏可以被声明为接受可变数量的参数，就像函数一样。定义宏的语法类似于函数的语法。以下是一个示例：

#+begin_src c
#define eprintf(…) fprintf (stderr, __VA_ARGS__)
#+end_src

这种类型的宏成为可变数量参数宏(variadic)。当调用宏时，在最后一个命名参数之后的宏参数列表中的所有标记，
包括任何逗号，都成为可变参数。这一系列标记将替换宏体中出现的标识符__VA_ARGS__。因此，我们得到以下扩展：

#+begin_src c
eprintf ("%s:%d: ", input_file, lineno)
     →  fprintf (stderr, "%s:%d: ", input_file, lineno)
#+end_src

可变参数在插入宏扩展之前会被完全宏展开，就像普通参数一样。您可以使用 # 和 ## 运算符将可变参数转化为字符串，
或将其前导或尾随标记与另一个标记粘合在一起。（但请参阅下文，了解 ## 运算符的一个重要特殊情况。

*警告：* 请不要将__VA_ARGS__ 用于可变数量参数以外的任何用途。

如果你的宏比较复杂，你可能希望为可变参数使用一个更具描述性的名称，而不是__VA_ARGS__。
你可以在 '...' 前面立即写上一个参数名称，该名称用于表示可变参数。上面的 eprintf 宏可以这样编写：

#+begin_src c
#define eprintf(args…) fprintf (stderr, args)
#+end_src

可变参数宏除了可变参数之外，还可以具有具名参数，因此可以这样定义 eprintf 宏：

#+begin_src c
#define eprintf(format, …) \
  fprintf (stderr, format, __VA_ARGS__)
#+end_src

这种表述方式更加清晰，但如果您想指定一个不带参数的格式字符串呢？在GNU C中如果格式化字符串的参数为空你可以省略参数
之前的逗号，但是在宏展开时会自动添加一个额外的逗号：

#+begin_src c
eprintf ("success!\n")
     → fprintf(stderr, "success!\n", );
#+end_src

这是一个错误的fprintf函数调用方式。

为了消除那个逗号，当将##标记粘合操作符放置在逗号和可变参数之间时，它具有特殊的含义。如果您写：

#+begin_src c
#define eprintf(format, …) \
  fprintf (stderr, format, ##__VA_ARGS__)
#+end_src


那么，如果您在使用具有空可变参数的宏 eprintf 时，## 将删除前面的逗号。

#+begin_src c
eprintf ("success!\n")
     → fprintf(stderr, "success!\n");
#+end_src

如果您传递一个空参数，或者如果##前面的标记不是逗号，宏展开后就不会增加多余的逗号。

当唯一的宏参数是一个可变参数参数，并且宏调用根本没有参数时，很难确定这意味着一个空参数还是一个缺失的参数。
逗号应该保留还是删除？C标准规定保留逗号，但早期的GNU C扩展删除了逗号。
如今，GNU C在实现特定的C标准时会保留逗号，否则会删除它。

C99规定，标识符__VA_ARGS__唯一可以出现的地方是在可变参数宏的替换列表中。
它不可以用作宏名称、宏参数名称或在不同类型的宏内部使用。在开放文本中可能也被禁止使用；标准存在一些模糊之处。
我们建议您除了其特殊用途外，尽量避免使用这个名称。

指定参数名称的可变参数宏是GNU C的一个长期支持的特性。标准C，从C99开始，只支持参数被称为__VA_ARGS__的形式。
为了保证在早期版本的GNU C中的可移植性，您应该只使用具有名称的可变参数参数。另一方面，为了在其他C99编译器中的可移植性，
您应该只使用__VA_ARGS__。

** 预定义宏

有一些类对象宏被预先定义在系统中；你可以直接使用它们。在这里，我们解释了用户程序通常需要使用的一些。
还有许多以‘__’开头的其他宏名称也是预定义的；通常情况下，您不应该自己定义这样的宏名称。

*__FILE__*

这个宏展开为当前输入文件的名称，以C字符串常量的形式表示。这是GCC打开文件时使用的完整名称，
而不是在#include中指定的短名称或作为输入文件名称参数的名称。
例如，这个宏的可能展开值为"/usr/local/include/myheader.h"。

*__LINE__*

这个宏展开为当前输入行的行号，以十进制整数常量的形式表示。
尽管我们称它为预定义宏，但它是一个相当奇特的宏，因为它的“定义”会随着每一行新的源代码而改变。

*__func__*
*__FUNCTION__*

这些名称类似于变量，其值是包含当前函数定义名称的字符串。它们实际上不是宏，但这是最好提到它们的地方。


\__FUNCTION__ 是自古以来在GNU C中定义的名称；__func__ 是由C标准定义的。
使用以下条件编译指令，您可以使用任何一个已定义的名称。

#+begin_src c
#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2
#  define __func__ __FUNCTION__
# else
#  define __func__ "<unknown>"
# endif
#endif
#+end_src


*__PRETTY_FUNCTION__*

这在C中等效于__FUNCTION__，但在C++中，该字符串还包括参数类型信息。这是GNU C的扩展特性。


这些特性在生成错误消息以报告程序检测到的不一致性时非常有用；错误消息可以指出检测到不一致性的源代码行。例如，

#+begin_src c
fprintf (stderr, "Internal error: "
                 "negative string length "
                 "in function %s "
                 "%d at %s, line %d.",
         __func__, length, __FILE__, __LINE__);
#+end_src


`#line` 指令会改变 `__LINE__`，并且可能也会改变 `__FILE__`。请参阅"Line Control"（行控制）了解更多信息。

*__DATA__*

这个宏会展开为一个字符串常量，描述了编译的日期。这个字符串常量包含了十一个字符，看起来像是"Feb 12 1996"。
如果月份中的日期只有一位数，前面会多加一个空格，以确保日期始终为十一个字符。


如果编译器无法确定当前日期，它会发出一条警告消息（每次编译一次），而 __DATE__ 会展开为 "??? ?? ????".

出于可重复编译的考虑，我们不建议使用 __DATE__。

*__TIME__*

这个宏会展开为一个字符串常量，描述了编译的时间。这个字符串常量包含了八个字符，看起来像是"23:59:01"。

如果编译器无法确定当前时间，它会发出一条警告消息（每次编译一次），而 __TIME__ 会展开为 "??:??:??"。

为了实现可重复编译性，我们不建议使用 __TIME__。

*__STDC__*

在正常操作中，这个宏展开为常数1，表示该编译器实现了ISO标准C。

*__STDC_VERSION__*

这个宏展开为C标准的版本号，是一个长整数常量，形式为yyyymmL，其中yyy和mm分别表示标准版本的年份和月份。
这指明了编译器实现的C标准的版本。

当前的默认值是201112L，表示C 2011标准。

*__STDC_HOSTED__*

如果编译器的目标是托管环境，那么这个宏被定义为1。托管环境提供了标准C库的全部功能。

一下预定义宏都是GNU C的扩展。

*__COUNTER__*

这个宏会展开为从0开始的连续整数值。换句话说，每次程序使用这个宏时，它都会生成下一个连续的整数。
结合##运算符，这为宏生成唯一标识符提供了方便的方法。

*__GNUC__*
*__GNUC_MINOR__*
*__GNUC_PATCHLEVEL__*

这些宏会展开为编译器的主版本、次版本和补丁版本，都表示为整数常量。
例如，GCC 3.2.1 会将 \__GNUC__ 展开为 3，\__GNUC_MINOR__ 展开为 2，\__GNUC_PATCHLEVEL__ 展开为 1。


如果您只需要知道您的程序是否由GCC编译，或者是否由声称接受GNU C扩展的非GCC编译器编译，
您可以简单地测试__GNUC__。如果您需要编写依赖于特定版本的代码，那么您必须进行更仔细的检查。
每次次版本更改都会将补丁级别重置为零；每次主版本更改（这种情况很少见）都会将次版本和补丁级别重置为零。
要直接在条件中使用预定义的宏，可以像这样编写：

#+begin_src c
/* Test for version 3.2.0 or later. */
#if __GNUC__ > 3 || \
    (__GNUC__ == 3 && (__GNUC_MINOR__ > 2 || \
                       (__GNUC_MINOR__ == 2 && \
                        __GNUC_PATCHLEVEL__ > 0))
#+end_src

另一种方法是使用预定义的宏来计算一个单一的数字，然后将其与一个阈值进行比较：

#+begin_src c
#define GCC_VERSION (__GNUC__ * 10000 \
                     + __GNUC_MINOR__ * 100 \
                     + __GNUC_PATCHLEVEL__)
/* … */
/* Test for GCC > 3.2.0 */
#if GCC_VERSION > 30200
#+end_src

许多人认为这种形式更容易理解。

*__VERSION__*

这个宏会展开为一个字符串常量，描述了正在使用的编译器的版本。
您不应该依赖其内容具有特定的形式，但您可以确保它至少包含了发布版本号。

*__TIMESTAMP__*

这个宏会展开为一个字符串常量，描述了当前源文件的最后修改日期和时间。
这个字符串常量包含缩写的星期几、月份、月份中的日期、hh:mm:ss 格式的时间，
以及年份，格式为 "Sun Sep 16 01:03:52 1973"。如果月份中的日期小于10，它会在左边用空格填充。

如果GCC无法确定日期和时间信息，它会发出一条警告消息（每次编译一次），
而 __TIMESTAMP__ 会展开为 "??? ??? ?? ??:??:?? ????"。

为了实现可重复编译性，我们不建议使用这个宏。

** 取消定义与重新定义

您可以使用 #undef 指令取消定义一个宏。#undef 接受一个参数，即要取消定义的宏的名称。
您使用宏的纯名称，即使该宏是类似函数的宏也是如此。如果在宏名称之后的行上出现任何内容，将会导致错误。
如果名称不是一个宏，#undef 不会产生任何影响。

#+begin_src c
#define FOO 4
x = FOO;        → x = 4;
#undef FOO
x = FOO;        → x = FOO;
#+end_src

一旦一个宏被取消定义，可以再次使用 #define 指令可以将该标识符重新定义为一个宏。新的定义不必与旧的定义有任何相似之处。

只有当新的宏定义与旧的宏定义在效果上是相同的情况下，你才能在不首先取消定义的情况下重新定义它。
两个宏定义在效果上是相同的，如果满足以下条件：

 * 它们都是相同类型的宏（对象宏或函数宏）。
 * 替换列表中的所有标记都相同。
 * 如果有任何参数，它们也是相同的。
 * 空格出现在相同的位置。尽管空格的数量不必完全相同，但需要注意注释也被视为空格。

这些定义在效果上是相同的:

#+begin_src c
#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* two */ + 2)
#+end_src

但这些不是:

#+begin_src c
#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
#+end_src

这允许两个不同的头文件定义一个共同的宏。

您可以使用 #define 重新定义一个已存在的宏，但如果使用不同的定义重新定义一个已存在的宏名称，将会产生一个警告。

** 宏参数内的指令


GNU C允许并处理宏参数中提供的文本中的预处理指令。这种情况在C标准中是未定义的，
但在GNU C中，宏参数中的条件指令是明确且有效的。

一个悖论的情况是在宏的调用内部重新定义宏。发生的情况是，新的定义在所有参数的预展开时生效，
然后原始定义被展开以替换调用。以下是一个病态示例：

#+begin_src c
#define f(x) x x
f (first f second
#undef f
#define f 2
f)
#+end_src

这将被展开为：

#+begin_src c
first 2 second 2 first 2 second 2
#+end_src


根据上述描述的语义，我们建议避免编写这种类型的代码。

** 宏陷阱

在这章节，我们将描述适用于宏和宏展开的一些特殊规则，并指出某些情况下这些规则会产生违反直觉的后果，您必须注意避免。

*** 嵌套错误

当以有参数的形式使用宏时，参数会被替换到宏的主体中，并将结果与宏所在的文件的其余部分一起检查，以查找更多的宏调用。
可以将一个宏调用从宏主体的一部分和参数的一部分组合在一起。例如，

#+begin_src c
#define twice(x) (2*(x))
#define call_with_1(x) x(1)
call_with_1 (twice)
     → twice(1)
     → (2*(1))
#+end_src

宏定义不必具有成对的括号。通过在宏主体中编写不成对的开括号，可以创建一个宏调用，它从宏主体内部开始，但在宏主体外部结束。例如，

#+begin_src c
#define strange(file) fprintf (file, "%s %d",
/* … */
strange(stderr) p, 35)
     → fprintf (stderr, "%s %d", p, 35)
#+end_src


能够组合一个宏调用的能力可能很有用，但在宏主体中使用不平衡的开括号只会导致混淆，应该避免这样做。
